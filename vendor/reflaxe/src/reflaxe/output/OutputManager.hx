// =======================================================
// * OutputManager
// =======================================================

package reflaxe.output;

#if (macro || reflaxe_runtime)

import haxe.io.BytesBuffer;
import haxe.macro.Context;

import reflaxe.BaseCompiler;

// ---

using Lambda;

using reflaxe.helpers.BaseTypeHelper;
using reflaxe.helpers.NullHelper;

typedef OutputMetadata = {
	/**
		The version of the output metadata format for Reflaxe.
	**/
	version: Int,

	/**
		This value is incremented every time Reflaxe compiles a target.
		Checking if this value has changed can check if Reflaxe has compiled.
	**/
	id: Int,

	/**
		If `true`, the most recent compilation was performed with cached modules.
	**/
	wasCached: Bool,

	/**
		A list of file paths to all the files generated by the Reflaxe target.
	**/
	filesGenerated: Array<String>,
}

/**
	Class containing all code related to generating the
	output files from the compiled classes.
**/
class OutputManager {
	// -------------------------------------------------------
	// constants
	public final GENERATED_LIST_FILENAME = "_GeneratedFiles.json";

	// -------------------------------------------------------
	// fields
	public var compiler(default, null): BaseCompiler;
	public var outputDir(default, null): Null<String> = null;

	var outputFiles: Array<String> = [];
	var outputMetadata: Null<OutputMetadata> = null;

	/**
		If any file is modified, created, or deleted, this should be set to `true`.
	**/
	var changed = false;

	/**
		The loaded count value from _GeneratedFiles.txt.
	**/
	var lastId = -1;

	// -------------------------------------------------------
	// getters
	var options(get, never): BaseCompilerOptions;
	function get_options(): BaseCompilerOptions return compiler.options;

	// -------------------------------------------------------
	// new
	public function new(compiler: BaseCompiler) {
		this.compiler = compiler;
	}

	// -------------------------------------------------------
	// joinPaths
	static function joinPaths(path1: String, path2: String): String {
		return haxe.io.Path.join([path1, path2]);
	}

	// -------------------------------------------------------
	// setOutputDir
	public function setOutputDir(outputDir: String) {
		this.outputDir = outputDir;
		checkForOldFiles();
	}

	/**
		Old output file management.
	**/
	function checkForOldFiles() {
		if(shouldDeleteOldOutput()) {
			outputMetadata = generatedFilesList();
			lastId = outputMetadata.id ?? -1;
		}
	}

	function shouldDeleteOldOutput() {
		return options.fileOutputType != SingleFile && options.deleteOldOutput;
	}

	function generatedFilesList(): OutputMetadata {
		final path = generatedFilesPath();
		if(sys.FileSystem.exists(path)) {
			return try {
				(haxe.Json.parse(sys.io.File.getContent(path)) : OutputMetadata);
			} catch(_) {
				defaultGeneratedData();
			}
		}
		return defaultGeneratedData();
	}

	function defaultGeneratedData(): OutputMetadata {
		return {
			version: 1,
			id: 0,
			wasCached: false,
			filesGenerated: []
		};
	}

	function generatedFilesPath() {
		return joinPaths(outputDir.or(""), GENERATED_LIST_FILENAME);
	}

	function ensureOutputDirExists() {
		if(outputDir != null && !sys.FileSystem.exists(outputDir)) {
			sys.FileSystem.createDirectory(outputDir);
		}
	}

	/**
		Generates the output files.
	**/
	public function generateFiles() {
		switch(options.fileOutputType) {
			case Manual: {
				compiler.generateFilesManually();
			}
			case SingleFile: {
				generateSingleFile();
			}
			case FilePerModule: {
				generateFilePerModule();
			}
			case FilePerClass: {
				generateFilePerClass();
			}
		}

		// Avoid key/value iteration (`for (k => v in map)`) here to prevent the compiler from
		// pulling in `haxe.iterators.MapKeyValueIterator` via `@:ifFeature`, which some targets
		// (including reflaxe.rust) do not currently emit.
		for(path in compiler.extraFiles.keys()) {
			final content = compiler.extraFiles.get(path);
			if(content == null) continue;

			final keys = [];
			for(priority in content.keys()) {
				final cpp = content.get(priority);
				if(StringTools.trim(cpp).length > 0) {
					keys.push(priority);
				}
			}

			keys.sort((a, b) -> a - b);

			var result = [];
			for(k in keys) {
				final c = content.get(k);
				if(c != null && StringTools.trim(c).length > 0) {
					result.push(c);
				}
			}

			saveFile(path, result.join("\n\n"));
		}

		if(shouldDeleteOldOutput()) {
			deleteOldOutputFiles();
			recordAllOutputMetadata();
		}
	}

	/**
		Generates a single file.

		This should be able to take no path, a file path, OR a directory path.
	**/
	function generateSingleFile() {
		var filePath = {
			// If output exists and ends with file-extension, it is a direct path
			if(outputDir != null && (options.fileOutputExtension.length == 0 || StringTools.endsWith(outputDir, options.fileOutputExtension))) {
				final file: String = haxe.io.Path.withoutDirectory(outputDir);
				outputDir = haxe.io.Path.directory(outputDir);
				file;
			}
			
			// Otherwise, it is a directory and use the default file name
			else {
				options.defaultOutputFilename;
			}
		}

		if(outputDir != null && outputDir.length > 0) {
			ensureOutputDirExists();
		}

		final arr = [];
		for(o in compiler.generateOutputIterator()) {
			arr.push(o.data);
		}
		saveFile(filePath, joinStringOrBytes(arr));
	}

	function generateFilePerModule() {
		ensureOutputDirExists();

		final files: Map<String, Array<StringOrBytes>> = [];
		for(c in compiler.generateOutputIterator()) {
			final mid = c.baseType.moduleId();
			final filename = overrideFileName(mid, c);
			#if debug_output_manager
			trace('[OutputManager] Processing class for module output:');
			trace('[OutputManager]   moduleId: ${mid}');
			trace('[OutputManager]   overrideFileName: ${c.overrideFileName}');
			trace('[OutputManager]   overrideDirectory: ${c.overrideDirectory}');
			trace('[OutputManager]   computed filename: ${filename}');
			var dataLen = switch(c.data.data()) {
				case String(s): s.length;
				case Bytes(b): b.length;
			};
			trace('[OutputManager]   data length: ${dataLen}');
			#end
			if(!files.exists(filename)) {
				files[filename] = [];
			}
			final f = files[filename];
			if(f != null) {
				f.push(c.data);
			}
		}

		#if debug_output_manager
		trace('[OutputManager] Files map ready. Checking entries...');
		for(k in files.keys()) {
			final v = files.get(k);
			if(v != null) {
				trace('[OutputManager] MAP KEY: ${k} (entries: ${v.length})');
			}
		}
		trace('[OutputManager] Writing files...');
		#end
		for(moduleId in files.keys()) {
			final outputList = files.get(moduleId);
			if(outputList == null) continue;
			#if debug_output_manager
			trace('[OutputManager] WRITE: ${getFileName(moduleId)}');
			#end
			saveFile(getFileName(moduleId), joinStringOrBytes(outputList));
		}
	}

	static function joinStringOrBytes(list: Array<StringOrBytes>): StringOrBytes {
		final strings = [];
		final bytes = [];
		for(o in list) {
			switch(o.data()) {
				case String(s): strings.push(s);
				case Bytes(b): bytes.push(b);
			}
		}

		if(strings.length > 0 && bytes.length > 0) {
			throw "Cannot mix String and Bytes outputs for join.";
		}

		return if(strings.length > 0) {
			strings.join("\n\n");
		} else if(bytes.length > 0) {
			final bb = new BytesBuffer();
			for(b in bytes) bb.add(b);
			bb.getBytes();
		} else {
			"";
		}
	}

	function generateFilePerClass() {
		ensureOutputDirExists();
		for(c in compiler.generateOutputIterator()) {
			final filename = overrideFileName(c.baseType.globalName(), c);
			#if debug_output_manager
			trace('[OutputManager] Writing file: ${getFileName(filename)}');
			trace('[OutputManager]   baseType.globalName: ${c.baseType.globalName()}');
			trace('[OutputManager]   overrideFileName: ${c.overrideFileName}');
			trace('[OutputManager]   overrideDirectory: ${c.overrideDirectory}');
			trace('[OutputManager]   final filename: ${filename}');
			#end
			saveFile(getFileName(filename), c.data);
		}
	}

	inline function overrideFileName(defaultName: String, o: {
		var overrideFileName(default, null): Null<String>;
		var overrideDirectory(default, null): Null<String>;
	}) {
		return (o.overrideDirectory != null ? o.overrideDirectory + "/" : "") + (o.overrideFileName ?? defaultName);
	}

	function getFileName(filename: String): String {
		return filename + options.fileOutputExtension;
	}

	/**
		Internal helper function for saving content to a path
		relative to the output folder.
	**/
	public function saveFile(path: String, content: StringOrBytes) {
		/**
		 * REFLAXE BUG FIX: Defensive path sanitization for malformed module filenames
		 * 
		 * PROBLEM:
		 * The generateFilePerModule() method can receive malformed filenames from
		 * getFileName(moduleId) where moduleId contains a leading slash. This creates
		 * invalid filesystem paths that attempt to write to the system root.
		 * 
		 * ROOT CAUSE ANALYSIS - WHY MALFORMED FILENAMES OCCUR:
		 * The issue originates from how Haxe processes certain standard library types
		 * during compilation, particularly when using regex literals like ~/pattern/:
		 * 
		 * 1. **Haxe Regex Literal Processing**: When Haxe encounters ~/pattern/, it
		 *    internally references the EReg class from the standard library
		 * 2. **Type Resolution Bug**: During macro-time type resolution, some standard
		 *    library types (especially EReg) get their BaseType.module field corrupted
		 * 3. **Module Name Corruption**: Instead of "EReg", the module becomes "/e_reg"
		 * 4. **Propagation Through Reflaxe**: This malformed name propagates through:
		 *    - BaseTypeHelper.moduleId() processes "/e_reg" → "/e_reg" 
		 *    - generateFilePerModule() calls getFileName("/e_reg") → "/e_reg.ex"
		 *    - saveFile() receives "/e_reg.ex" as filename
		 * 
		 * SUSPECTED HAXE COMPILER INTERACTION:
		 * This likely occurs due to:
		 * - Haxe's internal module name normalization conflicting with Reflaxe's expectations
		 * - Different handling of standard library vs user-defined types during macro expansion
		 * - Platform-specific path handling differences in Haxe 4.3.x macro context
		 * 
		 * PROBLEMATIC FLOW:
		 * 1. User writes: var r = ~/test/; (uses EReg implicitly)
		 * 2. Haxe type system: BaseType.module = "/e_reg" (should be "EReg")
		 * 3. BaseTypeHelper.moduleId() returns "/e_reg" (even after our primary fix)
		 * 4. getFileName("/e_reg") returns "/e_reg.ex" 
		 * 5. haxe.io.Path.isAbsolute("/e_reg.ex") returns true
		 * 6. saveFile() uses path as-is → tries to write "/e_reg.ex" at filesystem root
		 * 7. Result: "Uncaught exception /e_reg.ex: Read-only file system"
		 * 
		 * WHY OUTPUTMANAGER ALSO NEEDS THIS FIX:
		 * This is the SECOND layer of defense. Even though BaseTypeHelper.moduleId()
		 * sanitizes EReg's module name, we add this defensive check because:
		 * 1. Other code paths might bypass moduleId()
		 * 2. Future Haxe versions might corrupt other types similarly
		 * 3. Defensive programming prevents filesystem errors at the last moment
		 * 4. Two-layer defense ensures robustness
		 * 
		 * DEFENSIVE STRATEGY:
		 * Distinguish between legitimate absolute paths and malformed relative paths:
		 * - Legitimate: "/Users/john/project/file.ex", "/tmp/cache.ex", "/home/user/output.ex"
		 * - Malformed: "/e_reg.ex", "/some_type.ex" (these are corrupted module names)
		 * 
		 * EXAMPLES OF PATH CLASSIFICATION:
		 * - "/e_reg.ex" → Malformed relative path → "e_reg.ex" (sanitized)
		 * - "/some_module.ex" → Malformed relative path → "some_module.ex" (sanitized)  
		 * - "/Users/john/file.ex" → Real absolute path → "/Users/john/file.ex" (preserved)
		 * - "/tmp/output.ex" → Real absolute path → "/tmp/output.ex" (preserved)
		 * - "normal_file.ex" → Normal relative path → "normal_file.ex" (unchanged)
		 * 
		 * ALGORITHM:
		 * 1. If path starts with "/" AND length > 1:
		 * 2. Check if it looks like a real absolute path (/Users/, /tmp/, /var/, etc.)
		 * 3. If NOT a real absolute path, remove the leading "/" 
		 * 4. This converts malformed "/e_reg.ex" to proper "e_reg.ex"
		 * 
		 * IMPACT:
		 * - Prevents filesystem permission errors during compilation
		 * - Ensures all generated files go to the intended output directory
		 * - No impact on legitimate absolute paths
		 * - No impact on normal relative paths
		 * 
		 * LAYERED DEFENSE:
		 * This works in conjunction with the BaseTypeHelper.moduleId() fix:
		 * - Primary fix: Sanitize module names at source
		 * - Secondary fix: Sanitize file paths defensively here
		 * - Both fixes together ensure robust error handling
		 * 
		 * UPSTREAM STATUS:
		 * This is a defensive fix that should be contributed back to Reflaxe.
		 * The root cause of malformed module names should also be investigated
		 * in the Haxe compiler or Reflaxe's type processing.
		 * 
		 * Applied by: reflaxe.elixir project
		 * Date: 2025-01-18
		 */
		var sanitizedPath = path;
		if (StringTools.startsWith(path, "/") && path.length > 1) {
			// Check if this is a malformed relative path (starts with / but doesn't look like a real absolute path)
			var isRealAbsolutePath = StringTools.startsWith(path, "/Users/") || 
									StringTools.startsWith(path, "/tmp/") || 
									StringTools.startsWith(path, "/var/") || 
									StringTools.startsWith(path, "/home/") ||
									StringTools.startsWith(path, "/opt/");
			if (!isRealAbsolutePath) {
				sanitizedPath = path.substring(1); // Remove leading slash from malformed path
			}
		}
		
		// Get full path using sanitized input
		final p = if(haxe.io.Path.isAbsolute(sanitizedPath)) {
			sanitizedPath;
		} else if(outputDir != null) {
			joinPaths(outputDir, sanitizedPath);
		} else {
			sanitizedPath;
		}

		// Ensure directories exist
		final dir = haxe.io.Path.directory(p);
		if(!sys.FileSystem.exists(dir)) {
			sys.FileSystem.createDirectory(dir);
		}

		// Save file
		saveFileImpl(p, content);
	}

	function saveFileImpl(path: String, content: StringOrBytes) {
		// Do not save anything if the file already exists and has same content
		if(!sys.FileSystem.exists(path) || !content.matchesFile(path)) {
			content.save(path);
			changed = true;
		}
		if(shouldDeleteOldOutput()) {
			recordOutputFile(path);
		}
	}

	/**
		Records a path for a file that was generated.
		Ensures it will not be deleted when the rest of the old source files are removed.
	**/
	function recordOutputFile(path: String) {
		if(outputDir == null) return;
		final dir = StringTools.endsWith(outputDir, "/") ? outputDir : (outputDir + "/");
		final outputFilePath = StringTools.replace(path, dir, "");
		outputFiles.push(outputFilePath);

		if(outputMetadata != null) {
			#if !reflaxe.disallow_build_cache_check
			if(ReflectCompiler.isCachedRebuild) {
				// Don't modify `filesGenerated` if we are cache rebuilding.
			} else
			#end

			// -------------------------------------------------------
			// We overwrote this file if it existed, so we can
			// remove it from old files we're planning to delete.
			if(outputMetadata.filesGenerated.contains(outputFilePath)) {
				outputMetadata.filesGenerated.remove(outputFilePath);
			}
		}
	}

	/**
		We've removed elements from this array if we saved
		a new file with the same path, so we can safely assume
		all the remaining elements are old file paths we
		want to delete.
	**/
	function deleteOldOutputFiles() {
		#if !reflaxe.disallow_build_cache_check
		if(ReflectCompiler.isCachedRebuild) {
			return;
		}
		#end

		if(outputMetadata != null && outputDir != null) {
			for(file in outputMetadata.filesGenerated) {
				final filePath = joinPaths(outputDir, file);
				if(sys.FileSystem.exists(filePath)) {
					try {
						sys.FileSystem.deleteFile(filePath);
					} catch(e) {
						#if eval
						Context.warning('Could not delete file at "$filePath".\n$e', Context.currentPos());
						#end
					}
				}
			}
		}
	}

	function recordAllOutputMetadata() {
		if(!changed) {
			Sys.println("No files updated.");
		}

		if(outputFiles.length <= 0) {
			return;
		}

		final outputMetadata: OutputMetadata = {
			version: 1,
			id: #if !reflaxe.dont_output_metadata_id lastId + 1 #else 0 #end,
			wasCached: #if !reflaxe.disallow_build_cache_check ReflectCompiler.isCachedRebuild #else false #end,
			filesGenerated: [],
		};

		// -------------------------------------------------------
		// If this is a cache build, we cannot delete old files.
		// Instead add this to the list of files generated if it
		// doesn't exist.
		#if !reflaxe.disallow_build_cache_check
		if(ReflectCompiler.isCachedRebuild) {
			for(outputFile in outputFiles) {
				if(!outputMetadata.filesGenerated.contains(outputFile)) {
					outputMetadata.filesGenerated.push(outputFile);
				}
			}
			Sys.println("Only recompiled " + outputFiles.length + " file" + (outputFiles.length != 1 ? "s" : "") + ".");
		} else
		#end
		{
			outputMetadata.filesGenerated = outputFiles;
		}

		sys.io.File.saveContent(generatedFilesPath(), haxe.Json.stringify(outputMetadata, "\t"));
	}
}

#end
