// Generated by reflaxe.rust (POC)

#![allow(dead_code)]

type HxRef<T> = std::rc::Rc<std::cell::RefCell<T>>;

mod rust_option_tools;
mod rust_result_tools;
mod sys;

fn main() {
    let o: Option<i32> = Option::Some(10);
    let n: i32 = {
        let o_2: Option<i32> = {
            let _g: Option<i32> = match o.clone() {
                Option::Some(__p) => {
                    let _g_2: i32 = __p;
                    {
                        let v: i32 = _g_2;
                        Option::Some(v + 1)
                    }
                }
                Option::None => Option::None,
            };
            match _g.clone() {
                Option::Some(__p) => {
                    let _g_3: i32 = __p;
                    {
                        let v_2: i32 = _g_3;
                        if v_2 > 0 {
                            Option::Some(v_2 * 2)
                        } else {
                            Option::None
                        }
                    }
                }
                Option::None => Option::None,
            }
        };
        match o_2.clone() {
            Option::Some(__p) => {
                let _g_4: i32 = __p;
                {
                    let v_3: i32 = _g_4;
                    v_3
                }
            }
            Option::None => 0,
        }
    };
    let r: Result<i32, String> = Result::Ok(n);
    let r2: Result<i32, String> = {
        let _g_5: Result<i32, String> = match r.clone() {
            Result::Ok(__p) => {
                let _g_6: i32 = __p;
                {
                    let v_4: i32 = _g_6;
                    Result::Ok(v_4 + 5)
                }
            }
            Result::Err(__p) => {
                let _g_7: String = __p;
                {
                    let _e: String = _g_7;
                    Result::Err(_e.clone())
                }
            }
        };
        match _g_5.clone() {
            Result::Ok(__p) => {
                let _g_8: i32 = __p;
                {
                    let v_5: i32 = _g_8;
                    if v_5 > 100 {
                        Result::Err(String::from("too big"))
                    } else {
                        Result::Ok(v_5)
                    }
                }
            }
            Result::Err(__p) => {
                let _g_9: String = __p;
                {
                    let _e_2: String = _g_9;
                    Result::Err(_e_2.clone())
                }
            }
        }
    };
    let msg: i32 = {
        let _g_10: Result<i32, String> = match r2.clone() {
            Result::Ok(__p) => {
                let _g_11: i32 = __p;
                {
                    let v_6: i32 = _g_11;
                    Result::Ok(v_6)
                }
            }
            Result::Err(__p) => {
                let _g_12: String = __p;
                {
                    let e: String = _g_12;
                    Result::Err(
                        format!(
                            "{}{}",
                            format!("{}{}", String::from("computing value"), String::from(": ")),
                            e
                        )
                        .clone(),
                    )
                }
            }
        };
        match _g_10.clone() {
            Result::Ok(__p) => {
                let _g_13: i32 = __p;
                {
                    let v_7: i32 = _g_13;
                    v_7
                }
            }
            Result::Err(__p) => {
                let _g_14: String = __p;
                {
                    let _e_3: String = _g_14;
                    -1
                }
            }
        }
    };
    println!("{}", hxrt::dynamic::from(msg));
    let o2: Option<i32> = Option::None;
    let r3: Result<i32, String> = match o2.clone() {
        Option::Some(__p) => {
            let _g_15: i32 = __p;
            {
                let v_8: i32 = _g_15;
                Result::Ok(v_8)
            }
        }
        Option::None => Result::Err(String::from("missing")),
    };
    println!(
        "{}",
        hxrt::dynamic::from(
            !(match r3.clone() {
                Result::Ok(__p) => {
                    let _g_16: i32 = __p;
                    true
                }
                Result::Err(__p) => {
                    let _g_17: String = __p;
                    false
                }
            })
        )
    );
    let caught: Result<i32, String> = match hxrt::exception::catch_unwind(|| {
        Result::Ok({
            let x: i32 = 1;
            if x == 1 {
                hxrt::exception::throw(hxrt::dynamic::from(String::from("boom")));
            }
            x
        })
    }) {
        Ok(__hx_ok) => __hx_ok,
        Err(__hx_ex) => {
            let e_2: hxrt::dynamic::Dynamic = __hx_ex;
            Result::Err(e_2.to_haxe_string().clone())
        }
    };
    match caught.clone() {
        Result::Ok(__p) => {
            let _g_18: i32 = __p;
            {
                let v_9: i32 = _g_18;
                println!("{}", hxrt::dynamic::from(v_9));
            }
        }
        Result::Err(__p) => {
            let _g_19: String = __p;
            {
                let e_3: String = _g_19;
                println!("{}", hxrt::dynamic::from(e_3.clone()));
            }
        }
    }
}
