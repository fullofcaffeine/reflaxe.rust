// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0xfb16179cu32;

#[derive(Debug)]

pub struct Stdin {
    pub big_endian: bool,
}

impl Stdin {
    pub fn new() -> crate::HxRef<crate::sys_io_stdin::Stdin> {
        let self_: crate::HxRef<crate::sys_io_stdin::Stdin> =
            std::rc::Rc::new(std::cell::RefCell::new(Stdin { big_endian: false }));
        return self_;
    }

    pub fn read_byte(_self_: &std::cell::RefCell<Stdin>) -> i32 {
        let c: i32 = {
            use std::io::Read;
            let mut buf = [0u8; 1];
            match std::io::stdin().read(&mut buf) {
                Ok(0) => -1i32,
                Ok(_) => buf[0] as i32,
                Err(_) => -1i32,
            }
        };
        if c < 0 {
            hxrt::exception::throw(hxrt::dynamic::from(crate::haxe_io_eof::Eof::new()));
        }
        return c;
    }

    pub fn read_bytes(
        _self_: &std::cell::RefCell<Stdin>,
        s: crate::HxRef<hxrt::bytes::Bytes>,
        pos: i32,
        len: i32,
    ) -> i32 {
        if pos < 0 || len < 0 || pos + len > s.borrow().length() {
            hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::OutsideBounds));
        }
        if len == 0 {
            return 0;
        }
        return {
            use std::io::Read;
            let mut buf = vec![0u8; len as usize];
            match std::io::stdin().read(&mut buf) {
                Ok(n) => {
                    if n == 0 {
                        return 0i32;
                    }
                    let mut b = s.borrow_mut();
                    let base = pos as i32;
                    let mut i: usize = 0;
                    while i < n {
                        b.set(base + i as i32, buf[i] as i32);
                        i += 1;
                    }
                    n as i32
                }
                Err(_) => 0i32,
            }
        };
    }
}

impl crate::haxe_io_input::InputTrait for std::cell::RefCell<Stdin> {
    fn __hx_get_big_endian(&self) -> bool {
        self.borrow().big_endian
    }
    fn __hx_set_big_endian(&self, v: bool) {
        self.borrow_mut().big_endian = v;
    }
    fn read_byte(&self) -> i32 {
        Stdin::read_byte(self)
    }
    fn read_bytes(&self, s: crate::HxRef<hxrt::bytes::Bytes>, pos: i32, len: i32) -> i32 {
        Stdin::read_bytes(self, s, pos, len)
    }
    fn close(&self) -> () {
        todo!()
    }
    fn set_big_endian(&self, _: bool) -> bool {
        todo!()
    }
    fn read_all(&self, _: Option<i32>) -> crate::HxRef<hxrt::bytes::Bytes> {
        todo!()
    }
    fn read_full_bytes(&self, _: crate::HxRef<hxrt::bytes::Bytes>, _: i32, _: i32) -> () {
        todo!()
    }
    fn read(&self, _: i32) -> crate::HxRef<hxrt::bytes::Bytes> {
        todo!()
    }
    fn read_until(&self, _: i32) -> String {
        todo!()
    }
    fn read_line(&self) -> String {
        todo!()
    }
    fn read_float(&self) -> f64 {
        todo!()
    }
    fn read_double(&self) -> f64 {
        todo!()
    }
    fn read_int8(&self) -> i32 {
        todo!()
    }
    fn read_int16(&self) -> i32 {
        todo!()
    }
    fn read_u_int16(&self) -> i32 {
        todo!()
    }
    fn read_int24(&self) -> i32 {
        todo!()
    }
    fn read_u_int24(&self) -> i32 {
        todo!()
    }
    fn read_int32(&self) -> i32 {
        todo!()
    }
    fn read_string(&self, _: i32, _: Option<crate::haxe_io_encoding::Encoding>) -> String {
        todo!()
    }
    fn __hx_type_id(&self) -> u32 {
        crate::sys_io_stdin::__HX_TYPE_ID
    }
}
