// Generated by reflaxe.rust (POC)

#![allow(dead_code)]
#![allow(type_alias_bounds)]

type HxRc<T> = hxrt::cell::HxRc<T>;
type HxDynRef<T: ?Sized> = hxrt::cell::HxDynRef<T>;
type HxRefCell<T> = hxrt::cell::HxCell<T>;
type HxRef<T> = hxrt::cell::HxRef<T>;

mod date;
mod haxe_call_stack_call_stack_impl_;
mod haxe_ds_enum_value_map;
mod haxe_ds_int_map;
mod haxe_ds_object_map;
mod haxe_ds_string_map;
mod haxe_exception;
mod haxe_http_http_base;
mod haxe_i_map;
mod haxe_int64_int64;
mod haxe_int64_int64_impl_;
mod haxe_io_bytes_buffer;
mod haxe_io_bytes_output;
mod haxe_io_encoding;
mod haxe_io_eof;
mod haxe_io_fp_helper;
mod haxe_io_input;
mod haxe_io_output;
mod haxe_iterators_string_iterator;
mod haxe_iterators_string_key_value_iterator;
mod haxe_stack_item;
mod string_buf;
mod string_tools;
mod sys;
mod sys_http;
mod sys_io_stderr;
mod sys_io_stdin;
mod sys_io_stdout;
mod sys_net_host;
mod sys_net_socket;
mod sys_net_socket_input;
mod sys_net_socket_output;
mod sys_ssl_certificate;
mod sys_ssl_key;
mod sys_ssl_socket;
mod sys_thread_event_loop;
mod sys_thread_next_event_time;
mod sys_thread_thread;

fn main() {
    let server: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync> = {
        let __tmp = crate::sys_net_socket::Socket::new();
        let __up: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync> =
            match __tmp.as_arc_opt() {
                Some(__rc) => __rc.clone(),
                None => hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access"))),
            };
        __up
    };
    server.bind(
        crate::sys_net_host::Host::new(hxrt::string::HxString::from(hxrt::string::HxString::from(
            "127.0.0.1",
        ))),
        0,
    );
    server.listen(1);
    let port: i32 = server.host().borrow().get::<i32>("port");
    crate::sys_thread_thread::Thread::create({
        let __rc: crate::HxRc<dyn Fn() + Send + Sync> = crate::HxRc::new(move || {
            let client: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync> =
                server.accept();
            let req: hxrt::string::HxString = hxrt::string::HxString::from(
                client.__hx_get_input().read_all(None).borrow().to_string(),
            );
            if hxrt::string::index_of(
                req.as_str(),
                hxrt::string::HxString::from(hxrt::string::HxString::from("\r\n\r\n")).as_str(),
                None,
            ) < 0
            {
                client.close();
                server.close();
                return;
            }
            client.__hx_get_output().write_string(
                hxrt::string::HxString::from(hxrt::string::HxString::from(
                    "HTTP/1.1 200 OK\r\nContent-Length: 2\r\nConnection: close\r\n\r\nok",
                )),
                None,
            );
            client.close();
            server.close();
        });
        crate::HxDynRef::new(__rc)
    });
    let h: crate::HxRef<crate::sys_http::Http> = crate::sys_http::Http::new(
        hxrt::string::HxString::from(hxrt::string::HxString::from(format!(
            "{}{}{}",
            "http://127.0.0.1:",
            hxrt::dynamic::from(port).to_haxe_string(),
            "/"
        ))),
    );
    {
        let __tmp = {
            let __rc: crate::HxRc<dyn Fn(hxrt::string::HxString) + Send + Sync> =
                crate::HxRc::new(move |d: hxrt::string::HxString| {
                    crate::sys::Sys::println(hxrt::dynamic::from(d));
                });
            crate::HxDynRef::new(__rc)
        };
        h.borrow_mut().on_data = __tmp.clone();
        __tmp
    };
    {
        let __tmp = {
            let __rc: crate::HxRc<dyn Fn(hxrt::string::HxString) + Send + Sync> =
                crate::HxRc::new(move |e: hxrt::string::HxString| {
                    hxrt::exception::throw(hxrt::dynamic::from(e));
                });
            crate::HxDynRef::new(__rc)
        };
        h.borrow_mut().on_error = __tmp.clone();
        __tmp
    };
    crate::sys_http::Http::request(&*h, Some(false));
}
