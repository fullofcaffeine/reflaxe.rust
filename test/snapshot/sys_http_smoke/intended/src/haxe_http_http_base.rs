// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0xf37438f4u32;

pub struct HttpBase {
    pub url: String,
    pub response_bytes: crate::HxRef<hxrt::bytes::Bytes>,
    response_as_string: Option<String>,
    post_data: Option<String>,
    post_bytes: crate::HxRef<hxrt::bytes::Bytes>,
    headers: hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>>,
    params: hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>>,
    pub on_data: crate::HxDynRef<dyn Fn(String) + Send + Sync>,
    pub on_bytes: crate::HxDynRef<dyn Fn(crate::HxRef<hxrt::bytes::Bytes>) + Send + Sync>,
    pub on_error: crate::HxDynRef<dyn Fn(String) + Send + Sync>,
    pub on_status: crate::HxDynRef<dyn Fn(i32) + Send + Sync>,
}

impl HttpBase {
    pub fn new(url: String) -> crate::HxRef<crate::haxe_http_http_base::HttpBase> {
        let self_: crate::HxRef<crate::haxe_http_http_base::HttpBase> =
            crate::HxRef::new(HttpBase {
                url: url,
                response_bytes: crate::HxRef::<hxrt::bytes::Bytes>::null(),
                response_as_string: None,
                post_data: None,
                post_bytes: crate::HxRef::<hxrt::bytes::Bytes>::null(),
                headers: hxrt::array::Array::<crate::HxRef<hxrt::anon::Anon>>::new(),
                params: hxrt::array::Array::<crate::HxRef<hxrt::anon::Anon>>::new(),
                on_data: {
                    let __rc: crate::HxRc<dyn Fn(String) + Send + Sync> =
                        crate::HxRc::new(move |_a0| {});
                    crate::HxDynRef::new(__rc)
                },
                on_bytes: {
                    let __rc: crate::HxRc<dyn Fn(crate::HxRef<hxrt::bytes::Bytes>) + Send + Sync> =
                        crate::HxRc::new(move |_a0| {});
                    crate::HxDynRef::new(__rc)
                },
                on_error: {
                    let __rc: crate::HxRc<dyn Fn(String) + Send + Sync> =
                        crate::HxRc::new(move |_a0| {});
                    crate::HxDynRef::new(__rc)
                },
                on_status: {
                    let __rc: crate::HxRc<dyn Fn(i32) + Send + Sync> =
                        crate::HxRc::new(move |_a0| {});
                    crate::HxDynRef::new(__rc)
                },
            });
        {
            let __tmp = {
                let __rc: crate::HxRc<dyn Fn(String) + Send + Sync> =
                    crate::HxRc::new(move |_data: String| {});
                crate::HxDynRef::new(__rc)
            };
            self_.borrow_mut().on_data = __tmp.clone();
            __tmp
        };
        {
            let __tmp = {
                let __rc: crate::HxRc<dyn Fn(crate::HxRef<hxrt::bytes::Bytes>) + Send + Sync> =
                    crate::HxRc::new(move |_data: crate::HxRef<hxrt::bytes::Bytes>| {});
                crate::HxDynRef::new(__rc)
            };
            self_.borrow_mut().on_bytes = __tmp.clone();
            __tmp
        };
        {
            let __tmp = {
                let __rc: crate::HxRc<dyn Fn(String) + Send + Sync> =
                    crate::HxRc::new(move |_msg: String| {});
                crate::HxDynRef::new(__rc)
            };
            self_.borrow_mut().on_error = __tmp.clone();
            __tmp
        };
        {
            let __tmp = {
                let __rc: crate::HxRc<dyn Fn(i32) + Send + Sync> =
                    crate::HxRc::new(move |_status: i32| {});
                crate::HxDynRef::new(__rc)
            };
            self_.borrow_mut().on_status = __tmp.clone();
            __tmp
        };
        return self_;
    }

    pub fn set_header(self_: &crate::HxRefCell<HttpBase>, name: String, value: String) {
        let __hx_this: crate::HxRef<crate::haxe_http_http_base::HttpBase> = self_.self_ref();
        {
            let mut _g: i32 = 0;
            let _g1: i32 = ({
                let __b = __hx_this.borrow();
                __b.headers.clone()
            })
            .len() as i32;
            while _g < _g1 {
                let i: i32 = {
                    let __tmp = _g;
                    _g = _g + 1;
                    __tmp
                };
                if ({
                    let __b = __hx_this.borrow();
                    __b.headers.clone()
                })
                .get_unchecked(i as usize)
                .borrow()
                .get::<String>("name")
                    == name
                {
                    {
                        let __tmp = {
                            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
                            {
                                let mut __b = __o.borrow_mut();
                                __b.set("name", name.clone());
                                __b.set("value", value.clone());
                            };
                            __o
                        };
                        ({
                            let __b = __hx_this.borrow();
                            __b.headers.clone()
                        })
                        .set_haxe(i as usize, __tmp.clone(), move || crate::HxRef::null());
                        __tmp
                    };
                    return;
                }
            }
        }
        ({
            let __b = __hx_this.borrow();
            __b.headers.clone()
        })
        .push({
            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
            {
                let mut __b = __o.borrow_mut();
                __b.set("name", name.clone());
                __b.set("value", value.clone());
            };
            __o
        });
    }

    pub fn add_header(self_: &crate::HxRefCell<HttpBase>, header: String, value: String) {
        let __hx_this: crate::HxRef<crate::haxe_http_http_base::HttpBase> = self_.self_ref();
        ({
            let __b = __hx_this.borrow();
            __b.headers.clone()
        })
        .push({
            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
            {
                let mut __b = __o.borrow_mut();
                __b.set("name", header);
                __b.set("value", value);
            };
            __o
        });
    }

    pub fn set_parameter(self_: &crate::HxRefCell<HttpBase>, name: String, value: String) {
        let __hx_this: crate::HxRef<crate::haxe_http_http_base::HttpBase> = self_.self_ref();
        {
            let mut _g: i32 = 0;
            let _g1: i32 = ({
                let __b = __hx_this.borrow();
                __b.params.clone()
            })
            .len() as i32;
            while _g < _g1 {
                let i: i32 = {
                    let __tmp = _g;
                    _g = _g + 1;
                    __tmp
                };
                if ({
                    let __b = __hx_this.borrow();
                    __b.params.clone()
                })
                .get_unchecked(i as usize)
                .borrow()
                .get::<String>("name")
                    == name
                {
                    {
                        let __tmp = {
                            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
                            {
                                let mut __b = __o.borrow_mut();
                                __b.set("name", name.clone());
                                __b.set("value", value.clone());
                            };
                            __o
                        };
                        ({
                            let __b = __hx_this.borrow();
                            __b.params.clone()
                        })
                        .set_haxe(i as usize, __tmp.clone(), move || crate::HxRef::null());
                        __tmp
                    };
                    return;
                }
            }
        }
        ({
            let __b = __hx_this.borrow();
            __b.params.clone()
        })
        .push({
            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
            {
                let mut __b = __o.borrow_mut();
                __b.set("name", name.clone());
                __b.set("value", value.clone());
            };
            __o
        });
    }

    pub fn add_parameter(self_: &crate::HxRefCell<HttpBase>, name: String, value: String) {
        let __hx_this: crate::HxRef<crate::haxe_http_http_base::HttpBase> = self_.self_ref();
        ({
            let __b = __hx_this.borrow();
            __b.params.clone()
        })
        .push({
            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
            {
                let mut __b = __o.borrow_mut();
                __b.set("name", name);
                __b.set("value", value);
            };
            __o
        });
    }

    pub fn set_post_data(self_: &crate::HxRefCell<HttpBase>, data: Option<String>) {
        let __hx_this: crate::HxRef<crate::haxe_http_http_base::HttpBase> = self_.self_ref();
        {
            let __tmp = data;
            __hx_this.borrow_mut().post_data = __tmp.clone();
            __tmp
        };
        {
            let __tmp = crate::HxRef::<hxrt::bytes::Bytes>::null();
            __hx_this.borrow_mut().post_bytes = __tmp.clone();
            __tmp
        };
    }

    pub fn set_post_bytes(
        self_: &crate::HxRefCell<HttpBase>,
        data: crate::HxRef<hxrt::bytes::Bytes>,
    ) {
        let __hx_this: crate::HxRef<crate::haxe_http_http_base::HttpBase> = self_.self_ref();
        {
            let __tmp = data;
            __hx_this.borrow_mut().post_bytes = __tmp.clone();
            __tmp
        };
        {
            let __tmp = None;
            __hx_this.borrow_mut().post_data = __tmp.clone();
            __tmp
        };
    }

    pub fn request(self_: &crate::HxRefCell<HttpBase>, _post: Option<bool>) {
        let __hx_this: crate::HxRef<crate::haxe_http_http_base::HttpBase> = self_.self_ref();
        ({
            let __b = __hx_this.borrow();
            __b.on_error.clone()
        })(String::from(
            "HttpBase.request is not implemented on this target",
        ));
    }

    fn success(self_: &crate::HxRefCell<HttpBase>, data: crate::HxRef<hxrt::bytes::Bytes>) {
        let __hx_this: crate::HxRef<crate::haxe_http_http_base::HttpBase> = self_.self_ref();
        {
            let __tmp = data.clone();
            __hx_this.borrow_mut().response_bytes = __tmp.clone();
            __tmp
        };
        let s: String = data.borrow().to_string();
        {
            let __tmp = s.clone();
            __hx_this.borrow_mut().response_as_string = Some(__tmp.clone());
            __tmp
        };
        ({
            let __b = __hx_this.borrow();
            __b.on_data.clone()
        })(s.clone());
        ({
            let __b = __hx_this.borrow();
            __b.on_bytes.clone()
        })(data.clone());
    }

    pub fn get_response_data(self_: &crate::HxRefCell<HttpBase>) -> Option<String> {
        let __hx_this: crate::HxRef<crate::haxe_http_http_base::HttpBase> = self_.self_ref();
        return {
            let __b = __hx_this.borrow();
            __b.response_as_string.clone()
        };
    }
}

pub trait HttpBaseTrait: Send + Sync {
    fn __hx_get_url(&self) -> String;
    fn __hx_set_url(&self, v: String);
    fn __hx_get_response_bytes(&self) -> crate::HxRef<hxrt::bytes::Bytes>;
    fn __hx_set_response_bytes(&self, v: crate::HxRef<hxrt::bytes::Bytes>);
    fn __hx_get_response_as_string(&self) -> Option<String>;
    fn __hx_set_response_as_string(&self, v: Option<String>);
    fn __hx_get_post_data(&self) -> Option<String>;
    fn __hx_set_post_data(&self, v: Option<String>);
    fn __hx_get_post_bytes(&self) -> crate::HxRef<hxrt::bytes::Bytes>;
    fn __hx_set_post_bytes(&self, v: crate::HxRef<hxrt::bytes::Bytes>);
    fn __hx_get_headers(&self) -> hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>>;
    fn __hx_set_headers(&self, v: hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>>);
    fn __hx_get_params(&self) -> hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>>;
    fn __hx_set_params(&self, v: hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>>);
    fn __hx_get_on_data(&self) -> crate::HxDynRef<dyn Fn(String) + Send + Sync>;
    fn __hx_set_on_data(&self, v: crate::HxDynRef<dyn Fn(String) + Send + Sync>);
    fn __hx_get_on_bytes(
        &self,
    ) -> crate::HxDynRef<dyn Fn(crate::HxRef<hxrt::bytes::Bytes>) + Send + Sync>;
    fn __hx_set_on_bytes(
        &self,
        v: crate::HxDynRef<dyn Fn(crate::HxRef<hxrt::bytes::Bytes>) + Send + Sync>,
    );
    fn __hx_get_on_error(&self) -> crate::HxDynRef<dyn Fn(String) + Send + Sync>;
    fn __hx_set_on_error(&self, v: crate::HxDynRef<dyn Fn(String) + Send + Sync>);
    fn __hx_get_on_status(&self) -> crate::HxDynRef<dyn Fn(i32) + Send + Sync>;
    fn __hx_set_on_status(&self, v: crate::HxDynRef<dyn Fn(i32) + Send + Sync>);
    fn set_header(&self, name: String, value: String) -> ();
    fn add_header(&self, header: String, value: String) -> ();
    fn set_parameter(&self, name: String, value: String) -> ();
    fn add_parameter(&self, name: String, value: String) -> ();
    fn set_post_data(&self, data: Option<String>) -> ();
    fn set_post_bytes(&self, data: crate::HxRef<hxrt::bytes::Bytes>) -> ();
    fn request(&self, _post: Option<bool>) -> ();
    fn success(&self, data: crate::HxRef<hxrt::bytes::Bytes>) -> ();
    fn get_response_data(&self) -> Option<String>;
    fn __hx_type_id(&self) -> u32;
}

impl crate::haxe_http_http_base::HttpBaseTrait for crate::HxRefCell<HttpBase> {
    fn __hx_get_url(&self) -> String {
        self.borrow().url.clone()
    }
    fn __hx_set_url(&self, v: String) {
        self.borrow_mut().url = v;
    }
    fn __hx_get_response_bytes(&self) -> crate::HxRef<hxrt::bytes::Bytes> {
        self.borrow().response_bytes.clone()
    }
    fn __hx_set_response_bytes(&self, v: crate::HxRef<hxrt::bytes::Bytes>) {
        self.borrow_mut().response_bytes = v;
    }
    fn __hx_get_response_as_string(&self) -> Option<String> {
        self.borrow().response_as_string.clone()
    }
    fn __hx_set_response_as_string(&self, v: Option<String>) {
        self.borrow_mut().response_as_string = v;
    }
    fn __hx_get_post_data(&self) -> Option<String> {
        self.borrow().post_data.clone()
    }
    fn __hx_set_post_data(&self, v: Option<String>) {
        self.borrow_mut().post_data = v;
    }
    fn __hx_get_post_bytes(&self) -> crate::HxRef<hxrt::bytes::Bytes> {
        self.borrow().post_bytes.clone()
    }
    fn __hx_set_post_bytes(&self, v: crate::HxRef<hxrt::bytes::Bytes>) {
        self.borrow_mut().post_bytes = v;
    }
    fn __hx_get_headers(&self) -> hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>> {
        self.borrow().headers.clone()
    }
    fn __hx_set_headers(&self, v: hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>>) {
        self.borrow_mut().headers = v;
    }
    fn __hx_get_params(&self) -> hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>> {
        self.borrow().params.clone()
    }
    fn __hx_set_params(&self, v: hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>>) {
        self.borrow_mut().params = v;
    }
    fn __hx_get_on_data(&self) -> crate::HxDynRef<dyn Fn(String) + Send + Sync> {
        self.borrow().on_data.clone()
    }
    fn __hx_set_on_data(&self, v: crate::HxDynRef<dyn Fn(String) + Send + Sync>) {
        self.borrow_mut().on_data = v;
    }
    fn __hx_get_on_bytes(
        &self,
    ) -> crate::HxDynRef<dyn Fn(crate::HxRef<hxrt::bytes::Bytes>) + Send + Sync> {
        self.borrow().on_bytes.clone()
    }
    fn __hx_set_on_bytes(
        &self,
        v: crate::HxDynRef<dyn Fn(crate::HxRef<hxrt::bytes::Bytes>) + Send + Sync>,
    ) {
        self.borrow_mut().on_bytes = v;
    }
    fn __hx_get_on_error(&self) -> crate::HxDynRef<dyn Fn(String) + Send + Sync> {
        self.borrow().on_error.clone()
    }
    fn __hx_set_on_error(&self, v: crate::HxDynRef<dyn Fn(String) + Send + Sync>) {
        self.borrow_mut().on_error = v;
    }
    fn __hx_get_on_status(&self) -> crate::HxDynRef<dyn Fn(i32) + Send + Sync> {
        self.borrow().on_status.clone()
    }
    fn __hx_set_on_status(&self, v: crate::HxDynRef<dyn Fn(i32) + Send + Sync>) {
        self.borrow_mut().on_status = v;
    }
    fn set_header(&self, name: String, value: String) -> () {
        HttpBase::set_header(self, name, value)
    }
    fn add_header(&self, header: String, value: String) -> () {
        HttpBase::add_header(self, header, value)
    }
    fn set_parameter(&self, name: String, value: String) -> () {
        HttpBase::set_parameter(self, name, value)
    }
    fn add_parameter(&self, name: String, value: String) -> () {
        HttpBase::add_parameter(self, name, value)
    }
    fn set_post_data(&self, data: Option<String>) -> () {
        HttpBase::set_post_data(self, data)
    }
    fn set_post_bytes(&self, data: crate::HxRef<hxrt::bytes::Bytes>) -> () {
        HttpBase::set_post_bytes(self, data)
    }
    fn request(&self, _post: Option<bool>) -> () {
        HttpBase::request(self, _post)
    }
    fn success(&self, data: crate::HxRef<hxrt::bytes::Bytes>) -> () {
        HttpBase::success(self, data)
    }
    fn get_response_data(&self) -> Option<String> {
        HttpBase::get_response_data(self)
    }
    fn __hx_type_id(&self) -> u32 {
        crate::haxe_http_http_base::__HX_TYPE_ID
    }
}
