// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0x8c46fc34u32;

#[derive(Debug)]

pub struct EventLoop {
    _thread_id: i32,
}

impl EventLoop {
    pub fn new() -> crate::HxRef<crate::sys_thread_event_loop::EventLoop> {
        let self_: crate::HxRef<crate::sys_thread_event_loop::EventLoop> =
            crate::HxRc::new(crate::HxRefCell::new(EventLoop { _thread_id: 0 }));
        {
            let __tmp = hxrt::thread::thread_current_id();
            self_.borrow_mut()._thread_id = __tmp;
            __tmp
        };
        return self_;
    }

    pub fn repeat(
        self_: &crate::HxRefCell<EventLoop>,
        event: crate::HxRc<dyn Fn() + Send + Sync>,
        interval_ms: i32,
    ) -> i32 {
        let id: i32 =
            hxrt::thread::event_loop_repeat(self_.borrow()._thread_id, event, interval_ms);
        return id as i32;
    }

    pub fn cancel(self_: &crate::HxRefCell<EventLoop>, event_handler: i32) {
        let id: i32 = event_handler as i32;
        hxrt::thread::event_loop_cancel(self_.borrow()._thread_id, id);
    }

    pub fn promise(self_: &crate::HxRefCell<EventLoop>) {
        hxrt::thread::event_loop_promise(self_.borrow()._thread_id);
    }

    pub fn run(self_: &crate::HxRefCell<EventLoop>, event: crate::HxRc<dyn Fn() + Send + Sync>) {
        hxrt::thread::event_loop_run(self_.borrow()._thread_id, event);
    }

    pub fn run_promised(
        self_: &crate::HxRefCell<EventLoop>,
        event: crate::HxRc<dyn Fn() + Send + Sync>,
    ) {
        hxrt::thread::event_loop_run_promised(self_.borrow()._thread_id, event);
    }

    pub fn progress(
        self_: &crate::HxRefCell<EventLoop>,
    ) -> crate::sys_thread_next_event_time::NextEventTime {
        let next_at: f64 = hxrt::thread::event_loop_progress(self_.borrow()._thread_id);
        return if next_at == -2.0 {
            crate::sys_thread_next_event_time::NextEventTime::Now
        } else {
            if next_at == -1.0 {
                crate::sys_thread_next_event_time::NextEventTime::Never
            } else {
                if next_at == -3.0 {
                    crate::sys_thread_next_event_time::NextEventTime::AnyTime(None)
                } else {
                    crate::sys_thread_next_event_time::NextEventTime::At(next_at)
                }
            }
        };
    }

    pub fn wait(self_: &crate::HxRefCell<EventLoop>, timeout: Option<f64>) -> bool {
        return hxrt::thread::event_loop_wait(self_.borrow()._thread_id, timeout);
    }

    pub fn loop_(self_: &crate::HxRefCell<EventLoop>) {
        hxrt::thread::event_loop_loop(self_.borrow()._thread_id);
    }

    pub(crate) fn _from_thread_id(
        thread_id: i32,
    ) -> crate::HxRef<crate::sys_thread_event_loop::EventLoop> {
        let loop_: crate::HxRef<crate::sys_thread_event_loop::EventLoop> =
            crate::sys_thread_event_loop::EventLoop::new();
        {
            let __tmp = thread_id;
            loop_.borrow_mut()._thread_id = __tmp;
            __tmp
        };
        return loop_;
    }
}
