// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0x8c46fc34u32;

#[derive(Debug)]

pub struct EventLoop {
    _thread_id: i32,
}

impl EventLoop {
    pub fn new() -> crate::HxRef<crate::sys_thread_event_loop::EventLoop> {
        let self_: crate::HxRef<crate::sys_thread_event_loop::EventLoop> =
            crate::HxRef::new(EventLoop { _thread_id: 0 });
        {
            let __tmp = hxrt::thread::thread_current_id();
            self_.borrow_mut()._thread_id = __tmp;
            __tmp
        };
        return self_;
    }

    pub fn repeat(
        self_: &crate::HxRefCell<EventLoop>,
        event: crate::HxDynRef<dyn Fn() + Send + Sync>,
        interval_ms: i32,
    ) -> i32 {
        let __hx_this: crate::HxRef<crate::sys_thread_event_loop::EventLoop> = self_.self_ref();
        let id: i32 = hxrt::thread::event_loop_repeat(
            {
                let __b = __hx_this.borrow();
                __b._thread_id
            },
            event,
            interval_ms,
        );
        return id as i32;
    }

    pub fn cancel(self_: &crate::HxRefCell<EventLoop>, event_handler: i32) {
        let __hx_this: crate::HxRef<crate::sys_thread_event_loop::EventLoop> = self_.self_ref();
        let id: i32 = event_handler as i32;
        hxrt::thread::event_loop_cancel(
            {
                let __b = __hx_this.borrow();
                __b._thread_id
            },
            id,
        );
    }

    pub fn promise(self_: &crate::HxRefCell<EventLoop>) {
        let __hx_this: crate::HxRef<crate::sys_thread_event_loop::EventLoop> = self_.self_ref();
        hxrt::thread::event_loop_promise({
            let __b = __hx_this.borrow();
            __b._thread_id
        });
    }

    pub fn run(
        self_: &crate::HxRefCell<EventLoop>,
        event: crate::HxDynRef<dyn Fn() + Send + Sync>,
    ) {
        let __hx_this: crate::HxRef<crate::sys_thread_event_loop::EventLoop> = self_.self_ref();
        hxrt::thread::event_loop_run(
            {
                let __b = __hx_this.borrow();
                __b._thread_id
            },
            event,
        );
    }

    pub fn run_promised(
        self_: &crate::HxRefCell<EventLoop>,
        event: crate::HxDynRef<dyn Fn() + Send + Sync>,
    ) {
        let __hx_this: crate::HxRef<crate::sys_thread_event_loop::EventLoop> = self_.self_ref();
        hxrt::thread::event_loop_run_promised(
            {
                let __b = __hx_this.borrow();
                __b._thread_id
            },
            event,
        );
    }

    pub fn progress(
        self_: &crate::HxRefCell<EventLoop>,
    ) -> crate::sys_thread_next_event_time::NextEventTime {
        let __hx_this: crate::HxRef<crate::sys_thread_event_loop::EventLoop> = self_.self_ref();
        let next_at: f64 = hxrt::thread::event_loop_progress({
            let __b = __hx_this.borrow();
            __b._thread_id
        });
        return if next_at == -2.0 {
            crate::sys_thread_next_event_time::NextEventTime::Now
        } else {
            if next_at == -1.0 {
                crate::sys_thread_next_event_time::NextEventTime::Never
            } else {
                if next_at == -3.0 {
                    crate::sys_thread_next_event_time::NextEventTime::AnyTime(None)
                } else {
                    crate::sys_thread_next_event_time::NextEventTime::At(next_at)
                }
            }
        };
    }

    pub fn wait(self_: &crate::HxRefCell<EventLoop>, timeout: Option<f64>) -> bool {
        let __hx_this: crate::HxRef<crate::sys_thread_event_loop::EventLoop> = self_.self_ref();
        return hxrt::thread::event_loop_wait(
            {
                let __b = __hx_this.borrow();
                __b._thread_id
            },
            timeout,
        );
    }

    pub fn loop_(self_: &crate::HxRefCell<EventLoop>) {
        let __hx_this: crate::HxRef<crate::sys_thread_event_loop::EventLoop> = self_.self_ref();
        hxrt::thread::event_loop_loop({
            let __b = __hx_this.borrow();
            __b._thread_id
        });
    }

    pub(crate) fn _from_thread_id(
        thread_id: i32,
    ) -> crate::HxRef<crate::sys_thread_event_loop::EventLoop> {
        let loop_: crate::HxRef<crate::sys_thread_event_loop::EventLoop> =
            crate::sys_thread_event_loop::EventLoop::new();
        {
            let __tmp = thread_id;
            loop_.borrow_mut()._thread_id = __tmp;
            __tmp
        };
        return loop_;
    }
}
