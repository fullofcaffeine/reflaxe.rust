// Generated by reflaxe.rust (POC)

static __HX_STATIC_DEFAULT_VERIFY_CERT: std::sync::OnceLock<hxrt::cell::HxCell<Option<bool>>> =
    std::sync::OnceLock::new();
fn __hx_static_cell_default_verify_cert() -> &'static hxrt::cell::HxCell<Option<bool>> {
    __HX_STATIC_DEFAULT_VERIFY_CERT.get_or_init(|| hxrt::cell::HxCell::new(None))
}
pub(crate) fn __hx_static_get_default_verify_cert() -> Option<bool> {
    __hx_static_cell_default_verify_cert().borrow().clone()
}
pub(crate) fn __hx_static_set_default_verify_cert(value: Option<bool>) {
    *__hx_static_cell_default_verify_cert().borrow_mut() = value;
}

static __HX_STATIC_DEFAULT_CA: std::sync::OnceLock<
    hxrt::cell::HxCell<crate::HxRef<crate::sys_ssl_certificate::Certificate>>,
> = std::sync::OnceLock::new();
fn __hx_static_cell_default_ca(
) -> &'static hxrt::cell::HxCell<crate::HxRef<crate::sys_ssl_certificate::Certificate>> {
    __HX_STATIC_DEFAULT_CA.get_or_init(|| {
        hxrt::cell::HxCell::new(crate::HxRef::<crate::sys_ssl_certificate::Certificate>::null())
    })
}
pub(crate) fn __hx_static_get_default_ca() -> crate::HxRef<crate::sys_ssl_certificate::Certificate>
{
    __hx_static_cell_default_ca().borrow().clone()
}
pub(crate) fn __hx_static_set_default_ca(
    value: crate::HxRef<crate::sys_ssl_certificate::Certificate>,
) {
    *__hx_static_cell_default_ca().borrow_mut() = value;
}

pub const __HX_TYPE_ID: u32 = 0x9c467869u32;

pub struct Socket {
    pub input: Option<crate::HxRc<dyn crate::haxe_io_input::InputTrait + Send + Sync>>,
    pub output: Option<crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync>>,
    pub custom: hxrt::dynamic::Dynamic,
    handle: crate::HxRef<hxrt::net::SocketHandle>,
    pub verify_cert: Option<bool>,
    ca: crate::HxRef<crate::sys_ssl_certificate::Certificate>,
    hostname: Option<String>,
    server_cert: crate::HxRef<crate::sys_ssl_certificate::Certificate>,
    server_key: crate::HxRef<crate::sys_ssl_key::Key>,
}

impl Socket {
    pub fn new() -> crate::HxRef<crate::sys_ssl_socket::Socket> {
        let self_: crate::HxRef<crate::sys_ssl_socket::Socket> = crate::HxRef::new(Socket {
            input: None,
            output: None,
            custom: hxrt::dynamic::Dynamic::null(),
            handle: Default::default(),
            verify_cert: None,
            ca: crate::HxRef::<crate::sys_ssl_certificate::Certificate>::null(),
            hostname: None,
            server_cert: crate::HxRef::<crate::sys_ssl_certificate::Certificate>::null(),
            server_key: crate::HxRef::<crate::sys_ssl_key::Key>::null(),
        });
        {
            let __tmp = hxrt::dynamic::Dynamic::null();
            self_.borrow_mut().custom = __tmp.clone();
            __tmp
        };
        let h: crate::HxRef<hxrt::net::SocketHandle> = hxrt::net::socket_new_tcp();
        {
            let __tmp = h.clone();
            self_.borrow_mut().handle = __tmp.clone();
            __tmp
        };
        {
            let __tmp = crate::sys_net_socket_input::SocketInput::new(h.clone());
            self_.borrow_mut().input = Some({
                let __tmp = __tmp.clone();
                let __up: crate::HxRc<dyn crate::haxe_io_input::InputTrait + Send + Sync> =
                    match __tmp.as_arc_opt() {
                        Some(__rc) => __rc.clone(),
                        None => {
                            hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access")))
                        }
                    };
                __up
            });
            __tmp
        };
        {
            let __tmp = crate::sys_net_socket_output::SocketOutput::new(h.clone());
            self_.borrow_mut().output = Some({
                let __tmp = __tmp.clone();
                let __up: crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync> =
                    match __tmp.as_arc_opt() {
                        Some(__rc) => __rc.clone(),
                        None => {
                            hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access")))
                        }
                    };
                __up
            });
            __tmp
        };
        return self_;
    }

    pub fn handshake(self_: &crate::HxRefCell<Socket>) {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        let verify: bool = ({
            let __b = __hx_this.borrow();
            __b.verify_cert.clone()
        }) != Some(false);
        if !({
            let __b = __hx_this.borrow();
            __b.server_cert.clone()
        })
        .is_null()
            && !({
                let __b = __hx_this.borrow();
                __b.server_key.clone()
            })
            .is_null()
        {
            {
                let cert_handle = {
                    let __b = __hx_this.borrow();
                    __b.server_cert.clone()
                }
                .borrow()
                .handle
                .clone();
                let key_handle = {
                    let __b = __hx_this.borrow();
                    __b.server_key.clone()
                }
                .borrow()
                .handle
                .clone();
                {
                    let __b = __hx_this.borrow();
                    __b.handle.clone()
                }
                .borrow_mut()
                .tls_handshake_server(cert_handle, key_handle);
            };
            return;
        }
        {
            let ca_handle = match {
                let __b = __hx_this.borrow();
                __b.ca.clone()
            }
            .as_arc_opt()
            {
                None => None,
                Some(c) => Some(c.borrow().handle.clone()),
            };
            {
                let __b = __hx_this.borrow();
                __b.handle.clone()
            }
            .borrow_mut()
            .tls_handshake_client(
                {
                    let __b = __hx_this.borrow();
                    __b.hostname.clone()
                },
                Some(verify as bool),
                ca_handle,
            );
        };
    }

    pub fn set_ca(
        self_: &crate::HxRefCell<Socket>,
        cert: crate::HxRef<crate::sys_ssl_certificate::Certificate>,
    ) {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        {
            let __tmp = cert;
            __hx_this.borrow_mut().ca = __tmp.clone();
            __tmp
        };
    }

    pub fn set_hostname(self_: &crate::HxRefCell<Socket>, name: String) {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        {
            let __tmp = name;
            __hx_this.borrow_mut().hostname = Some(__tmp.clone());
            __tmp
        };
    }

    pub fn set_certificate(
        self_: &crate::HxRefCell<Socket>,
        cert: crate::HxRef<crate::sys_ssl_certificate::Certificate>,
        key: crate::HxRef<crate::sys_ssl_key::Key>,
    ) {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        {
            let __tmp = cert;
            __hx_this.borrow_mut().server_cert = __tmp.clone();
            __tmp
        };
        {
            let __tmp = key;
            __hx_this.borrow_mut().server_key = __tmp.clone();
            __tmp
        };
    }

    pub fn add_sni_certificate(
        _self_: &crate::HxRefCell<Socket>,
        _cb_servername_match: crate::HxDynRef<dyn Fn(String) -> bool + Send + Sync>,
        _cert: crate::HxRef<crate::sys_ssl_certificate::Certificate>,
        _key: crate::HxRef<crate::sys_ssl_key::Key>,
    ) {
        hxrt::exception::throw(hxrt::dynamic::from(String::from(
            "sys.ssl.Socket.addSNICertificate is not implemented yet on reflaxe.rust",
        )));
    }

    pub fn peer_certificate(
        self_: &crate::HxRefCell<Socket>,
    ) -> crate::HxRef<crate::sys_ssl_certificate::Certificate> {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        let h: crate::HxRef<hxrt::ssl::Certificate> = {
            let __b = __hx_this.borrow();
            __b.handle.clone()
        }
        .borrow()
        .tls_peer_certificate();
        return crate::sys_ssl_certificate::Certificate::from_handle(h.clone());
    }

    pub fn accept(self_: &crate::HxRefCell<Socket>) -> crate::HxRef<crate::sys_ssl_socket::Socket> {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        let h: crate::HxRef<hxrt::net::SocketHandle> = {
            let __b = __hx_this.borrow();
            __b.handle.clone()
        }
        .borrow_mut()
        .accept();
        let s: crate::HxRef<crate::sys_ssl_socket::Socket> = crate::sys_ssl_socket::Socket::new();
        {
            let __tmp = h.clone();
            s.borrow_mut().handle = __tmp.clone();
            __tmp
        };
        {
            let __tmp = crate::sys_net_socket_input::SocketInput::new(h.clone());
            s.borrow_mut().input = Some({
                let __tmp = __tmp.clone();
                let __up: crate::HxRc<dyn crate::haxe_io_input::InputTrait + Send + Sync> =
                    match __tmp.as_arc_opt() {
                        Some(__rc) => __rc.clone(),
                        None => {
                            hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access")))
                        }
                    };
                __up
            });
            __tmp
        };
        {
            let __tmp = crate::sys_net_socket_output::SocketOutput::new(h.clone());
            s.borrow_mut().output = Some({
                let __tmp = __tmp.clone();
                let __up: crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync> =
                    match __tmp.as_arc_opt() {
                        Some(__rc) => __rc.clone(),
                        None => {
                            hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access")))
                        }
                    };
                __up
            });
            __tmp
        };
        return s;
    }

    pub fn connect(
        self_: &crate::HxRefCell<Socket>,
        host: crate::HxRef<crate::sys_net_host::Host>,
        port: i32,
    ) {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        crate::sys_ssl_socket::Socket::__hx_super_sys_net_socket_connect(
            &*self_,
            host.clone(),
            port,
        );
    }

    pub fn close(self_: &crate::HxRefCell<Socket>) {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        {
            let __b = __hx_this.borrow();
            __b.handle.clone()
        }
        .borrow_mut()
        .close();
    }

    pub fn read(self_: &crate::HxRefCell<Socket>) -> String {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        return ({
            let __b = __hx_this.borrow();
            __b.input.as_ref().unwrap().clone()
        })
        .read_all(None)
        .borrow()
        .to_string();
    }

    pub fn write(self_: &crate::HxRefCell<Socket>, content: String) {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        ({
            let __b = __hx_this.borrow();
            __b.output.as_ref().unwrap().clone()
        })
        .write_string(content, None);
    }

    pub fn listen(self_: &crate::HxRefCell<Socket>, connections: i32) {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        {
            let __b = __hx_this.borrow();
            __b.handle.clone()
        }
        .borrow_mut()
        .listen(connections as i32);
    }

    pub fn shutdown(self_: &crate::HxRefCell<Socket>, read: bool, write: bool) {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        {
            let __b = __hx_this.borrow();
            __b.handle.clone()
        }
        .borrow_mut()
        .shutdown(read as bool, write as bool);
    }

    pub fn bind(
        self_: &crate::HxRefCell<Socket>,
        host: crate::HxRef<crate::sys_net_host::Host>,
        port: i32,
    ) {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        {
            let __b = __hx_this.borrow();
            __b.handle.clone()
        }
        .borrow_mut()
        .bind(
            {
                let __b = host.borrow();
                __b.ip
            } as i32,
            port as i32,
        );
    }

    pub fn peer(self_: &crate::HxRefCell<Socket>) -> crate::HxRef<hxrt::anon::Anon> {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        let info: hxrt::array::Array<i32> = {
            let (ip, port) = {
                let __b = __hx_this.borrow();
                __b.handle.clone()
            }
            .borrow()
            .peer();
            hxrt::array::Array::<i32>::from_vec(vec![ip, port])
        };
        let host: crate::HxRef<crate::sys_net_host::Host> =
            crate::sys_net_host::Host::new(String::from("127.0.0.1"));
        {
            let __tmp = info.get_unchecked(0 as usize);
            host.borrow_mut().ip = __tmp;
            __tmp
        };
        return {
            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
            {
                let mut __b = __o.borrow_mut();
                __b.set("host", host.clone());
                __b.set("port", info.get_unchecked(1 as usize));
            };
            __o
        };
    }

    pub fn host(self_: &crate::HxRefCell<Socket>) -> crate::HxRef<hxrt::anon::Anon> {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        let info: hxrt::array::Array<i32> = {
            let (ip, port) = {
                let __b = __hx_this.borrow();
                __b.handle.clone()
            }
            .borrow()
            .host();
            hxrt::array::Array::<i32>::from_vec(vec![ip, port])
        };
        let host: crate::HxRef<crate::sys_net_host::Host> =
            crate::sys_net_host::Host::new(String::from("127.0.0.1"));
        {
            let __tmp = info.get_unchecked(0 as usize);
            host.borrow_mut().ip = __tmp;
            __tmp
        };
        return {
            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
            {
                let mut __b = __o.borrow_mut();
                __b.set("host", host.clone());
                __b.set("port", info.get_unchecked(1 as usize));
            };
            __o
        };
    }

    pub fn set_timeout(self_: &crate::HxRefCell<Socket>, timeout: f64) {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        {
            let __b = __hx_this.borrow();
            __b.handle.clone()
        }
        .borrow_mut()
        .set_timeout(timeout as f64);
    }

    pub fn wait_for_read(self_: &crate::HxRefCell<Socket>) {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        {
            let _ = hxrt::net::socket_select(
                vec![{
                    let __b = __hx_this.borrow();
                    __b.handle.clone()
                }
                .clone()],
                vec![],
                vec![],
                Some(-1.0),
            );
        };
    }

    pub fn set_blocking(self_: &crate::HxRefCell<Socket>, b: bool) {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        {
            let __b = __hx_this.borrow();
            __b.handle.clone()
        }
        .borrow_mut()
        .set_blocking(b as bool);
    }

    pub fn set_fast_send(self_: &crate::HxRefCell<Socket>, b: bool) {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        {
            let __b = __hx_this.borrow();
            __b.handle.clone()
        }
        .borrow_mut()
        .set_fast_send(b as bool);
    }

    fn __hx_super_sys_net_socket_connect(
        self_: &crate::HxRefCell<Socket>,
        host: crate::HxRef<crate::sys_net_host::Host>,
        port: i32,
    ) {
        let __hx_this: crate::HxRef<crate::sys_ssl_socket::Socket> = self_.self_ref();
        {
            let __b = __hx_this.borrow();
            __b.handle.clone()
        }
        .borrow_mut()
        .connect(
            {
                let __b = host.borrow();
                __b.ip
            } as i32,
            port as i32,
        );
    }
}

impl crate::sys_net_socket::SocketTrait for crate::HxRefCell<Socket> {
    fn __hx_get_input(&self) -> crate::HxRc<dyn crate::haxe_io_input::InputTrait + Send + Sync> {
        self.borrow().input.as_ref().unwrap().clone()
    }
    fn __hx_set_input(&self, v: crate::HxRc<dyn crate::haxe_io_input::InputTrait + Send + Sync>) {
        self.borrow_mut().input = Some(v);
    }
    fn __hx_get_output(&self) -> crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync> {
        self.borrow().output.as_ref().unwrap().clone()
    }
    fn __hx_set_output(
        &self,
        v: crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync>,
    ) {
        self.borrow_mut().output = Some(v);
    }
    fn __hx_get_custom(&self) -> hxrt::dynamic::Dynamic {
        self.borrow().custom.clone()
    }
    fn __hx_set_custom(&self, v: hxrt::dynamic::Dynamic) {
        self.borrow_mut().custom = v;
    }
    fn __hx_get_handle(&self) -> crate::HxRef<hxrt::net::SocketHandle> {
        self.borrow().handle.clone()
    }
    fn __hx_set_handle(&self, v: crate::HxRef<hxrt::net::SocketHandle>) {
        self.borrow_mut().handle = v;
    }
    fn accept(&self) -> crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync> {
        {
            let __tmp = Socket::accept(self);
            let __up: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync> =
                match __tmp.as_arc_opt() {
                    Some(__rc) => __rc.clone(),
                    None => {
                        hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access")))
                    }
                };
            __up
        }
    }
    fn bind(&self, host: crate::HxRef<crate::sys_net_host::Host>, port: i32) -> () {
        Socket::bind(self, host, port)
    }
    fn close(&self) -> () {
        Socket::close(self)
    }
    fn connect(&self, host: crate::HxRef<crate::sys_net_host::Host>, port: i32) -> () {
        Socket::connect(self, host, port)
    }
    fn host(&self) -> crate::HxRef<hxrt::anon::Anon> {
        Socket::host(self)
    }
    fn listen(&self, connections: i32) -> () {
        Socket::listen(self, connections)
    }
    fn peer(&self) -> crate::HxRef<hxrt::anon::Anon> {
        Socket::peer(self)
    }
    fn read(&self) -> String {
        Socket::read(self)
    }
    fn set_blocking(&self, b: bool) -> () {
        Socket::set_blocking(self, b)
    }
    fn set_fast_send(&self, b: bool) -> () {
        Socket::set_fast_send(self, b)
    }
    fn set_timeout(&self, timeout: f64) -> () {
        Socket::set_timeout(self, timeout)
    }
    fn shutdown(&self, read: bool, write: bool) -> () {
        Socket::shutdown(self, read, write)
    }
    fn wait_for_read(&self) -> () {
        Socket::wait_for_read(self)
    }
    fn write(&self, content: String) -> () {
        Socket::write(self, content)
    }
    fn __hx_type_id(&self) -> u32 {
        crate::sys_ssl_socket::__HX_TYPE_ID
    }
}
