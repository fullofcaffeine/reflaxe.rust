// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0x3cbd411eu32;

pub struct Socket {
    pub input: Option<crate::HxRc<dyn crate::haxe_io_input::InputTrait + Send + Sync>>,
    pub output: Option<crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync>>,
    pub custom: hxrt::dynamic::Dynamic,
    handle: crate::HxRef<hxrt::net::SocketHandle>,
}

impl Socket {
    pub fn new() -> crate::HxRef<crate::sys_net_socket::Socket> {
        let self_: crate::HxRef<crate::sys_net_socket::Socket> = crate::HxRef::new(Socket {
            input: None,
            output: None,
            custom: hxrt::dynamic::Dynamic::null(),
            handle: Default::default(),
        });
        let h: crate::HxRef<hxrt::net::SocketHandle> = hxrt::net::socket_new_tcp();
        {
            let __tmp = h.clone();
            self_.borrow_mut().handle = __tmp.clone();
            __tmp
        };
        {
            let __tmp = crate::sys_net_socket_input::SocketInput::new(h.clone());
            self_.borrow_mut().input = Some({
                let __tmp = __tmp.clone();
                let __up: crate::HxRc<dyn crate::haxe_io_input::InputTrait + Send + Sync> =
                    match __tmp.as_arc_opt() {
                        Some(__rc) => __rc.clone(),
                        None => {
                            hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access")))
                        }
                    };
                __up
            });
            __tmp
        };
        {
            let __tmp = crate::sys_net_socket_output::SocketOutput::new(h.clone());
            self_.borrow_mut().output = Some({
                let __tmp = __tmp.clone();
                let __up: crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync> =
                    match __tmp.as_arc_opt() {
                        Some(__rc) => __rc.clone(),
                        None => {
                            hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access")))
                        }
                    };
                __up
            });
            __tmp
        };
        return self_;
    }

    pub fn close(self_: &crate::HxRefCell<Socket>) {
        let __hx_this: crate::HxRef<crate::sys_net_socket::Socket> = self_.self_ref();
        {
            let __b = __hx_this.borrow();
            __b.handle.clone()
        }
        .borrow_mut()
        .close();
    }

    pub fn read(self_: &crate::HxRefCell<Socket>) -> String {
        let __hx_this: crate::HxRef<crate::sys_net_socket::Socket> = self_.self_ref();
        return ({
            let __b = __hx_this.borrow();
            __b.input.as_ref().unwrap().clone()
        })
        .read_all(None)
        .borrow()
        .to_string();
    }

    pub fn write(self_: &crate::HxRefCell<Socket>, content: String) {
        let __hx_this: crate::HxRef<crate::sys_net_socket::Socket> = self_.self_ref();
        ({
            let __b = __hx_this.borrow();
            __b.output.as_ref().unwrap().clone()
        })
        .write_string(content, None);
    }

    pub fn connect(
        self_: &crate::HxRefCell<Socket>,
        host: crate::HxRef<crate::sys_net_host::Host>,
        port: i32,
    ) {
        let __hx_this: crate::HxRef<crate::sys_net_socket::Socket> = self_.self_ref();
        {
            let __b = __hx_this.borrow();
            __b.handle.clone()
        }
        .borrow_mut()
        .connect(
            {
                let __b = host.borrow();
                __b.ip
            } as i32,
            port as i32,
        );
    }

    pub fn listen(self_: &crate::HxRefCell<Socket>, connections: i32) {
        let __hx_this: crate::HxRef<crate::sys_net_socket::Socket> = self_.self_ref();
        {
            let __b = __hx_this.borrow();
            __b.handle.clone()
        }
        .borrow_mut()
        .listen(connections as i32);
    }

    pub fn shutdown(self_: &crate::HxRefCell<Socket>, read: bool, write: bool) {
        let __hx_this: crate::HxRef<crate::sys_net_socket::Socket> = self_.self_ref();
        {
            let __b = __hx_this.borrow();
            __b.handle.clone()
        }
        .borrow_mut()
        .shutdown(read as bool, write as bool);
    }

    pub fn bind(
        self_: &crate::HxRefCell<Socket>,
        host: crate::HxRef<crate::sys_net_host::Host>,
        port: i32,
    ) {
        let __hx_this: crate::HxRef<crate::sys_net_socket::Socket> = self_.self_ref();
        {
            let __b = __hx_this.borrow();
            __b.handle.clone()
        }
        .borrow_mut()
        .bind(
            {
                let __b = host.borrow();
                __b.ip
            } as i32,
            port as i32,
        );
    }

    pub fn accept(
        self_: &crate::HxRefCell<Socket>,
    ) -> crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync> {
        let __hx_this: crate::HxRef<crate::sys_net_socket::Socket> = self_.self_ref();
        let h: crate::HxRef<hxrt::net::SocketHandle> = {
            let __b = __hx_this.borrow();
            __b.handle.clone()
        }
        .borrow_mut()
        .accept();
        let s: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync> = {
            let __tmp = crate::sys_net_socket::Socket::new();
            let __up: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync> =
                match __tmp.as_arc_opt() {
                    Some(__rc) => __rc.clone(),
                    None => {
                        hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access")))
                    }
                };
            __up
        };
        {
            let __tmp = h.clone();
            s.__hx_set_handle(__tmp.clone());
            __tmp
        };
        {
            let __tmp = crate::sys_net_socket_input::SocketInput::new(h.clone());
            s.__hx_set_input({
                let __tmp = __tmp.clone();
                let __up: crate::HxRc<dyn crate::haxe_io_input::InputTrait + Send + Sync> =
                    match __tmp.as_arc_opt() {
                        Some(__rc) => __rc.clone(),
                        None => {
                            hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access")))
                        }
                    };
                __up
            });
            __tmp
        };
        {
            let __tmp = crate::sys_net_socket_output::SocketOutput::new(h.clone());
            s.__hx_set_output({
                let __tmp = __tmp.clone();
                let __up: crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync> =
                    match __tmp.as_arc_opt() {
                        Some(__rc) => __rc.clone(),
                        None => {
                            hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access")))
                        }
                    };
                __up
            });
            __tmp
        };
        return s;
    }

    pub fn peer(self_: &crate::HxRefCell<Socket>) -> crate::HxRef<hxrt::anon::Anon> {
        let __hx_this: crate::HxRef<crate::sys_net_socket::Socket> = self_.self_ref();
        let info: hxrt::array::Array<i32> = {
            let (ip, port) = {
                let __b = __hx_this.borrow();
                __b.handle.clone()
            }
            .borrow()
            .peer();
            hxrt::array::Array::<i32>::from_vec(vec![ip, port])
        };
        let host: crate::HxRef<crate::sys_net_host::Host> =
            crate::sys_net_host::Host::new(String::from("127.0.0.1"));
        {
            let __tmp = info.get_unchecked(0 as usize);
            host.borrow_mut().ip = __tmp;
            __tmp
        };
        return {
            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
            {
                let mut __b = __o.borrow_mut();
                __b.set("host", host.clone());
                __b.set("port", info.get_unchecked(1 as usize));
            };
            __o
        };
    }

    pub fn host(self_: &crate::HxRefCell<Socket>) -> crate::HxRef<hxrt::anon::Anon> {
        let __hx_this: crate::HxRef<crate::sys_net_socket::Socket> = self_.self_ref();
        let info: hxrt::array::Array<i32> = {
            let (ip, port) = {
                let __b = __hx_this.borrow();
                __b.handle.clone()
            }
            .borrow()
            .host();
            hxrt::array::Array::<i32>::from_vec(vec![ip, port])
        };
        let host: crate::HxRef<crate::sys_net_host::Host> =
            crate::sys_net_host::Host::new(String::from("127.0.0.1"));
        {
            let __tmp = info.get_unchecked(0 as usize);
            host.borrow_mut().ip = __tmp;
            __tmp
        };
        return {
            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
            {
                let mut __b = __o.borrow_mut();
                __b.set("host", host.clone());
                __b.set("port", info.get_unchecked(1 as usize));
            };
            __o
        };
    }

    pub fn set_timeout(self_: &crate::HxRefCell<Socket>, timeout: f64) {
        let __hx_this: crate::HxRef<crate::sys_net_socket::Socket> = self_.self_ref();
        {
            let __b = __hx_this.borrow();
            __b.handle.clone()
        }
        .borrow_mut()
        .set_timeout(timeout as f64);
    }

    pub fn wait_for_read(self_: &crate::HxRefCell<Socket>) {
        let __hx_this: crate::HxRef<crate::sys_net_socket::Socket> = self_.self_ref();
        {
            let _ = hxrt::net::socket_select(
                vec![{
                    let __b = __hx_this.borrow();
                    __b.handle.clone()
                }
                .clone()],
                vec![],
                vec![],
                Some(-1.0),
            );
        };
    }

    pub fn set_blocking(self_: &crate::HxRefCell<Socket>, b: bool) {
        let __hx_this: crate::HxRef<crate::sys_net_socket::Socket> = self_.self_ref();
        {
            let __b = __hx_this.borrow();
            __b.handle.clone()
        }
        .borrow_mut()
        .set_blocking(b as bool);
    }

    pub fn set_fast_send(self_: &crate::HxRefCell<Socket>, b: bool) {
        let __hx_this: crate::HxRef<crate::sys_net_socket::Socket> = self_.self_ref();
        {
            let __b = __hx_this.borrow();
            __b.handle.clone()
        }
        .borrow_mut()
        .set_fast_send(b as bool);
    }

    pub fn select(
        read: hxrt::array::Array<crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync>>,
        write: hxrt::array::Array<
            crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync>,
        >,
        others: hxrt::array::Array<
            crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync>,
        >,
        timeout: Option<f64>,
    ) -> crate::HxRef<hxrt::anon::Anon> {
        let rh: hxrt::array::Array<crate::HxRef<hxrt::net::SocketHandle>> = {
            let _g: hxrt::array::Array<crate::HxRef<hxrt::net::SocketHandle>> =
                hxrt::array::Array::<crate::HxRef<hxrt::net::SocketHandle>>::new();
            {
                let mut _g1: i32 = 0;
                while _g1 < (read.len() as i32) {
                    let s: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync> =
                        read.get_unchecked(_g1 as usize);
                    {
                        _g1 = _g1 + 1;
                        _g1
                    };
                    _g.push(s.__hx_get_handle());
                }
            }
            _g
        };
        let wh: hxrt::array::Array<crate::HxRef<hxrt::net::SocketHandle>> = {
            let _g_2: hxrt::array::Array<crate::HxRef<hxrt::net::SocketHandle>> =
                hxrt::array::Array::<crate::HxRef<hxrt::net::SocketHandle>>::new();
            {
                let mut _g1_2: i32 = 0;
                while _g1_2 < (write.len() as i32) {
                    let s_2: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync> =
                        write.get_unchecked(_g1_2 as usize);
                    {
                        _g1_2 = _g1_2 + 1;
                        _g1_2
                    };
                    _g_2.push(s_2.__hx_get_handle());
                }
            }
            _g_2
        };
        let oh: hxrt::array::Array<crate::HxRef<hxrt::net::SocketHandle>> = {
            let _g_3: hxrt::array::Array<crate::HxRef<hxrt::net::SocketHandle>> =
                hxrt::array::Array::<crate::HxRef<hxrt::net::SocketHandle>>::new();
            {
                let mut _g1_3: i32 = 0;
                while _g1_3 < (others.len() as i32) {
                    let s_3: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync> =
                        others.get_unchecked(_g1_3 as usize);
                    {
                        _g1_3 = _g1_3 + 1;
                        _g1_3
                    };
                    _g_3.push(s_3.__hx_get_handle());
                }
            }
            _g_3
        };
        let idx_groups: hxrt::array::Array<hxrt::array::Array<i32>> = {
            let (ri, wi, oi) =
                hxrt::net::socket_select(rh.to_vec(), wh.to_vec(), oh.to_vec(), timeout);
            hxrt::array::Array::<hxrt::array::Array<i32>>::from_vec(vec![
                hxrt::array::Array::<i32>::from_vec(ri),
                hxrt::array::Array::<i32>::from_vec(wi),
                hxrt::array::Array::<i32>::from_vec(oi),
            ])
        };
        let pick: crate::HxDynRef<
            dyn Fn(
                    hxrt::array::Array<
                        crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync>,
                    >,
                    hxrt::array::Array<i32>,
                ) -> hxrt::array::Array<
                    crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync>,
                > + Send
                + Sync,
        > = {
            let __rc: crate::HxRc<
                dyn Fn(
                        hxrt::array::Array<
                            crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync>,
                        >,
                        hxrt::array::Array<i32>,
                    ) -> hxrt::array::Array<
                        crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync>,
                    > + Send
                    + Sync,
            > = crate::HxRc::new(
                move |src: hxrt::array::Array<
                    crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync>,
                >,
                      idx: hxrt::array::Array<i32>| {
                    let out: hxrt::array::Array<
                        crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync>,
                    > = hxrt::array::Array::<
                        crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync>,
                    >::new();
                    {
                        let mut _g: i32 = 0;
                        while _g < (idx.len() as i32) {
                            let i: i32 = idx.get_unchecked(_g as usize);
                            {
                                _g = _g + 1;
                                _g
                            };
                            out.push(src.get_unchecked(i as usize));
                        }
                    }
                    return out;
                },
            );
            crate::HxDynRef::new(__rc)
        };
        return {
            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
            {
                let mut __b = __o.borrow_mut();
                __b.set(
                    "read",
                    pick(read.clone(), idx_groups.get_unchecked(0 as usize)),
                );
                __b.set(
                    "write",
                    pick(write.clone(), idx_groups.get_unchecked(1 as usize)),
                );
                __b.set(
                    "others",
                    pick(others.clone(), idx_groups.get_unchecked(2 as usize)),
                );
            };
            __o
        };
    }
}

pub trait SocketTrait: Send + Sync {
    fn __hx_get_input(&self) -> crate::HxRc<dyn crate::haxe_io_input::InputTrait + Send + Sync>;
    fn __hx_set_input(&self, v: crate::HxRc<dyn crate::haxe_io_input::InputTrait + Send + Sync>);
    fn __hx_get_output(&self) -> crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync>;
    fn __hx_set_output(&self, v: crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync>);
    fn __hx_get_custom(&self) -> hxrt::dynamic::Dynamic;
    fn __hx_set_custom(&self, v: hxrt::dynamic::Dynamic);
    fn __hx_get_handle(&self) -> crate::HxRef<hxrt::net::SocketHandle>;
    fn __hx_set_handle(&self, v: crate::HxRef<hxrt::net::SocketHandle>);
    fn close(&self) -> ();
    fn read(&self) -> String;
    fn write(&self, content: String) -> ();
    fn connect(&self, host: crate::HxRef<crate::sys_net_host::Host>, port: i32) -> ();
    fn listen(&self, connections: i32) -> ();
    fn shutdown(&self, read: bool, write: bool) -> ();
    fn bind(&self, host: crate::HxRef<crate::sys_net_host::Host>, port: i32) -> ();
    fn accept(&self) -> crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync>;
    fn peer(&self) -> crate::HxRef<hxrt::anon::Anon>;
    fn host(&self) -> crate::HxRef<hxrt::anon::Anon>;
    fn set_timeout(&self, timeout: f64) -> ();
    fn wait_for_read(&self) -> ();
    fn set_blocking(&self, b: bool) -> ();
    fn set_fast_send(&self, b: bool) -> ();
    fn __hx_type_id(&self) -> u32;
}

impl crate::sys_net_socket::SocketTrait for crate::HxRefCell<Socket> {
    fn __hx_get_input(&self) -> crate::HxRc<dyn crate::haxe_io_input::InputTrait + Send + Sync> {
        self.borrow().input.as_ref().unwrap().clone()
    }
    fn __hx_set_input(&self, v: crate::HxRc<dyn crate::haxe_io_input::InputTrait + Send + Sync>) {
        self.borrow_mut().input = Some(v);
    }
    fn __hx_get_output(&self) -> crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync> {
        self.borrow().output.as_ref().unwrap().clone()
    }
    fn __hx_set_output(
        &self,
        v: crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync>,
    ) {
        self.borrow_mut().output = Some(v);
    }
    fn __hx_get_custom(&self) -> hxrt::dynamic::Dynamic {
        self.borrow().custom.clone()
    }
    fn __hx_set_custom(&self, v: hxrt::dynamic::Dynamic) {
        self.borrow_mut().custom = v;
    }
    fn __hx_get_handle(&self) -> crate::HxRef<hxrt::net::SocketHandle> {
        self.borrow().handle.clone()
    }
    fn __hx_set_handle(&self, v: crate::HxRef<hxrt::net::SocketHandle>) {
        self.borrow_mut().handle = v;
    }
    fn close(&self) -> () {
        Socket::close(self)
    }
    fn read(&self) -> String {
        Socket::read(self)
    }
    fn write(&self, content: String) -> () {
        Socket::write(self, content)
    }
    fn connect(&self, host: crate::HxRef<crate::sys_net_host::Host>, port: i32) -> () {
        Socket::connect(self, host, port)
    }
    fn listen(&self, connections: i32) -> () {
        Socket::listen(self, connections)
    }
    fn shutdown(&self, read: bool, write: bool) -> () {
        Socket::shutdown(self, read, write)
    }
    fn bind(&self, host: crate::HxRef<crate::sys_net_host::Host>, port: i32) -> () {
        Socket::bind(self, host, port)
    }
    fn accept(&self) -> crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync> {
        Socket::accept(self)
    }
    fn peer(&self) -> crate::HxRef<hxrt::anon::Anon> {
        Socket::peer(self)
    }
    fn host(&self) -> crate::HxRef<hxrt::anon::Anon> {
        Socket::host(self)
    }
    fn set_timeout(&self, timeout: f64) -> () {
        Socket::set_timeout(self, timeout)
    }
    fn wait_for_read(&self) -> () {
        Socket::wait_for_read(self)
    }
    fn set_blocking(&self, b: bool) -> () {
        Socket::set_blocking(self, b)
    }
    fn set_fast_send(&self, b: bool) -> () {
        Socket::set_fast_send(self, b)
    }
    fn __hx_type_id(&self) -> u32 {
        crate::sys_net_socket::__HX_TYPE_ID
    }
}
