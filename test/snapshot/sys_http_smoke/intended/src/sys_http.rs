// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0x76d977f8u32;

pub struct Http {
    pub url: String,
    pub response_bytes: crate::HxRef<hxrt::bytes::Bytes>,
    response_as_string: Option<String>,
    post_data: Option<String>,
    post_bytes: crate::HxRef<hxrt::bytes::Bytes>,
    headers: hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>>,
    params: hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>>,
    pub on_data: crate::HxDynRef<dyn Fn(String) + Send + Sync>,
    pub on_bytes: crate::HxDynRef<dyn Fn(crate::HxRef<hxrt::bytes::Bytes>) + Send + Sync>,
    pub on_error: crate::HxDynRef<dyn Fn(String) + Send + Sync>,
    pub on_status: crate::HxDynRef<dyn Fn(i32) + Send + Sync>,
    pub no_shutdown: bool,
    pub cnx_timeout: f64,
    pub response_headers: crate::HxRef<crate::haxe_ds_string_map::StringMap<String>>,
    response_headers_sm: crate::HxRef<crate::haxe_ds_string_map::StringMap<String>>,
}

impl Http {
    pub fn new(url: String) -> crate::HxRef<crate::sys_http::Http> {
        let self_: crate::HxRef<crate::sys_http::Http> = crate::HxRef::new(Http {
            url: String::new(),
            response_bytes: crate::HxRef::<hxrt::bytes::Bytes>::null(),
            response_as_string: None,
            post_data: None,
            post_bytes: crate::HxRef::<hxrt::bytes::Bytes>::null(),
            headers: hxrt::array::Array::<crate::HxRef<hxrt::anon::Anon>>::new(),
            params: hxrt::array::Array::<crate::HxRef<hxrt::anon::Anon>>::new(),
            on_data: {
                let __rc: crate::HxRc<dyn Fn(String) + Send + Sync> =
                    crate::HxRc::new(move |_a0| {});
                crate::HxDynRef::new(__rc)
            },
            on_bytes: {
                let __rc: crate::HxRc<dyn Fn(crate::HxRef<hxrt::bytes::Bytes>) + Send + Sync> =
                    crate::HxRc::new(move |_a0| {});
                crate::HxDynRef::new(__rc)
            },
            on_error: {
                let __rc: crate::HxRc<dyn Fn(String) + Send + Sync> =
                    crate::HxRc::new(move |_a0| {});
                crate::HxDynRef::new(__rc)
            },
            on_status: {
                let __rc: crate::HxRc<dyn Fn(i32) + Send + Sync> = crate::HxRc::new(move |_a0| {});
                crate::HxDynRef::new(__rc)
            },
            no_shutdown: false,
            cnx_timeout: 10.0,
            response_headers: crate::haxe_ds_string_map::StringMap::<String>::new(),
            response_headers_sm: crate::haxe_ds_string_map::StringMap::<String>::new(),
        });
        let __hx_super_0_0: String = url;
        {
            let __tmp = __hx_super_0_0.clone();
            self_.borrow_mut().url = __tmp.clone();
            __tmp
        };
        {
            let __tmp = hxrt::array::Array::<crate::HxRef<hxrt::anon::Anon>>::new();
            self_.borrow_mut().headers = __tmp.clone();
            __tmp
        };
        {
            let __tmp = hxrt::array::Array::<crate::HxRef<hxrt::anon::Anon>>::new();
            self_.borrow_mut().params = __tmp.clone();
            __tmp
        };
        {
            let __tmp = {
                let __rc: crate::HxRc<dyn Fn(String) + Send + Sync> =
                    crate::HxRc::new(move |_data: String| {});
                crate::HxDynRef::new(__rc)
            };
            self_.borrow_mut().on_data = __tmp.clone();
            __tmp
        };
        {
            let __tmp = {
                let __rc: crate::HxRc<dyn Fn(crate::HxRef<hxrt::bytes::Bytes>) + Send + Sync> =
                    crate::HxRc::new(move |_data: crate::HxRef<hxrt::bytes::Bytes>| {});
                crate::HxDynRef::new(__rc)
            };
            self_.borrow_mut().on_bytes = __tmp.clone();
            __tmp
        };
        {
            let __tmp = {
                let __rc: crate::HxRc<dyn Fn(String) + Send + Sync> =
                    crate::HxRc::new(move |_msg: String| {});
                crate::HxDynRef::new(__rc)
            };
            self_.borrow_mut().on_error = __tmp.clone();
            __tmp
        };
        {
            let __tmp = {
                let __rc: crate::HxRc<dyn Fn(i32) + Send + Sync> =
                    crate::HxRc::new(move |_status: i32| {});
                crate::HxDynRef::new(__rc)
            };
            self_.borrow_mut().on_status = __tmp.clone();
            __tmp
        };
        {
            let __tmp = crate::haxe_ds_string_map::StringMap::<String>::new();
            self_.borrow_mut().response_headers_sm = __tmp.clone();
            __tmp
        };
        {
            let __tmp = {
                let __b = self_.borrow();
                __b.response_headers_sm.clone()
            };
            self_.borrow_mut().response_headers = __tmp.clone();
            __tmp
        };
        return self_;
    }

    pub fn request(self_: &crate::HxRefCell<Http>, post: Option<bool>) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        let post_flag: bool = post == Some(true)
            || !({
                let __b = __hx_this.borrow();
                __b.post_bytes.clone()
            })
            .is_null()
            || ({
                let __b = __hx_this.borrow();
                __b.post_data.clone()
            })
            .is_some();
        if post_flag {
            ({
                let __b = __hx_this.borrow();
                __b.on_error.clone()
            })(String::from(
                "POST/request bodies are not implemented on this target yet.",
            ));
            return;
        }
        let output: crate::HxRef<crate::haxe_io_bytes_output::BytesOutput> =
            crate::haxe_io_bytes_output::BytesOutput::new();
        match hxrt::exception::catch_unwind(|| {
            crate::sys_http::Http::custom_request(
                &*__hx_this,
                false,
                {
                    let __tmp = output.clone();
                    let __up: crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync> =
                        match __tmp.as_arc_opt() {
                            Some(__rc) => __rc.clone(),
                            None => hxrt::exception::throw(hxrt::dynamic::from(String::from(
                                "Null Access",
                            ))),
                        };
                    __up
                },
                None,
                None,
            );
            crate::sys_http::Http::success(
                &*__hx_this,
                crate::haxe_io_bytes_output::BytesOutput::get_bytes(&*output),
            );
        }) {
            Ok(__hx_ok) => __hx_ok,
            Err(__hx_ex) => {
                let e: hxrt::dynamic::Dynamic = __hx_ex;
                {
                    let __tmp = crate::haxe_io_bytes_output::BytesOutput::get_bytes(&*output);
                    __hx_this.borrow_mut().response_bytes = __tmp.clone();
                    __tmp
                };
                ({
                    let __b = __hx_this.borrow();
                    __b.on_error.clone()
                })(format!("{}{}", "", e.to_haxe_string()));
            }
        };
    }

    pub fn file_transfert(
        self_: &crate::HxRefCell<Http>,
        _argname: String,
        _filename: String,
        _file: crate::HxRc<dyn crate::haxe_io_input::InputTrait + Send + Sync>,
        _size: i32,
        _mime_type: String,
    ) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        crate::sys_http::Http::file_transfer(
            &*__hx_this,
            _argname,
            _filename,
            _file.clone(),
            _size,
            _mime_type,
        );
    }

    pub fn file_transfer(
        self_: &crate::HxRefCell<Http>,
        _argname: String,
        _filename: String,
        _file: crate::HxRc<dyn crate::haxe_io_input::InputTrait + Send + Sync>,
        _size: i32,
        _mime_type: String,
    ) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        ({
            let __b = __hx_this.borrow();
            __b.on_error.clone()
        })(String::from(
            "Multipart file uploads are not implemented on this target yet.",
        ));
    }

    pub fn get_response_header_values(
        self_: &crate::HxRefCell<Http>,
        key: String,
    ) -> hxrt::array::Array<String> {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        let v: Option<String> = crate::haxe_ds_string_map::StringMap::get(
            &*({
                let __b = __hx_this.borrow();
                __b.response_headers_sm.clone()
            }),
            key,
        );
        if v.is_none() {
            return hxrt::array::Array::<String>::new();
        }
        return hxrt::array::Array::<String>::from_vec(vec![v.unwrap()]);
    }

    pub fn custom_request(
        self_: &crate::HxRefCell<Http>,
        post: bool,
        api: crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync>,
        _sock: Option<crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync>>,
        _method: Option<String>,
    ) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        {
            let __tmp = None;
            __hx_this.borrow_mut().response_as_string = __tmp.clone();
            __tmp
        };
        {
            let __tmp = crate::HxRef::<hxrt::bytes::Bytes>::null();
            __hx_this.borrow_mut().response_bytes = __tmp.clone();
            __tmp
        };
        {
            let __tmp = crate::haxe_ds_string_map::StringMap::<String>::new();
            __hx_this.borrow_mut().response_headers_sm = __tmp.clone();
            __tmp
        };
        {
            let __tmp = {
                let __b = __hx_this.borrow();
                __b.response_headers_sm.clone()
            };
            __hx_this.borrow_mut().response_headers = __tmp.clone();
            __tmp
        };
        let parsed: crate::HxRef<hxrt::anon::Anon> = crate::sys_http::Http::parse_url({
            let __b = __hx_this.borrow();
            __b.url.clone()
        });
        if hxrt::string::len(parsed.borrow().get::<String>("host").as_str()) == 0 {
            ({
                let __b = __hx_this.borrow();
                __b.on_error.clone()
            })(String::from("Invalid URL"));
            return;
        }
        if post {
            ({
                let __b = __hx_this.borrow();
                __b.on_error.clone()
            })(String::from(
                "POST/request bodies are not implemented on this target yet.",
            ));
            return;
        }
        let host: String = parsed.borrow().get::<String>("host");
        let port: i32 = parsed.borrow().get::<i32>("port");
        let mut request: String = parsed.borrow().get::<String>("path");
        if hxrt::string::len(request.as_str()) == 0 {
            request = String::from("/");
        }
        if hxrt::string::char_at(request.as_str(), 0) != String::from("/") {
            request = format!("{}{}", "/", &request);
        }
        let mut uri: String = String::from("");
        if (({
            let __b = __hx_this.borrow();
            __b.params.clone()
        })
        .len() as i32)
            > 0
        {
            let kv: hxrt::array::Array<String> = hxrt::array::Array::<String>::new();
            {
                let mut _g: i32 = 0;
                let _g1: hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>> = {
                    let __b = __hx_this.borrow();
                    __b.params.clone()
                };
                while _g < (_g1.len() as i32) {
                    let p: crate::HxRef<hxrt::anon::Anon> = _g1.get_unchecked(_g as usize);
                    {
                        _g = _g + 1;
                        _g
                    };
                    kv.push(format!(
                        "{}{}{}",
                        crate::string_tools::StringTools::url_encode(
                            p.borrow().get::<String>("name")
                        ),
                        "=",
                        crate::string_tools::StringTools::url_encode(
                            p.borrow().get::<String>("value")
                        )
                    ));
                }
            }
            uri = kv.join(String::from("&"));
        }
        let b: crate::HxRef<crate::haxe_io_bytes_output::BytesOutput> =
            crate::haxe_io_bytes_output::BytesOutput::new();
        crate::haxe_io_bytes_output::BytesOutput::write_string(&*b, String::from("GET "), None);
        crate::haxe_io_bytes_output::BytesOutput::write_string(&*b, request.clone(), None);
        if uri != String::from("") {
            if hxrt::string::index_of(request.as_str(), String::from("?").as_str(), Some(0)) >= 0 {
                crate::haxe_io_bytes_output::BytesOutput::write_string(
                    &*b,
                    String::from("&"),
                    None,
                );
            } else {
                crate::haxe_io_bytes_output::BytesOutput::write_string(
                    &*b,
                    String::from("?"),
                    None,
                );
            }
            crate::haxe_io_bytes_output::BytesOutput::write_string(&*b, uri.clone(), None);
        }
        crate::haxe_io_bytes_output::BytesOutput::write_string(
            &*b,
            format!("{}{}{}", " HTTP/1.1\r\nHost: ", &host, "\r\n"),
            None,
        );
        crate::haxe_io_bytes_output::BytesOutput::write_string(
            &*b,
            String::from("Connection: close\r\n"),
            None,
        );
        {
            let mut _g_2: i32 = 0;
            let _g1_2: hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>> = {
                let __b = __hx_this.borrow();
                __b.headers.clone()
            };
            while _g_2 < (_g1_2.len() as i32) {
                let h: crate::HxRef<hxrt::anon::Anon> = _g1_2.get_unchecked(_g_2 as usize);
                {
                    _g_2 = _g_2 + 1;
                    _g_2
                };
                crate::haxe_io_bytes_output::BytesOutput::write_string(
                    &*b,
                    h.borrow().get::<String>("name"),
                    None,
                );
                crate::haxe_io_bytes_output::BytesOutput::write_string(
                    &*b,
                    String::from(": "),
                    None,
                );
                crate::haxe_io_bytes_output::BytesOutput::write_string(
                    &*b,
                    h.borrow().get::<String>("value"),
                    None,
                );
                crate::haxe_io_bytes_output::BytesOutput::write_string(
                    &*b,
                    String::from("\r\n"),
                    None,
                );
            }
        }
        crate::haxe_io_bytes_output::BytesOutput::write_string(&*b, String::from("\r\n"), None);
        let mut s: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync> = {
            let __tmp = crate::sys_net_socket::Socket::new();
            let __up: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync> =
                match __tmp.as_arc_opt() {
                    Some(__rc) => __rc.clone(),
                    None => {
                        hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access")))
                    }
                };
            __up
        };
        match hxrt::exception::catch_unwind(|| {
            if parsed.borrow().get::<bool>("secure") {
                let ss: crate::HxRef<crate::sys_ssl_socket::Socket> =
                    crate::sys_ssl_socket::Socket::new();
                s = {
                    let __tmp = ss.clone();
                    let __up: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync> =
                        match __tmp.as_arc_opt() {
                            Some(__rc) => __rc.clone(),
                            None => hxrt::exception::throw(hxrt::dynamic::from(String::from(
                                "Null Access",
                            ))),
                        };
                    __up
                };
                crate::sys_ssl_socket::Socket::set_timeout(&*ss, {
                    let __b = __hx_this.borrow();
                    __b.cnx_timeout
                });
                crate::sys_ssl_socket::Socket::set_hostname(&*ss, host.clone());
                crate::sys_ssl_socket::Socket::connect(
                    &*ss,
                    crate::sys_net_host::Host::new(host.clone()),
                    port,
                );
                crate::sys_ssl_socket::Socket::handshake(&*ss);
            } else {
                s.set_timeout({
                    let __b = __hx_this.borrow();
                    __b.cnx_timeout
                });
                s.connect(crate::sys_net_host::Host::new(host.clone()), port);
            }
            crate::sys_http::Http::write_body(&*__hx_this, b.clone(), s.clone());
            crate::sys_http::Http::read_http_response(&*__hx_this, api.clone(), s.clone());
            s.close();
        }) {
            Ok(__hx_ok) => __hx_ok,
            Err(__hx_ex) => {
                let e: hxrt::dynamic::Dynamic = __hx_ex;
                match hxrt::exception::catch_unwind(|| {
                    s.close();
                }) {
                    Ok(__hx_ok) => __hx_ok,
                    Err(__hx_ex) => {
                        let _ = __hx_ex;
                    }
                };
                ({
                    let __b = __hx_this.borrow();
                    __b.on_error.clone()
                })(format!("{}{}", "", e.to_haxe_string()));
            }
        };
    }

    fn write_body(
        _self_: &crate::HxRefCell<Http>,
        body: crate::HxRef<crate::haxe_io_bytes_output::BytesOutput>,
        sock: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync>,
    ) {
        let bytes: crate::HxRef<hxrt::bytes::Bytes> =
            crate::haxe_io_bytes_output::BytesOutput::get_bytes(&*body);
        sock.__hx_get_output()
            .write_full_bytes(bytes.clone(), 0, bytes.borrow().length());
    }

    fn read_http_response(
        self_: &crate::HxRefCell<Http>,
        api: crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync>,
        sock: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync>,
    ) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        sock.set_timeout({
            let __b = __hx_this.borrow();
            __b.cnx_timeout
        });
        let status_line: String = sock.__hx_get_input().read_line();
        let status: i32 = crate::sys_http::Http::parse_status(status_line);
        let mut size: i32 = -1;
        let mut chunked: bool = false;
        loop {
            let line: String = sock.__hx_get_input().read_line();
            if line == String::from("") {
                break;
            }
            let sep: i32 =
                hxrt::string::index_of(line.as_str(), String::from(":").as_str(), Some(0));
            if sep < 0 {
                continue;
            }
            let hname: String = hxrt::string::substr(line.as_str(), 0, Some(sep));
            let hval: String = {
                let s: String = hxrt::string::substr(line.as_str(), sep + 1, None);
                crate::string_tools::StringTools::ltrim(crate::string_tools::StringTools::rtrim(
                    s.clone(),
                ))
            };
            let hn: String = hxrt::string::to_lower_case(hname.as_str());
            if hn == String::from("content-length") {
                size = crate::sys_http::Http::parse_dec_int(hval.clone());
            } else {
                if hn == String::from("transfer-encoding") {
                    chunked = hxrt::string::to_lower_case(hval.as_str()) == String::from("chunked");
                }
            }
            crate::haxe_ds_string_map::StringMap::set(
                &*({
                    let __b = __hx_this.borrow();
                    __b.response_headers_sm.clone()
                }),
                hname.clone(),
                hval.clone(),
            );
        }
        ({
            let __b = __hx_this.borrow();
            __b.on_status.clone()
        })(status);
        let bufsize: i32 = 1024;
        let buf: crate::HxRef<hxrt::bytes::Bytes> =
            crate::HxRef::new(hxrt::bytes::Bytes::alloc(bufsize as usize));
        if chunked {
            crate::sys_http::Http::read_chunked(&*__hx_this, api.clone(), sock.clone());
        } else {
            if size < 0 {
                if !({
                    let __b = __hx_this.borrow();
                    __b.no_shutdown
                }) {
                    sock.shutdown(false, true);
                }
                match hxrt::exception::catch_unwind(|| loop {
                    let len: i32 = sock.__hx_get_input().read_bytes(buf.clone(), 0, bufsize);
                    if len == 0 {
                        break;
                    }
                    api.write_bytes(buf.clone(), 0, len);
                }) {
                    Ok(__hx_ok) => __hx_ok,
                    Err(__hx_ex) => {
                        match __hx_ex.downcast::<crate::HxRef<crate::haxe_io_eof::Eof>>() {
                            Ok(_) => {}
                            Err(__hx_ex) => hxrt::exception::rethrow(__hx_ex),
                        }
                    }
                };
            } else {
                api.prepare(size);
                let mut remaining: i32 = size;
                match hxrt::exception::catch_unwind(|| {
                    while remaining > 0 {
                        let want: i32 = if remaining > bufsize {
                            bufsize
                        } else {
                            remaining
                        };
                        let len_2: i32 = sock.__hx_get_input().read_bytes(buf.clone(), 0, want);
                        if len_2 == 0 {
                            hxrt::exception::throw(hxrt::dynamic::from(String::from(
                                "Transfer aborted",
                            )));
                        }
                        api.write_bytes(buf.clone(), 0, len_2);
                        {
                            remaining = remaining - len_2;
                            remaining
                        };
                    }
                }) {
                    Ok(__hx_ok) => __hx_ok,
                    Err(__hx_ex) => {
                        match __hx_ex.downcast::<crate::HxRef<crate::haxe_io_eof::Eof>>() {
                            Ok(_) => {
                                hxrt::exception::throw(hxrt::dynamic::from(String::from(
                                    "Transfer aborted",
                                )));
                            }
                            Err(__hx_ex) => hxrt::exception::rethrow(__hx_ex),
                        }
                    }
                };
            }
        }
        if status < 200 || status >= 400 {
            hxrt::exception::throw(hxrt::dynamic::from(format!(
                "{}{}",
                "Http Error #",
                hxrt::dynamic::from(status).to_haxe_string()
            )));
        }
        api.close();
    }

    fn read_chunked(
        _self_: &crate::HxRefCell<Http>,
        api: crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync>,
        sock: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync>,
    ) {
        loop {
            let mut size_line: String = sock.__hx_get_input().read_line();
            let semi: i32 =
                hxrt::string::index_of(size_line.as_str(), String::from(";").as_str(), Some(0));
            if semi >= 0 {
                size_line = hxrt::string::substr(size_line.as_str(), 0, Some(semi));
            }
            size_line = crate::string_tools::StringTools::ltrim(
                crate::string_tools::StringTools::rtrim(size_line.clone()),
            );
            let size: i32 = crate::sys_http::Http::parse_hex_int(size_line.clone());
            if size < 0 {
                hxrt::exception::throw(hxrt::dynamic::from(String::from("Invalid chunk")));
            }
            if size == 0 {
                loop {
                    let trailer: String = sock.__hx_get_input().read_line();
                    if trailer == String::from("") {
                        break;
                    }
                }
                return;
            }
            let bytes: crate::HxRef<hxrt::bytes::Bytes> =
                crate::HxRef::new(hxrt::bytes::Bytes::alloc(size as usize));
            sock.__hx_get_input()
                .read_full_bytes(bytes.clone(), 0, size);
            api.write_bytes(bytes.clone(), 0, size);
            sock.__hx_get_input().read_line();
        }
    }

    pub fn set_header(self_: &crate::HxRefCell<Http>, name: String, value: String) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        {
            let mut _g: i32 = 0;
            let _g1: i32 = ({
                let __b = __hx_this.borrow();
                __b.headers.clone()
            })
            .len() as i32;
            while _g < _g1 {
                let i: i32 = {
                    let __tmp = _g;
                    _g = _g + 1;
                    __tmp
                };
                if ({
                    let __b = __hx_this.borrow();
                    __b.headers.clone()
                })
                .get_unchecked(i as usize)
                .borrow()
                .get::<String>("name")
                    == name
                {
                    {
                        let __tmp = {
                            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
                            {
                                let mut __b = __o.borrow_mut();
                                __b.set("name", name.clone());
                                __b.set("value", value.clone());
                            };
                            __o
                        };
                        ({
                            let __b = __hx_this.borrow();
                            __b.headers.clone()
                        })
                        .set_haxe(i as usize, __tmp.clone(), move || crate::HxRef::null());
                        __tmp
                    };
                    return;
                }
            }
        }
        ({
            let __b = __hx_this.borrow();
            __b.headers.clone()
        })
        .push({
            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
            {
                let mut __b = __o.borrow_mut();
                __b.set("name", name.clone());
                __b.set("value", value.clone());
            };
            __o
        });
    }

    pub fn add_header(self_: &crate::HxRefCell<Http>, header: String, value: String) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        ({
            let __b = __hx_this.borrow();
            __b.headers.clone()
        })
        .push({
            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
            {
                let mut __b = __o.borrow_mut();
                __b.set("name", header);
                __b.set("value", value);
            };
            __o
        });
    }

    pub fn set_parameter(self_: &crate::HxRefCell<Http>, name: String, value: String) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        {
            let mut _g: i32 = 0;
            let _g1: i32 = ({
                let __b = __hx_this.borrow();
                __b.params.clone()
            })
            .len() as i32;
            while _g < _g1 {
                let i: i32 = {
                    let __tmp = _g;
                    _g = _g + 1;
                    __tmp
                };
                if ({
                    let __b = __hx_this.borrow();
                    __b.params.clone()
                })
                .get_unchecked(i as usize)
                .borrow()
                .get::<String>("name")
                    == name
                {
                    {
                        let __tmp = {
                            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
                            {
                                let mut __b = __o.borrow_mut();
                                __b.set("name", name.clone());
                                __b.set("value", value.clone());
                            };
                            __o
                        };
                        ({
                            let __b = __hx_this.borrow();
                            __b.params.clone()
                        })
                        .set_haxe(i as usize, __tmp.clone(), move || crate::HxRef::null());
                        __tmp
                    };
                    return;
                }
            }
        }
        ({
            let __b = __hx_this.borrow();
            __b.params.clone()
        })
        .push({
            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
            {
                let mut __b = __o.borrow_mut();
                __b.set("name", name.clone());
                __b.set("value", value.clone());
            };
            __o
        });
    }

    pub fn add_parameter(self_: &crate::HxRefCell<Http>, name: String, value: String) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        ({
            let __b = __hx_this.borrow();
            __b.params.clone()
        })
        .push({
            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
            {
                let mut __b = __o.borrow_mut();
                __b.set("name", name);
                __b.set("value", value);
            };
            __o
        });
    }

    pub fn set_post_data(self_: &crate::HxRefCell<Http>, data: Option<String>) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        {
            let __tmp = data;
            __hx_this.borrow_mut().post_data = __tmp.clone();
            __tmp
        };
        {
            let __tmp = crate::HxRef::<hxrt::bytes::Bytes>::null();
            __hx_this.borrow_mut().post_bytes = __tmp.clone();
            __tmp
        };
    }

    pub fn set_post_bytes(self_: &crate::HxRefCell<Http>, data: crate::HxRef<hxrt::bytes::Bytes>) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        {
            let __tmp = data;
            __hx_this.borrow_mut().post_bytes = __tmp.clone();
            __tmp
        };
        {
            let __tmp = None;
            __hx_this.borrow_mut().post_data = __tmp.clone();
            __tmp
        };
    }

    fn success(self_: &crate::HxRefCell<Http>, data: crate::HxRef<hxrt::bytes::Bytes>) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        {
            let __tmp = data.clone();
            __hx_this.borrow_mut().response_bytes = __tmp.clone();
            __tmp
        };
        let s: String = data.borrow().to_string();
        {
            let __tmp = s.clone();
            __hx_this.borrow_mut().response_as_string = Some(__tmp.clone());
            __tmp
        };
        ({
            let __b = __hx_this.borrow();
            __b.on_data.clone()
        })(s.clone());
        ({
            let __b = __hx_this.borrow();
            __b.on_bytes.clone()
        })(data.clone());
    }

    pub fn get_response_data(self_: &crate::HxRefCell<Http>) -> Option<String> {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        return {
            let __b = __hx_this.borrow();
            __b.response_as_string.clone()
        };
    }

    fn parse_url(url: String) -> crate::HxRef<hxrt::anon::Anon> {
        let mut u: String = url;
        let mut secure: bool = false;
        if hxrt::string::index_of(u.as_str(), String::from("http://").as_str(), Some(0)) == 0 {
            u = hxrt::string::substr(
                u.as_str(),
                hxrt::string::len(String::from("http://").as_str()),
                None,
            );
        } else {
            if hxrt::string::index_of(u.as_str(), String::from("https://").as_str(), Some(0)) == 0 {
                secure = true;
                u = hxrt::string::substr(
                    u.as_str(),
                    hxrt::string::len(String::from("https://").as_str()),
                    None,
                );
            }
        }
        let slash: i32 = hxrt::string::index_of(u.as_str(), String::from("/").as_str(), Some(0));
        let host_port: String = if slash >= 0 {
            hxrt::string::substr(u.as_str(), 0, Some(slash))
        } else {
            hxrt::string::substr(u.as_str(), 0, Some(hxrt::string::len(u.as_str())))
        };
        let path: String = if slash >= 0 {
            hxrt::string::substr(u.as_str(), slash, None)
        } else {
            String::from("/")
        };
        if hxrt::string::len(host_port.as_str()) == 0 {
            return {
                let __o = crate::HxRef::new(hxrt::anon::Anon::new());
                {
                    let mut __b = __o.borrow_mut();
                    __b.set("secure", secure);
                    __b.set("host", String::from(""));
                    __b.set("port", 0);
                    __b.set("path", String::from("/"));
                };
                __o
            };
        }
        let mut host: String = host_port.clone();
        let mut port: i32 = if secure { 443 } else { 80 };
        let colon: i32 =
            hxrt::string::index_of(host_port.as_str(), String::from(":").as_str(), Some(0));
        if colon >= 0 {
            host = hxrt::string::substr(host_port.as_str(), 0, Some(colon));
            let p: i32 = crate::sys_http::Http::parse_dec_int(hxrt::string::substr(
                host_port.as_str(),
                colon + 1,
                None,
            ));
            if p < 0 {
                return {
                    let __o = crate::HxRef::new(hxrt::anon::Anon::new());
                    {
                        let mut __b = __o.borrow_mut();
                        __b.set("secure", secure);
                        __b.set("host", String::from(""));
                        __b.set("port", 0);
                        __b.set("path", String::from("/"));
                    };
                    __o
                };
            }
            port = p;
        }
        if hxrt::string::len(host.as_str()) == 0 {
            return {
                let __o = crate::HxRef::new(hxrt::anon::Anon::new());
                {
                    let mut __b = __o.borrow_mut();
                    __b.set("secure", secure);
                    __b.set("host", String::from(""));
                    __b.set("port", 0);
                    __b.set("path", String::from("/"));
                };
                __o
            };
        }
        return {
            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
            {
                let mut __b = __o.borrow_mut();
                __b.set("secure", secure);
                __b.set("host", host.clone());
                __b.set("port", port);
                __b.set("path", path);
            };
            __o
        };
    }

    fn parse_dec_int(s: String) -> i32 {
        return s.parse::<i32>().unwrap_or(-1);
    }

    fn parse_hex_int(s: String) -> i32 {
        return i32::from_str_radix(s.trim(), 16).unwrap_or(-1);
    }

    fn parse_status(line: String) -> i32 {
        let first: i32 = hxrt::string::index_of(line.as_str(), String::from(" ").as_str(), Some(0));
        if first < 0 {
            hxrt::exception::throw(hxrt::dynamic::from(String::from("Response status error")));
        }
        let mut second: i32 =
            hxrt::string::index_of(line.as_str(), String::from(" ").as_str(), Some(first + 1));
        if second < 0 {
            second = hxrt::string::len(line.as_str());
        }
        let code_str: String =
            hxrt::string::substr(line.as_str(), first + 1, Some(second - first - 1));
        let n: i32 = crate::sys_http::Http::parse_dec_int(code_str);
        if n < 0 {
            hxrt::exception::throw(hxrt::dynamic::from(String::from("Response status error")));
        }
        return n;
    }

    pub fn request_url(url: String) -> String {
        let h: crate::HxRef<crate::sys_http::Http> = crate::sys_http::Http::new(url);
        let out: crate::HxRef<crate::haxe_io_bytes_output::BytesOutput> =
            crate::haxe_io_bytes_output::BytesOutput::new();
        {
            let __tmp = {
                let __rc: crate::HxRc<dyn Fn(String) + Send + Sync> =
                    crate::HxRc::new(move |e: String| {
                        hxrt::exception::throw(hxrt::dynamic::from(e));
                    });
                crate::HxDynRef::new(__rc)
            };
            h.borrow_mut().on_error = __tmp.clone();
            __tmp
        };
        crate::sys_http::Http::custom_request(
            &*h,
            false,
            {
                let __tmp = out.clone();
                let __up: crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync> =
                    match __tmp.as_arc_opt() {
                        Some(__rc) => __rc.clone(),
                        None => {
                            hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access")))
                        }
                    };
                __up
            },
            None,
            None,
        );
        return crate::haxe_io_bytes_output::BytesOutput::get_bytes(&*out)
            .borrow()
            .to_string();
    }
}

impl crate::haxe_http_http_base::HttpBaseTrait for crate::HxRefCell<Http> {
    fn __hx_get_url(&self) -> String {
        self.borrow().url.clone()
    }
    fn __hx_set_url(&self, v: String) {
        self.borrow_mut().url = v;
    }
    fn __hx_get_response_bytes(&self) -> crate::HxRef<hxrt::bytes::Bytes> {
        self.borrow().response_bytes.clone()
    }
    fn __hx_set_response_bytes(&self, v: crate::HxRef<hxrt::bytes::Bytes>) {
        self.borrow_mut().response_bytes = v;
    }
    fn __hx_get_response_as_string(&self) -> Option<String> {
        self.borrow().response_as_string.clone()
    }
    fn __hx_set_response_as_string(&self, v: Option<String>) {
        self.borrow_mut().response_as_string = v;
    }
    fn __hx_get_post_data(&self) -> Option<String> {
        self.borrow().post_data.clone()
    }
    fn __hx_set_post_data(&self, v: Option<String>) {
        self.borrow_mut().post_data = v;
    }
    fn __hx_get_post_bytes(&self) -> crate::HxRef<hxrt::bytes::Bytes> {
        self.borrow().post_bytes.clone()
    }
    fn __hx_set_post_bytes(&self, v: crate::HxRef<hxrt::bytes::Bytes>) {
        self.borrow_mut().post_bytes = v;
    }
    fn __hx_get_headers(&self) -> hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>> {
        self.borrow().headers.clone()
    }
    fn __hx_set_headers(&self, v: hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>>) {
        self.borrow_mut().headers = v;
    }
    fn __hx_get_params(&self) -> hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>> {
        self.borrow().params.clone()
    }
    fn __hx_set_params(&self, v: hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>>) {
        self.borrow_mut().params = v;
    }
    fn __hx_get_on_data(&self) -> crate::HxDynRef<dyn Fn(String) + Send + Sync> {
        self.borrow().on_data.clone()
    }
    fn __hx_set_on_data(&self, v: crate::HxDynRef<dyn Fn(String) + Send + Sync>) {
        self.borrow_mut().on_data = v;
    }
    fn __hx_get_on_bytes(
        &self,
    ) -> crate::HxDynRef<dyn Fn(crate::HxRef<hxrt::bytes::Bytes>) + Send + Sync> {
        self.borrow().on_bytes.clone()
    }
    fn __hx_set_on_bytes(
        &self,
        v: crate::HxDynRef<dyn Fn(crate::HxRef<hxrt::bytes::Bytes>) + Send + Sync>,
    ) {
        self.borrow_mut().on_bytes = v;
    }
    fn __hx_get_on_error(&self) -> crate::HxDynRef<dyn Fn(String) + Send + Sync> {
        self.borrow().on_error.clone()
    }
    fn __hx_set_on_error(&self, v: crate::HxDynRef<dyn Fn(String) + Send + Sync>) {
        self.borrow_mut().on_error = v;
    }
    fn __hx_get_on_status(&self) -> crate::HxDynRef<dyn Fn(i32) + Send + Sync> {
        self.borrow().on_status.clone()
    }
    fn __hx_set_on_status(&self, v: crate::HxDynRef<dyn Fn(i32) + Send + Sync>) {
        self.borrow_mut().on_status = v;
    }
    fn add_header(&self, header: String, value: String) -> () {
        Http::add_header(self, header, value)
    }
    fn add_parameter(&self, name: String, value: String) -> () {
        Http::add_parameter(self, name, value)
    }
    fn get_response_data(&self) -> Option<String> {
        Http::get_response_data(self)
    }
    fn request(&self, _post: Option<bool>) -> () {
        Http::request(self, _post)
    }
    fn set_header(&self, name: String, value: String) -> () {
        Http::set_header(self, name, value)
    }
    fn set_parameter(&self, name: String, value: String) -> () {
        Http::set_parameter(self, name, value)
    }
    fn set_post_bytes(&self, data: crate::HxRef<hxrt::bytes::Bytes>) -> () {
        Http::set_post_bytes(self, data)
    }
    fn set_post_data(&self, data: Option<String>) -> () {
        Http::set_post_data(self, data)
    }
    fn success(&self, data: crate::HxRef<hxrt::bytes::Bytes>) -> () {
        Http::success(self, data)
    }
    fn __hx_type_id(&self) -> u32 {
        crate::sys_http::__HX_TYPE_ID
    }
}
