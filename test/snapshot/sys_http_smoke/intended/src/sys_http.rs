// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0x76d977f8u32;

pub struct Http {
    pub url: hxrt::string::HxString,
    pub response_bytes: crate::HxRef<hxrt::bytes::Bytes>,
    response_as_string: hxrt::string::HxString,
    post_data: hxrt::string::HxString,
    post_bytes: crate::HxRef<hxrt::bytes::Bytes>,
    headers: hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>>,
    params: hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>>,
    pub on_data: crate::HxDynRef<dyn Fn(hxrt::string::HxString) + Send + Sync>,
    pub on_bytes: crate::HxDynRef<dyn Fn(crate::HxRef<hxrt::bytes::Bytes>) + Send + Sync>,
    pub on_error: crate::HxDynRef<dyn Fn(hxrt::string::HxString) + Send + Sync>,
    pub on_status: crate::HxDynRef<dyn Fn(i32) + Send + Sync>,
    pub no_shutdown: bool,
    pub cnx_timeout: f64,
    pub response_headers:
        crate::HxRef<crate::haxe_ds_string_map::StringMap<hxrt::string::HxString>>,
    response_headers_sm: crate::HxRef<crate::haxe_ds_string_map::StringMap<hxrt::string::HxString>>,
}

impl Http {
    pub fn new(url: hxrt::string::HxString) -> crate::HxRef<crate::sys_http::Http> {
        let self_: crate::HxRef<crate::sys_http::Http> = crate::HxRef::new(Http {
            url: hxrt::string::HxString::null(),
            response_bytes: crate::HxRef::<hxrt::bytes::Bytes>::null(),
            response_as_string: hxrt::string::HxString::null(),
            post_data: hxrt::string::HxString::null(),
            post_bytes: crate::HxRef::<hxrt::bytes::Bytes>::null(),
            headers: hxrt::array::Array::<crate::HxRef<hxrt::anon::Anon>>::new(),
            params: hxrt::array::Array::<crate::HxRef<hxrt::anon::Anon>>::new(),
            on_data: {
                let __rc: crate::HxRc<dyn Fn(hxrt::string::HxString) + Send + Sync> =
                    crate::HxRc::new(move |_a0| {});
                crate::HxDynRef::new(__rc)
            },
            on_bytes: {
                let __rc: crate::HxRc<dyn Fn(crate::HxRef<hxrt::bytes::Bytes>) + Send + Sync> =
                    crate::HxRc::new(move |_a0| {});
                crate::HxDynRef::new(__rc)
            },
            on_error: {
                let __rc: crate::HxRc<dyn Fn(hxrt::string::HxString) + Send + Sync> =
                    crate::HxRc::new(move |_a0| {});
                crate::HxDynRef::new(__rc)
            },
            on_status: {
                let __rc: crate::HxRc<dyn Fn(i32) + Send + Sync> = crate::HxRc::new(move |_a0| {});
                crate::HxDynRef::new(__rc)
            },
            no_shutdown: false,
            cnx_timeout: 10.0,
            response_headers: crate::haxe_ds_string_map::StringMap::<hxrt::string::HxString>::new(),
            response_headers_sm:
                crate::haxe_ds_string_map::StringMap::<hxrt::string::HxString>::new(),
        });
        let __hx_super_0_0: hxrt::string::HxString = hxrt::string::HxString::from(url);
        {
            let __tmp = __hx_super_0_0.clone();
            self_.borrow_mut().url = hxrt::string::HxString::from(__tmp.clone());
            __tmp
        };
        {
            let __tmp = hxrt::array::Array::<crate::HxRef<hxrt::anon::Anon>>::new();
            self_.borrow_mut().headers = __tmp.clone();
            __tmp
        };
        {
            let __tmp = hxrt::array::Array::<crate::HxRef<hxrt::anon::Anon>>::new();
            self_.borrow_mut().params = __tmp.clone();
            __tmp
        };
        {
            let __tmp = {
                let __rc: crate::HxRc<dyn Fn(hxrt::string::HxString) + Send + Sync> =
                    crate::HxRc::new(move |_data: hxrt::string::HxString| {});
                crate::HxDynRef::new(__rc)
            };
            self_.borrow_mut().on_data = __tmp.clone();
            __tmp
        };
        {
            let __tmp = {
                let __rc: crate::HxRc<dyn Fn(crate::HxRef<hxrt::bytes::Bytes>) + Send + Sync> =
                    crate::HxRc::new(move |_data: crate::HxRef<hxrt::bytes::Bytes>| {});
                crate::HxDynRef::new(__rc)
            };
            self_.borrow_mut().on_bytes = __tmp.clone();
            __tmp
        };
        {
            let __tmp = {
                let __rc: crate::HxRc<dyn Fn(hxrt::string::HxString) + Send + Sync> =
                    crate::HxRc::new(move |_msg: hxrt::string::HxString| {});
                crate::HxDynRef::new(__rc)
            };
            self_.borrow_mut().on_error = __tmp.clone();
            __tmp
        };
        {
            let __tmp = {
                let __rc: crate::HxRc<dyn Fn(i32) + Send + Sync> =
                    crate::HxRc::new(move |_status: i32| {});
                crate::HxDynRef::new(__rc)
            };
            self_.borrow_mut().on_status = __tmp.clone();
            __tmp
        };
        {
            let __tmp = crate::haxe_ds_string_map::StringMap::<hxrt::string::HxString>::new();
            self_.borrow_mut().response_headers_sm = __tmp.clone();
            __tmp
        };
        {
            let __tmp = {
                let __b = self_.borrow();
                __b.response_headers_sm.clone()
            };
            self_.borrow_mut().response_headers = __tmp.clone();
            __tmp
        };
        return self_;
    }

    pub fn request(self_: &crate::HxRefCell<Http>, post: Option<bool>) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        let post_flag: bool = post == Some(true)
            || !({
                let __b = __hx_this.borrow();
                __b.post_bytes.clone()
            })
            .is_null()
            || !({
                let __b = __hx_this.borrow();
                __b.post_data.clone()
            })
            .is_null();
        if post_flag {
            ({
                let __b = __hx_this.borrow();
                __b.on_error.clone()
            })(hxrt::string::HxString::from(hxrt::string::HxString::from(
                "POST/request bodies are not implemented on this target yet.",
            )));
            return;
        }
        let output: crate::HxRef<crate::haxe_io_bytes_output::BytesOutput> =
            crate::haxe_io_bytes_output::BytesOutput::new();
        match hxrt::exception::catch_unwind(|| {
            crate::sys_http::Http::custom_request(
                &*__hx_this,
                false,
                {
                    let __tmp = output.clone();
                    let __up: crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync> =
                        match __tmp.as_arc_opt() {
                            Some(__rc) => __rc.clone(),
                            None => hxrt::exception::throw(hxrt::dynamic::from(String::from(
                                "Null Access",
                            ))),
                        };
                    __up
                },
                None,
                hxrt::string::HxString::null(),
            );
            crate::sys_http::Http::success(
                &*__hx_this,
                crate::haxe_io_bytes_output::BytesOutput::get_bytes(&*output),
            );
        }) {
            Ok(__hx_ok) => __hx_ok,
            Err(__hx_ex) => {
                let e: hxrt::dynamic::Dynamic = __hx_ex;
                {
                    let __tmp = crate::haxe_io_bytes_output::BytesOutput::get_bytes(&*output);
                    __hx_this.borrow_mut().response_bytes = __tmp.clone();
                    __tmp
                };
                ({
                    let __b = __hx_this.borrow();
                    __b.on_error.clone()
                })(hxrt::string::HxString::from(hxrt::string::HxString::from(
                    format!("{}{}", "", hxrt::string::HxString::from(e.to_haxe_string())),
                )));
            }
        };
    }

    pub fn file_transfert(
        self_: &crate::HxRefCell<Http>,
        _argname: hxrt::string::HxString,
        _filename: hxrt::string::HxString,
        _file: crate::HxRc<dyn crate::haxe_io_input::InputTrait + Send + Sync>,
        _size: i32,
        _mime_type: hxrt::string::HxString,
    ) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        crate::sys_http::Http::file_transfer(
            &*__hx_this,
            hxrt::string::HxString::from(_argname),
            hxrt::string::HxString::from(_filename),
            _file.clone(),
            _size,
            hxrt::string::HxString::from(_mime_type),
        );
    }

    pub fn file_transfer(
        self_: &crate::HxRefCell<Http>,
        _argname: hxrt::string::HxString,
        _filename: hxrt::string::HxString,
        _file: crate::HxRc<dyn crate::haxe_io_input::InputTrait + Send + Sync>,
        _size: i32,
        _mime_type: hxrt::string::HxString,
    ) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        ({
            let __b = __hx_this.borrow();
            __b.on_error.clone()
        })(hxrt::string::HxString::from(hxrt::string::HxString::from(
            "Multipart file uploads are not implemented on this target yet.",
        )));
    }

    pub fn get_response_header_values(
        self_: &crate::HxRefCell<Http>,
        key: hxrt::string::HxString,
    ) -> hxrt::array::Array<hxrt::string::HxString> {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        let v: hxrt::string::HxString =
            hxrt::string::HxString::from(crate::haxe_ds_string_map::StringMap::get(
                &*({
                    let __b = __hx_this.borrow();
                    __b.response_headers_sm.clone()
                }),
                hxrt::string::HxString::from(key),
            ));
        if v.is_null() {
            return hxrt::array::Array::<hxrt::string::HxString>::new();
        }
        return hxrt::array::Array::<hxrt::string::HxString>::from_vec(vec![v]);
    }

    pub fn custom_request(
        self_: &crate::HxRefCell<Http>,
        post: bool,
        api: crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync>,
        _sock: Option<crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync>>,
        _method: hxrt::string::HxString,
    ) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        {
            let __tmp = hxrt::string::HxString::null();
            __hx_this.borrow_mut().response_as_string = __tmp.clone();
            __tmp
        };
        {
            let __tmp = crate::HxRef::<hxrt::bytes::Bytes>::null();
            __hx_this.borrow_mut().response_bytes = __tmp.clone();
            __tmp
        };
        {
            let __tmp = crate::haxe_ds_string_map::StringMap::<hxrt::string::HxString>::new();
            __hx_this.borrow_mut().response_headers_sm = __tmp.clone();
            __tmp
        };
        {
            let __tmp = {
                let __b = __hx_this.borrow();
                __b.response_headers_sm.clone()
            };
            __hx_this.borrow_mut().response_headers = __tmp.clone();
            __tmp
        };
        let parsed: crate::HxRef<hxrt::anon::Anon> =
            crate::sys_http::Http::parse_url(hxrt::string::HxString::from({
                let __b = __hx_this.borrow();
                __b.url.clone()
            }));
        if hxrt::string::len(
            parsed
                .borrow()
                .get::<hxrt::string::HxString>("host")
                .as_str(),
        ) == 0
        {
            ({
                let __b = __hx_this.borrow();
                __b.on_error.clone()
            })(hxrt::string::HxString::from(hxrt::string::HxString::from(
                "Invalid URL",
            )));
            return;
        }
        if post {
            ({
                let __b = __hx_this.borrow();
                __b.on_error.clone()
            })(hxrt::string::HxString::from(hxrt::string::HxString::from(
                "POST/request bodies are not implemented on this target yet.",
            )));
            return;
        }
        let host: hxrt::string::HxString =
            hxrt::string::HxString::from(parsed.borrow().get::<hxrt::string::HxString>("host"));
        let port: i32 = parsed.borrow().get::<i32>("port");
        let mut request: hxrt::string::HxString =
            hxrt::string::HxString::from(parsed.borrow().get::<hxrt::string::HxString>("path"));
        if hxrt::string::len(request.as_str()) == 0 {
            request = hxrt::string::HxString::from(hxrt::string::HxString::from("/"));
        }
        if hxrt::string::HxString::from(hxrt::string::char_at(request.as_str(), 0))
            != hxrt::string::HxString::from("/")
        {
            request = hxrt::string::HxString::from(hxrt::string::HxString::from(format!(
                "{}{}",
                "/", &request
            )));
        }
        let mut uri: hxrt::string::HxString =
            hxrt::string::HxString::from(hxrt::string::HxString::from(""));
        if (({
            let __b = __hx_this.borrow();
            __b.params.clone()
        })
        .len() as i32)
            > 0
        {
            let kv: hxrt::array::Array<hxrt::string::HxString> =
                hxrt::array::Array::<hxrt::string::HxString>::new();
            {
                let mut _g: i32 = 0;
                let _g1: hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>> = {
                    let __b = __hx_this.borrow();
                    __b.params.clone()
                };
                while _g < (_g1.len() as i32) {
                    let p: crate::HxRef<hxrt::anon::Anon> = _g1.get_unchecked(_g as usize);
                    {
                        _g = _g + 1;
                        _g
                    };
                    kv.push(hxrt::string::HxString::from(hxrt::string::HxString::from(
                        format!(
                            "{}{}{}",
                            crate::string_tools::StringTools::url_encode(
                                hxrt::string::HxString::from(
                                    p.borrow().get::<hxrt::string::HxString>("name")
                                )
                            ),
                            "=",
                            crate::string_tools::StringTools::url_encode(
                                hxrt::string::HxString::from(
                                    p.borrow().get::<hxrt::string::HxString>("value")
                                )
                            )
                        ),
                    )));
                }
            }
            uri = hxrt::string::HxString::from(hxrt::string::HxString::from(kv.join(
                hxrt::string::HxString::from(hxrt::string::HxString::from("&")),
            )));
        }
        let b: crate::HxRef<crate::haxe_io_bytes_output::BytesOutput> =
            crate::haxe_io_bytes_output::BytesOutput::new();
        crate::haxe_io_bytes_output::BytesOutput::write_string(
            &*b,
            hxrt::string::HxString::from(hxrt::string::HxString::from("GET ")),
            None,
        );
        crate::haxe_io_bytes_output::BytesOutput::write_string(
            &*b,
            hxrt::string::HxString::from(request.clone()),
            None,
        );
        if uri != hxrt::string::HxString::from("") {
            if hxrt::string::index_of(
                request.as_str(),
                hxrt::string::HxString::from(hxrt::string::HxString::from("?")).as_str(),
                Some(0),
            ) >= 0
            {
                crate::haxe_io_bytes_output::BytesOutput::write_string(
                    &*b,
                    hxrt::string::HxString::from(hxrt::string::HxString::from("&")),
                    None,
                );
            } else {
                crate::haxe_io_bytes_output::BytesOutput::write_string(
                    &*b,
                    hxrt::string::HxString::from(hxrt::string::HxString::from("?")),
                    None,
                );
            }
            crate::haxe_io_bytes_output::BytesOutput::write_string(
                &*b,
                hxrt::string::HxString::from(uri.clone()),
                None,
            );
        }
        crate::haxe_io_bytes_output::BytesOutput::write_string(
            &*b,
            hxrt::string::HxString::from(hxrt::string::HxString::from(format!(
                "{}{}{}",
                " HTTP/1.1\r\nHost: ", &host, "\r\n"
            ))),
            None,
        );
        crate::haxe_io_bytes_output::BytesOutput::write_string(
            &*b,
            hxrt::string::HxString::from(hxrt::string::HxString::from("Connection: close\r\n")),
            None,
        );
        {
            let mut _g_2: i32 = 0;
            let _g1_2: hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>> = {
                let __b = __hx_this.borrow();
                __b.headers.clone()
            };
            while _g_2 < (_g1_2.len() as i32) {
                let h: crate::HxRef<hxrt::anon::Anon> = _g1_2.get_unchecked(_g_2 as usize);
                {
                    _g_2 = _g_2 + 1;
                    _g_2
                };
                crate::haxe_io_bytes_output::BytesOutput::write_string(
                    &*b,
                    hxrt::string::HxString::from(h.borrow().get::<hxrt::string::HxString>("name")),
                    None,
                );
                crate::haxe_io_bytes_output::BytesOutput::write_string(
                    &*b,
                    hxrt::string::HxString::from(hxrt::string::HxString::from(": ")),
                    None,
                );
                crate::haxe_io_bytes_output::BytesOutput::write_string(
                    &*b,
                    hxrt::string::HxString::from(h.borrow().get::<hxrt::string::HxString>("value")),
                    None,
                );
                crate::haxe_io_bytes_output::BytesOutput::write_string(
                    &*b,
                    hxrt::string::HxString::from(hxrt::string::HxString::from("\r\n")),
                    None,
                );
            }
        }
        crate::haxe_io_bytes_output::BytesOutput::write_string(
            &*b,
            hxrt::string::HxString::from(hxrt::string::HxString::from("\r\n")),
            None,
        );
        let mut s: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync> = {
            let __tmp = crate::sys_net_socket::Socket::new();
            let __up: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync> =
                match __tmp.as_arc_opt() {
                    Some(__rc) => __rc.clone(),
                    None => {
                        hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access")))
                    }
                };
            __up
        };
        match hxrt::exception::catch_unwind(|| {
            if parsed.borrow().get::<bool>("secure") {
                let ss: crate::HxRef<crate::sys_ssl_socket::Socket> =
                    crate::sys_ssl_socket::Socket::new();
                s = {
                    let __tmp = ss.clone();
                    let __up: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync> =
                        match __tmp.as_arc_opt() {
                            Some(__rc) => __rc.clone(),
                            None => hxrt::exception::throw(hxrt::dynamic::from(String::from(
                                "Null Access",
                            ))),
                        };
                    __up
                };
                crate::sys_ssl_socket::Socket::set_timeout(&*ss, {
                    let __b = __hx_this.borrow();
                    __b.cnx_timeout
                });
                crate::sys_ssl_socket::Socket::set_hostname(
                    &*ss,
                    hxrt::string::HxString::from(host.clone()),
                );
                crate::sys_ssl_socket::Socket::connect(
                    &*ss,
                    crate::sys_net_host::Host::new(hxrt::string::HxString::from(host.clone())),
                    port,
                );
                crate::sys_ssl_socket::Socket::handshake(&*ss);
            } else {
                s.set_timeout({
                    let __b = __hx_this.borrow();
                    __b.cnx_timeout
                });
                s.connect(
                    crate::sys_net_host::Host::new(hxrt::string::HxString::from(host.clone())),
                    port,
                );
            }
            crate::sys_http::Http::write_body(&*__hx_this, b.clone(), s.clone());
            crate::sys_http::Http::read_http_response(&*__hx_this, api.clone(), s.clone());
            s.close();
        }) {
            Ok(__hx_ok) => __hx_ok,
            Err(__hx_ex) => {
                let e: hxrt::dynamic::Dynamic = __hx_ex;
                match hxrt::exception::catch_unwind(|| {
                    s.close();
                }) {
                    Ok(__hx_ok) => __hx_ok,
                    Err(__hx_ex) => {
                        let _ = __hx_ex;
                    }
                };
                ({
                    let __b = __hx_this.borrow();
                    __b.on_error.clone()
                })(hxrt::string::HxString::from(hxrt::string::HxString::from(
                    format!("{}{}", "", hxrt::string::HxString::from(e.to_haxe_string())),
                )));
            }
        };
    }

    fn write_body(
        _self_: &crate::HxRefCell<Http>,
        body: crate::HxRef<crate::haxe_io_bytes_output::BytesOutput>,
        sock: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync>,
    ) {
        let bytes: crate::HxRef<hxrt::bytes::Bytes> =
            crate::haxe_io_bytes_output::BytesOutput::get_bytes(&*body);
        sock.__hx_get_output()
            .write_full_bytes(bytes.clone(), 0, bytes.borrow().length());
    }

    fn read_http_response(
        self_: &crate::HxRefCell<Http>,
        api: crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync>,
        sock: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync>,
    ) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        sock.set_timeout({
            let __b = __hx_this.borrow();
            __b.cnx_timeout
        });
        let status_line: hxrt::string::HxString =
            hxrt::string::HxString::from(sock.__hx_get_input().read_line());
        let status: i32 =
            crate::sys_http::Http::parse_status(hxrt::string::HxString::from(status_line));
        let mut size: i32 = -1;
        let mut chunked: bool = false;
        loop {
            let line: hxrt::string::HxString =
                hxrt::string::HxString::from(sock.__hx_get_input().read_line());
            if line == hxrt::string::HxString::from("") {
                break;
            }
            let sep: i32 = hxrt::string::index_of(
                line.as_str(),
                hxrt::string::HxString::from(hxrt::string::HxString::from(":")).as_str(),
                Some(0),
            );
            if sep < 0 {
                continue;
            }
            let hname: hxrt::string::HxString = hxrt::string::HxString::from(
                hxrt::string::HxString::from(hxrt::string::substr(line.as_str(), 0, Some(sep))),
            );
            let hval: hxrt::string::HxString = hxrt::string::HxString::from({
                let s: hxrt::string::HxString =
                    hxrt::string::HxString::from(hxrt::string::HxString::from(
                        hxrt::string::substr(line.as_str(), sep + 1, None),
                    ));
                crate::string_tools::StringTools::ltrim(hxrt::string::HxString::from(
                    crate::string_tools::StringTools::rtrim(hxrt::string::HxString::from(
                        s.clone(),
                    )),
                ))
            });
            let hn: hxrt::string::HxString = hxrt::string::HxString::from(
                hxrt::string::HxString::from(hxrt::string::to_lower_case(hname.as_str())),
            );
            if hn == hxrt::string::HxString::from("content-length") {
                size = crate::sys_http::Http::parse_dec_int(hxrt::string::HxString::from(
                    hval.clone(),
                ));
            } else {
                if hn == hxrt::string::HxString::from("transfer-encoding") {
                    chunked =
                        hxrt::string::HxString::from(hxrt::string::to_lower_case(hval.as_str()))
                            == hxrt::string::HxString::from("chunked");
                }
            }
            crate::haxe_ds_string_map::StringMap::set(
                &*({
                    let __b = __hx_this.borrow();
                    __b.response_headers_sm.clone()
                }),
                hxrt::string::HxString::from(hname.clone()),
                hxrt::string::HxString::from(hval.clone()),
            );
        }
        ({
            let __b = __hx_this.borrow();
            __b.on_status.clone()
        })(status);
        let bufsize: i32 = 1024;
        let buf: crate::HxRef<hxrt::bytes::Bytes> =
            crate::HxRef::new(hxrt::bytes::Bytes::alloc(bufsize as usize));
        if chunked {
            crate::sys_http::Http::read_chunked(&*__hx_this, api.clone(), sock.clone());
        } else {
            if size < 0 {
                if !({
                    let __b = __hx_this.borrow();
                    __b.no_shutdown
                }) {
                    sock.shutdown(false, true);
                }
                match hxrt::exception::catch_unwind(|| loop {
                    let len: i32 = sock.__hx_get_input().read_bytes(buf.clone(), 0, bufsize);
                    if len == 0 {
                        break;
                    }
                    api.write_bytes(buf.clone(), 0, len);
                }) {
                    Ok(__hx_ok) => __hx_ok,
                    Err(__hx_ex) => {
                        match __hx_ex.downcast::<crate::HxRef<crate::haxe_io_eof::Eof>>() {
                            Ok(_) => {}
                            Err(__hx_ex) => hxrt::exception::rethrow(__hx_ex),
                        }
                    }
                };
            } else {
                api.prepare(size);
                let mut remaining: i32 = size;
                match hxrt::exception::catch_unwind(|| {
                    while remaining > 0 {
                        let want: i32 = if remaining > bufsize {
                            bufsize
                        } else {
                            remaining
                        };
                        let len_2: i32 = sock.__hx_get_input().read_bytes(buf.clone(), 0, want);
                        if len_2 == 0 {
                            hxrt::exception::throw(hxrt::dynamic::from(
                                hxrt::string::HxString::from("Transfer aborted"),
                            ));
                        }
                        api.write_bytes(buf.clone(), 0, len_2);
                        {
                            remaining = remaining - len_2;
                            remaining
                        };
                    }
                }) {
                    Ok(__hx_ok) => __hx_ok,
                    Err(__hx_ex) => {
                        match __hx_ex.downcast::<crate::HxRef<crate::haxe_io_eof::Eof>>() {
                            Ok(_) => {
                                hxrt::exception::throw(hxrt::dynamic::from(
                                    hxrt::string::HxString::from("Transfer aborted"),
                                ));
                            }
                            Err(__hx_ex) => hxrt::exception::rethrow(__hx_ex),
                        }
                    }
                };
            }
        }
        if status < 200 || status >= 400 {
            hxrt::exception::throw(hxrt::dynamic::from(hxrt::string::HxString::from(format!(
                "{}{}",
                "Http Error #",
                hxrt::dynamic::from(status).to_haxe_string()
            ))));
        }
        api.close();
    }

    fn read_chunked(
        _self_: &crate::HxRefCell<Http>,
        api: crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync>,
        sock: crate::HxRc<dyn crate::sys_net_socket::SocketTrait + Send + Sync>,
    ) {
        loop {
            let mut size_line: hxrt::string::HxString =
                hxrt::string::HxString::from(sock.__hx_get_input().read_line());
            let semi: i32 = hxrt::string::index_of(
                size_line.as_str(),
                hxrt::string::HxString::from(hxrt::string::HxString::from(";")).as_str(),
                Some(0),
            );
            if semi >= 0 {
                size_line = hxrt::string::HxString::from(hxrt::string::HxString::from(
                    hxrt::string::substr(size_line.as_str(), 0, Some(semi)),
                ));
            }
            size_line = hxrt::string::HxString::from(crate::string_tools::StringTools::ltrim(
                hxrt::string::HxString::from(crate::string_tools::StringTools::rtrim(
                    hxrt::string::HxString::from(size_line.clone()),
                )),
            ));
            let size: i32 = crate::sys_http::Http::parse_hex_int(hxrt::string::HxString::from(
                size_line.clone(),
            ));
            if size < 0 {
                hxrt::exception::throw(hxrt::dynamic::from(hxrt::string::HxString::from(
                    "Invalid chunk",
                )));
            }
            if size == 0 {
                loop {
                    let trailer: hxrt::string::HxString =
                        hxrt::string::HxString::from(sock.__hx_get_input().read_line());
                    if trailer == hxrt::string::HxString::from("") {
                        break;
                    }
                }
                return;
            }
            let bytes: crate::HxRef<hxrt::bytes::Bytes> =
                crate::HxRef::new(hxrt::bytes::Bytes::alloc(size as usize));
            sock.__hx_get_input()
                .read_full_bytes(bytes.clone(), 0, size);
            api.write_bytes(bytes.clone(), 0, size);
            sock.__hx_get_input().read_line();
        }
    }

    pub fn set_header(
        self_: &crate::HxRefCell<Http>,
        name: hxrt::string::HxString,
        value: hxrt::string::HxString,
    ) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        {
            let mut _g: i32 = 0;
            let _g1: i32 = ({
                let __b = __hx_this.borrow();
                __b.headers.clone()
            })
            .len() as i32;
            while _g < _g1 {
                let i: i32 = {
                    let __tmp = _g;
                    _g = _g + 1;
                    __tmp
                };
                if ({
                    let __b = __hx_this.borrow();
                    __b.headers.clone()
                })
                .get_unchecked(i as usize)
                .borrow()
                .get::<hxrt::string::HxString>("name")
                    == name
                {
                    {
                        let __tmp = {
                            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
                            {
                                let mut __b = __o.borrow_mut();
                                __b.set("name", name.clone());
                                __b.set("value", value.clone());
                            };
                            __o
                        };
                        ({
                            let __b = __hx_this.borrow();
                            __b.headers.clone()
                        })
                        .set_haxe(i as usize, __tmp.clone(), move || crate::HxRef::null());
                        __tmp
                    };
                    return;
                }
            }
        }
        ({
            let __b = __hx_this.borrow();
            __b.headers.clone()
        })
        .push({
            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
            {
                let mut __b = __o.borrow_mut();
                __b.set("name", name.clone());
                __b.set("value", value.clone());
            };
            __o
        });
    }

    pub fn add_header(
        self_: &crate::HxRefCell<Http>,
        header: hxrt::string::HxString,
        value: hxrt::string::HxString,
    ) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        ({
            let __b = __hx_this.borrow();
            __b.headers.clone()
        })
        .push({
            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
            {
                let mut __b = __o.borrow_mut();
                __b.set("name", header);
                __b.set("value", value);
            };
            __o
        });
    }

    pub fn set_parameter(
        self_: &crate::HxRefCell<Http>,
        name: hxrt::string::HxString,
        value: hxrt::string::HxString,
    ) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        {
            let mut _g: i32 = 0;
            let _g1: i32 = ({
                let __b = __hx_this.borrow();
                __b.params.clone()
            })
            .len() as i32;
            while _g < _g1 {
                let i: i32 = {
                    let __tmp = _g;
                    _g = _g + 1;
                    __tmp
                };
                if ({
                    let __b = __hx_this.borrow();
                    __b.params.clone()
                })
                .get_unchecked(i as usize)
                .borrow()
                .get::<hxrt::string::HxString>("name")
                    == name
                {
                    {
                        let __tmp = {
                            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
                            {
                                let mut __b = __o.borrow_mut();
                                __b.set("name", name.clone());
                                __b.set("value", value.clone());
                            };
                            __o
                        };
                        ({
                            let __b = __hx_this.borrow();
                            __b.params.clone()
                        })
                        .set_haxe(i as usize, __tmp.clone(), move || crate::HxRef::null());
                        __tmp
                    };
                    return;
                }
            }
        }
        ({
            let __b = __hx_this.borrow();
            __b.params.clone()
        })
        .push({
            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
            {
                let mut __b = __o.borrow_mut();
                __b.set("name", name.clone());
                __b.set("value", value.clone());
            };
            __o
        });
    }

    pub fn add_parameter(
        self_: &crate::HxRefCell<Http>,
        name: hxrt::string::HxString,
        value: hxrt::string::HxString,
    ) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        ({
            let __b = __hx_this.borrow();
            __b.params.clone()
        })
        .push({
            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
            {
                let mut __b = __o.borrow_mut();
                __b.set("name", name);
                __b.set("value", value);
            };
            __o
        });
    }

    pub fn set_post_data(self_: &crate::HxRefCell<Http>, data: hxrt::string::HxString) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        {
            let __tmp = data;
            __hx_this.borrow_mut().post_data = __tmp.clone();
            __tmp
        };
        {
            let __tmp = crate::HxRef::<hxrt::bytes::Bytes>::null();
            __hx_this.borrow_mut().post_bytes = __tmp.clone();
            __tmp
        };
    }

    pub fn set_post_bytes(self_: &crate::HxRefCell<Http>, data: crate::HxRef<hxrt::bytes::Bytes>) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        {
            let __tmp = data;
            __hx_this.borrow_mut().post_bytes = __tmp.clone();
            __tmp
        };
        {
            let __tmp = hxrt::string::HxString::null();
            __hx_this.borrow_mut().post_data = __tmp.clone();
            __tmp
        };
    }

    fn success(self_: &crate::HxRefCell<Http>, data: crate::HxRef<hxrt::bytes::Bytes>) {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        {
            let __tmp = data.clone();
            __hx_this.borrow_mut().response_bytes = __tmp.clone();
            __tmp
        };
        let s: hxrt::string::HxString = hxrt::string::HxString::from(data.borrow().to_string());
        {
            let __tmp = s.clone();
            __hx_this.borrow_mut().response_as_string = hxrt::string::HxString::from(__tmp.clone());
            __tmp
        };
        ({
            let __b = __hx_this.borrow();
            __b.on_data.clone()
        })(hxrt::string::HxString::from(s.clone()));
        ({
            let __b = __hx_this.borrow();
            __b.on_bytes.clone()
        })(data.clone());
    }

    pub fn get_response_data(self_: &crate::HxRefCell<Http>) -> hxrt::string::HxString {
        let __hx_this: crate::HxRef<crate::sys_http::Http> = self_.self_ref();
        return hxrt::string::HxString::from({
            let __b = __hx_this.borrow();
            __b.response_as_string.clone()
        });
    }

    fn parse_url(url: hxrt::string::HxString) -> crate::HxRef<hxrt::anon::Anon> {
        let mut u: hxrt::string::HxString = hxrt::string::HxString::from(url);
        let mut secure: bool = false;
        if hxrt::string::index_of(
            u.as_str(),
            hxrt::string::HxString::from(hxrt::string::HxString::from("http://")).as_str(),
            Some(0),
        ) == 0
        {
            u = hxrt::string::HxString::from(hxrt::string::HxString::from(hxrt::string::substr(
                u.as_str(),
                hxrt::string::len(hxrt::string::HxString::from("http://").as_str()),
                None,
            )));
        } else {
            if hxrt::string::index_of(
                u.as_str(),
                hxrt::string::HxString::from(hxrt::string::HxString::from("https://")).as_str(),
                Some(0),
            ) == 0
            {
                secure = true;
                u = hxrt::string::HxString::from(hxrt::string::HxString::from(
                    hxrt::string::substr(
                        u.as_str(),
                        hxrt::string::len(hxrt::string::HxString::from("https://").as_str()),
                        None,
                    ),
                ));
            }
        }
        let slash: i32 = hxrt::string::index_of(
            u.as_str(),
            hxrt::string::HxString::from(hxrt::string::HxString::from("/")).as_str(),
            Some(0),
        );
        let host_port: hxrt::string::HxString = hxrt::string::HxString::from(if slash >= 0 {
            hxrt::string::HxString::from(hxrt::string::substr(u.as_str(), 0, Some(slash)))
        } else {
            hxrt::string::HxString::from(hxrt::string::substr(
                u.as_str(),
                0,
                Some(hxrt::string::len(u.as_str())),
            ))
        });
        let path: hxrt::string::HxString = hxrt::string::HxString::from(if slash >= 0 {
            hxrt::string::HxString::from(hxrt::string::substr(u.as_str(), slash, None))
        } else {
            hxrt::string::HxString::from("/")
        });
        if hxrt::string::len(host_port.as_str()) == 0 {
            return {
                let __o = crate::HxRef::new(hxrt::anon::Anon::new());
                {
                    let mut __b = __o.borrow_mut();
                    __b.set("secure", secure);
                    __b.set("host", hxrt::string::HxString::from(""));
                    __b.set("port", 0);
                    __b.set("path", hxrt::string::HxString::from("/"));
                };
                __o
            };
        }
        let mut host: hxrt::string::HxString = hxrt::string::HxString::from(host_port.clone());
        let mut port: i32 = if secure { 443 } else { 80 };
        let colon: i32 = hxrt::string::index_of(
            host_port.as_str(),
            hxrt::string::HxString::from(hxrt::string::HxString::from(":")).as_str(),
            Some(0),
        );
        if colon >= 0 {
            host = hxrt::string::HxString::from(hxrt::string::HxString::from(
                hxrt::string::substr(host_port.as_str(), 0, Some(colon)),
            ));
            let p: i32 = crate::sys_http::Http::parse_dec_int(hxrt::string::HxString::from(
                hxrt::string::HxString::from(hxrt::string::substr(
                    host_port.as_str(),
                    colon + 1,
                    None,
                )),
            ));
            if p < 0 {
                return {
                    let __o = crate::HxRef::new(hxrt::anon::Anon::new());
                    {
                        let mut __b = __o.borrow_mut();
                        __b.set("secure", secure);
                        __b.set("host", hxrt::string::HxString::from(""));
                        __b.set("port", 0);
                        __b.set("path", hxrt::string::HxString::from("/"));
                    };
                    __o
                };
            }
            port = p;
        }
        if hxrt::string::len(host.as_str()) == 0 {
            return {
                let __o = crate::HxRef::new(hxrt::anon::Anon::new());
                {
                    let mut __b = __o.borrow_mut();
                    __b.set("secure", secure);
                    __b.set("host", hxrt::string::HxString::from(""));
                    __b.set("port", 0);
                    __b.set("path", hxrt::string::HxString::from("/"));
                };
                __o
            };
        }
        return {
            let __o = crate::HxRef::new(hxrt::anon::Anon::new());
            {
                let mut __b = __o.borrow_mut();
                __b.set("secure", secure);
                __b.set("host", host.clone());
                __b.set("port", port);
                __b.set("path", path);
            };
            __o
        };
    }

    fn parse_dec_int(s: hxrt::string::HxString) -> i32 {
        return s.parse::<i32>().unwrap_or(-1);
    }

    fn parse_hex_int(s: hxrt::string::HxString) -> i32 {
        return i32::from_str_radix(s.trim(), 16).unwrap_or(-1);
    }

    fn parse_status(line: hxrt::string::HxString) -> i32 {
        let first: i32 = hxrt::string::index_of(
            line.as_str(),
            hxrt::string::HxString::from(hxrt::string::HxString::from(" ")).as_str(),
            Some(0),
        );
        if first < 0 {
            hxrt::exception::throw(hxrt::dynamic::from(hxrt::string::HxString::from(
                "Response status error",
            )));
        }
        let mut second: i32 = hxrt::string::index_of(
            line.as_str(),
            hxrt::string::HxString::from(hxrt::string::HxString::from(" ")).as_str(),
            Some(first + 1),
        );
        if second < 0 {
            second = hxrt::string::len(line.as_str());
        }
        let code_str: hxrt::string::HxString =
            hxrt::string::HxString::from(hxrt::string::HxString::from(hxrt::string::substr(
                line.as_str(),
                first + 1,
                Some(second - first - 1),
            )));
        let n: i32 = crate::sys_http::Http::parse_dec_int(hxrt::string::HxString::from(code_str));
        if n < 0 {
            hxrt::exception::throw(hxrt::dynamic::from(hxrt::string::HxString::from(
                "Response status error",
            )));
        }
        return n;
    }

    pub fn request_url(url: hxrt::string::HxString) -> hxrt::string::HxString {
        let h: crate::HxRef<crate::sys_http::Http> =
            crate::sys_http::Http::new(hxrt::string::HxString::from(url));
        let out: crate::HxRef<crate::haxe_io_bytes_output::BytesOutput> =
            crate::haxe_io_bytes_output::BytesOutput::new();
        {
            let __tmp = {
                let __rc: crate::HxRc<dyn Fn(hxrt::string::HxString) + Send + Sync> =
                    crate::HxRc::new(move |e: hxrt::string::HxString| {
                        hxrt::exception::throw(hxrt::dynamic::from(e));
                    });
                crate::HxDynRef::new(__rc)
            };
            h.borrow_mut().on_error = __tmp.clone();
            __tmp
        };
        crate::sys_http::Http::custom_request(
            &*h,
            false,
            {
                let __tmp = out.clone();
                let __up: crate::HxRc<dyn crate::haxe_io_output::OutputTrait + Send + Sync> =
                    match __tmp.as_arc_opt() {
                        Some(__rc) => __rc.clone(),
                        None => {
                            hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access")))
                        }
                    };
                __up
            },
            None,
            hxrt::string::HxString::null(),
        );
        return hxrt::string::HxString::from(
            crate::haxe_io_bytes_output::BytesOutput::get_bytes(&*out)
                .borrow()
                .to_string(),
        );
    }
}

impl crate::haxe_http_http_base::HttpBaseTrait for crate::HxRefCell<Http> {
    fn __hx_get_url(&self) -> hxrt::string::HxString {
        self.borrow().url.clone()
    }
    fn __hx_set_url(&self, v: hxrt::string::HxString) {
        self.borrow_mut().url = v;
    }
    fn __hx_get_response_bytes(&self) -> crate::HxRef<hxrt::bytes::Bytes> {
        self.borrow().response_bytes.clone()
    }
    fn __hx_set_response_bytes(&self, v: crate::HxRef<hxrt::bytes::Bytes>) {
        self.borrow_mut().response_bytes = v;
    }
    fn __hx_get_response_as_string(&self) -> hxrt::string::HxString {
        self.borrow().response_as_string.clone()
    }
    fn __hx_set_response_as_string(&self, v: hxrt::string::HxString) {
        self.borrow_mut().response_as_string = v;
    }
    fn __hx_get_post_data(&self) -> hxrt::string::HxString {
        self.borrow().post_data.clone()
    }
    fn __hx_set_post_data(&self, v: hxrt::string::HxString) {
        self.borrow_mut().post_data = v;
    }
    fn __hx_get_post_bytes(&self) -> crate::HxRef<hxrt::bytes::Bytes> {
        self.borrow().post_bytes.clone()
    }
    fn __hx_set_post_bytes(&self, v: crate::HxRef<hxrt::bytes::Bytes>) {
        self.borrow_mut().post_bytes = v;
    }
    fn __hx_get_headers(&self) -> hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>> {
        self.borrow().headers.clone()
    }
    fn __hx_set_headers(&self, v: hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>>) {
        self.borrow_mut().headers = v;
    }
    fn __hx_get_params(&self) -> hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>> {
        self.borrow().params.clone()
    }
    fn __hx_set_params(&self, v: hxrt::array::Array<crate::HxRef<hxrt::anon::Anon>>) {
        self.borrow_mut().params = v;
    }
    fn __hx_get_on_data(&self) -> crate::HxDynRef<dyn Fn(hxrt::string::HxString) + Send + Sync> {
        self.borrow().on_data.clone()
    }
    fn __hx_set_on_data(&self, v: crate::HxDynRef<dyn Fn(hxrt::string::HxString) + Send + Sync>) {
        self.borrow_mut().on_data = v;
    }
    fn __hx_get_on_bytes(
        &self,
    ) -> crate::HxDynRef<dyn Fn(crate::HxRef<hxrt::bytes::Bytes>) + Send + Sync> {
        self.borrow().on_bytes.clone()
    }
    fn __hx_set_on_bytes(
        &self,
        v: crate::HxDynRef<dyn Fn(crate::HxRef<hxrt::bytes::Bytes>) + Send + Sync>,
    ) {
        self.borrow_mut().on_bytes = v;
    }
    fn __hx_get_on_error(&self) -> crate::HxDynRef<dyn Fn(hxrt::string::HxString) + Send + Sync> {
        self.borrow().on_error.clone()
    }
    fn __hx_set_on_error(&self, v: crate::HxDynRef<dyn Fn(hxrt::string::HxString) + Send + Sync>) {
        self.borrow_mut().on_error = v;
    }
    fn __hx_get_on_status(&self) -> crate::HxDynRef<dyn Fn(i32) + Send + Sync> {
        self.borrow().on_status.clone()
    }
    fn __hx_set_on_status(&self, v: crate::HxDynRef<dyn Fn(i32) + Send + Sync>) {
        self.borrow_mut().on_status = v;
    }
    fn add_header(&self, header: hxrt::string::HxString, value: hxrt::string::HxString) -> () {
        Http::add_header(self, header, value)
    }
    fn add_parameter(&self, name: hxrt::string::HxString, value: hxrt::string::HxString) -> () {
        Http::add_parameter(self, name, value)
    }
    fn get_response_data(&self) -> hxrt::string::HxString {
        Http::get_response_data(self)
    }
    fn request(&self, _post: Option<bool>) -> () {
        Http::request(self, _post)
    }
    fn set_header(&self, name: hxrt::string::HxString, value: hxrt::string::HxString) -> () {
        Http::set_header(self, name, value)
    }
    fn set_parameter(&self, name: hxrt::string::HxString, value: hxrt::string::HxString) -> () {
        Http::set_parameter(self, name, value)
    }
    fn set_post_bytes(&self, data: crate::HxRef<hxrt::bytes::Bytes>) -> () {
        Http::set_post_bytes(self, data)
    }
    fn set_post_data(&self, data: hxrt::string::HxString) -> () {
        Http::set_post_data(self, data)
    }
    fn success(&self, data: crate::HxRef<hxrt::bytes::Bytes>) -> () {
        Http::success(self, data)
    }
    fn __hx_type_id(&self) -> u32 {
        crate::sys_http::__HX_TYPE_ID
    }
}
