// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0x35260b66u32;

#[derive(Debug)]

pub struct Thread {
    _id: i32,
}

impl Thread {
    pub fn new(id: i32) -> crate::HxRef<crate::sys_thread_thread::Thread> {
        let self_: crate::HxRef<crate::sys_thread_thread::Thread> =
            crate::HxRef::new(Thread { _id: id });
        return self_;
    }

    pub fn get_events(
        self_: &crate::HxRefCell<Thread>,
    ) -> crate::HxRef<crate::sys_thread_event_loop::EventLoop> {
        let __hx_this: crate::HxRef<crate::sys_thread_thread::Thread> = self_.self_ref();
        return crate::sys_thread_event_loop::EventLoop::_from_thread_id({
            let __b = __hx_this.borrow();
            __b._id
        });
    }

    pub fn send_message(self_: &crate::HxRefCell<Thread>, msg: hxrt::dynamic::Dynamic) {
        let __hx_this: crate::HxRef<crate::sys_thread_thread::Thread> = self_.self_ref();
        hxrt::thread::thread_send_message(
            {
                let __b = __hx_this.borrow();
                __b._id
            },
            msg,
        );
    }

    pub fn current() -> crate::HxRef<crate::sys_thread_thread::Thread> {
        let id: i32 = hxrt::thread::thread_current_id();
        return crate::sys_thread_thread::Thread::new(id);
    }

    pub fn create(
        job: crate::HxDynRef<dyn Fn() + Send + Sync>,
    ) -> crate::HxRef<crate::sys_thread_thread::Thread> {
        let id: i32 = hxrt::thread::thread_spawn(job);
        return crate::sys_thread_thread::Thread::new(id);
    }

    pub fn run_with_event_loop(job: crate::HxDynRef<dyn Fn() + Send + Sync>) {
        job();
        let id: i32 = hxrt::thread::thread_current_id();
        hxrt::thread::event_loop_loop(id);
    }

    pub fn create_with_event_loop(
        job: crate::HxDynRef<dyn Fn() + Send + Sync>,
    ) -> crate::HxRef<crate::sys_thread_thread::Thread> {
        let id: i32 = hxrt::thread::thread_spawn_with_event_loop(job);
        return crate::sys_thread_thread::Thread::new(id);
    }

    pub fn read_message(block: bool) -> hxrt::dynamic::Dynamic {
        return hxrt::thread::thread_read_message(block);
    }

    pub fn read_message_as<T>(
        block: bool,
        decode: crate::HxDynRef<dyn Fn(hxrt::dynamic::Dynamic) -> Option<T> + Send + Sync>,
    ) -> Option<T> {
        let raw: hxrt::dynamic::Dynamic = crate::sys_thread_thread::Thread::read_message(block);
        if raw.is_null() {
            return None;
        }
        return decode(raw.clone());
    }

    pub fn read_message_string(block: bool) -> hxrt::string::HxString {
        let raw: hxrt::dynamic::Dynamic = crate::sys_thread_thread::Thread::read_message(block);
        if raw.is_null() {
            return hxrt::string::HxString::from(hxrt::string::HxString::null());
        }
        if {
            let __dyn = raw.clone();
            __dyn.downcast_ref::<String>().is_some()
                || __dyn.downcast_ref::<hxrt::string::HxString>().is_some()
        } {
            return hxrt::string::HxString::from({
                let __hx_dyn = raw;
                if __hx_dyn.is_null() {
                    hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access")))
                } else {
                    __hx_dyn
                        .downcast_ref::<hxrt::string::HxString>()
                        .unwrap()
                        .clone()
                }
            });
        }
        return hxrt::string::HxString::from(hxrt::string::HxString::null());
    }

    fn process_events() {
        crate::sys_thread_event_loop::EventLoop::progress(
            &*crate::sys_thread_thread::Thread::get_events(
                &*crate::sys_thread_thread::Thread::current(),
            ),
        );
    }
}
