// Generated by reflaxe.rust (POC)

#![allow(dead_code)]
#![allow(type_alias_bounds)]

type HxRc<T> = hxrt::cell::HxRc<T>;
type HxDynRef<T: ?Sized> = hxrt::cell::HxDynRef<T>;
type HxRefCell<T> = hxrt::cell::HxCell<T>;
type HxRef<T> = hxrt::cell::HxRef<T>;

mod action;
mod haxe_call_stack_call_stack_impl_;
mod haxe_exception;
mod haxe_stack_item;
mod rust_tui_constraint;
mod rust_tui_event;
mod rust_tui_fx_kind;
mod rust_tui_key_code;
mod rust_tui_key_mods_key_mods_impl_;
mod rust_tui_layout_dir;
mod rust_tui_style_token;
mod rust_tui_ui_node;
mod task;
mod tui_demo;

/// Runtime subtype check for stable Haxe class type ids.
///
/// Generated by reflaxe.rust from the emitted class inheritance graph.
#[inline]
pub(crate) fn __hx_is_subtype_type_id(actual: u32, expected: u32) -> bool {
    if actual == expected {
        return true;
    }
    false
}

fn main() {
    let tasks: hxrt::array::Array<crate::HxRef<crate::task::Task>> = hxrt::array::Array::<
        crate::HxRef<crate::task::Task>,
    >::from_vec(vec![
        crate::task::Task::new(
            hxrt::string::HxString::from(hxrt::string::HxString::from("bootstrap reflaxe.rust")),
            true,
        ),
        crate::task::Task::new(
            hxrt::string::HxString::from(hxrt::string::HxString::from("add enums + switch")),
            false,
        ),
        crate::task::Task::new(
            hxrt::string::HxString::from(hxrt::string::HxString::from("ship ratatui demo")),
            false,
        ),
    ]);
    let actions: hxrt::array::Array<crate::action::Action> =
        hxrt::array::Array::<crate::action::Action>::from_vec(vec![
            crate::action::Action::Down,
            crate::action::Action::Toggle,
            crate::action::Action::Down,
            crate::action::Action::Toggle,
            crate::action::Action::Up,
            crate::action::Action::Quit,
        ]);
    let mut selected: i32 = 0;
    let mut frame: i32 = 0;
    let mut i: i32 = 0;
    while i < (actions.len() as i32) {
        let action: crate::action::Action = actions.get_unchecked(i as usize);
        match action.clone() {
            crate::action::Action::Up => {
                if selected > 0 {
                    selected = selected - 1;
                }
            }
            crate::action::Action::Down => {
                if selected < tasks.len() as i32 - 1 {
                    selected = selected + 1;
                }
            }
            crate::action::Action::Toggle => {
                crate::task::Task::toggle(&*tasks.get_unchecked(selected as usize));
            }
            crate::action::Action::Quit => {
                break;
            }
        }
        let mut lines: hxrt::string::HxString =
            hxrt::string::HxString::from(hxrt::string::HxString::from(""));
        let mut j: i32 = 0;
        while j < (tasks.len() as i32) {
            lines = hxrt::string::HxString::from(hxrt::string::HxString::from(format!(
                "{}{}{}",
                &lines,
                crate::task::Task::line(&*tasks.get_unchecked(j as usize), j == selected),
                "\n"
            )));
            j = j + 1;
        }
        crate::tui_demo::run_frame(frame, hxrt::string::HxString::from(lines.clone()));
        frame = frame + 1;
        i = i + 1;
    }
}
