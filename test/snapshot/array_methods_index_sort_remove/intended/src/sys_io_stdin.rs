// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0xfb16179cu32;

#[derive(Debug)]

pub struct Stdin {
    pub big_endian: bool,
}

impl Stdin {
    pub fn new() -> crate::HxRef<crate::sys_io_stdin::Stdin> {
        let self_: crate::HxRef<crate::sys_io_stdin::Stdin> =
            crate::HxRef::new(Stdin { big_endian: false });
        return self_;
    }

    pub fn read_byte(_self_: &crate::HxRefCell<Stdin>) -> i32 {
        let c: i32 = {
            use std::io::Read;
            let mut buf = [0u8; 1];
            match std::io::stdin().read(&mut buf) {
                Ok(0) => -1i32,
                Ok(_) => buf[0] as i32,
                Err(_) => -1i32,
            }
        };
        if c < 0 {
            hxrt::exception::throw(hxrt::dynamic::from(crate::haxe_io_eof::Eof::new()));
        }
        return c;
    }

    pub fn read_bytes(
        _self_: &crate::HxRefCell<Stdin>,
        s: crate::HxRef<hxrt::bytes::Bytes>,
        pos: i32,
        len: i32,
    ) -> i32 {
        if pos < 0 || len < 0 || pos + len > s.borrow().length() {
            hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::OutsideBounds));
        }
        if len == 0 {
            return 0;
        }
        return {
            use std::io::Read;
            let mut buf = vec![0u8; len as usize];
            match std::io::stdin().read(&mut buf) {
                Ok(n) => {
                    if n == 0 {
                        return 0i32;
                    }
                    let mut b = s.borrow_mut();
                    let base = pos as i32;
                    let mut i: usize = 0;
                    while i < n {
                        b.set(base + i as i32, buf[i] as i32);
                        i += 1;
                    }
                    n as i32
                }
                Err(_) => 0i32,
            }
        };
    }

    pub fn close(_self_: &crate::HxRefCell<Stdin>) {}

    pub fn set_big_endian(self_: &crate::HxRefCell<Stdin>, b: bool) -> bool {
        let __hx_this: crate::HxRef<crate::sys_io_stdin::Stdin> = self_.self_ref();
        {
            let __tmp = b;
            __hx_this.borrow_mut().big_endian = __tmp;
            __tmp
        };
        return b;
    }

    pub fn read_all(
        self_: &crate::HxRefCell<Stdin>,
        bufsize: Option<i32>,
    ) -> crate::HxRef<hxrt::bytes::Bytes> {
        let __hx_this: crate::HxRef<crate::sys_io_stdin::Stdin> = self_.self_ref();
        let mut bs: Option<i32> = bufsize;
        if bs.is_none() {
            {
                let __tmp = 16384;
                bs = Some(__tmp);
                __tmp
            };
        }
        let bufsize_2: i32 = {
            let __hx_opt = bs.clone();
            match &__hx_opt {
                Some(__v) => __v.clone(),
                None => hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access"))),
            }
        };
        let buf: crate::HxRef<hxrt::bytes::Bytes> =
            crate::HxRef::new(hxrt::bytes::Bytes::alloc(bufsize_2 as usize));
        let total: crate::HxRef<crate::haxe_io_bytes_buffer::BytesBuffer> =
            crate::haxe_io_bytes_buffer::BytesBuffer::new();
        match hxrt::exception::catch_unwind(|| loop {
            let len: i32 =
                crate::sys_io_stdin::Stdin::read_bytes(&*__hx_this, buf.clone(), 0, bufsize_2);
            if len == 0 {
                hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::Blocked));
            }
            crate::haxe_io_bytes_buffer::BytesBuffer::add_bytes(&*total, buf.clone(), 0, len);
        }) {
            Ok(__hx_ok) => __hx_ok,
            Err(__hx_ex) => match __hx_ex.downcast::<crate::HxRef<crate::haxe_io_eof::Eof>>() {
                Ok(_) => {}
                Err(__hx_ex) => hxrt::exception::rethrow(__hx_ex),
            },
        };
        return crate::haxe_io_bytes_buffer::BytesBuffer::get_bytes(&*total);
    }

    pub fn read_full_bytes(
        self_: &crate::HxRefCell<Stdin>,
        s: crate::HxRef<hxrt::bytes::Bytes>,
        pos: i32,
        len: i32,
    ) {
        let __hx_this: crate::HxRef<crate::sys_io_stdin::Stdin> = self_.self_ref();
        let mut p: i32 = pos;
        let mut l: i32 = len;
        while l > 0 {
            let k: i32 = crate::sys_io_stdin::Stdin::read_bytes(&*__hx_this, s.clone(), p, l);
            if k == 0 {
                hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::Blocked));
            }
            {
                p = p + k;
                p
            };
            {
                l = l - k;
                l
            };
        }
    }

    pub fn read(self_: &crate::HxRefCell<Stdin>, nbytes: i32) -> crate::HxRef<hxrt::bytes::Bytes> {
        let __hx_this: crate::HxRef<crate::sys_io_stdin::Stdin> = self_.self_ref();
        let mut remaining: i32 = nbytes;
        let s: crate::HxRef<hxrt::bytes::Bytes> =
            crate::HxRef::new(hxrt::bytes::Bytes::alloc(remaining as usize));
        let mut p: i32 = 0;
        while remaining > 0 {
            let k: i32 =
                crate::sys_io_stdin::Stdin::read_bytes(&*__hx_this, s.clone(), p, remaining);
            if k == 0 {
                hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::Blocked));
            }
            {
                p = p + k;
                p
            };
            {
                remaining = remaining - k;
                remaining
            };
        }
        return s;
    }

    pub fn read_until(self_: &crate::HxRefCell<Stdin>, end: i32) -> hxrt::string::HxString {
        let __hx_this: crate::HxRef<crate::sys_io_stdin::Stdin> = self_.self_ref();
        let buf: crate::HxRef<crate::haxe_io_bytes_buffer::BytesBuffer> =
            crate::haxe_io_bytes_buffer::BytesBuffer::new();
        loop {
            let last: i32 = crate::sys_io_stdin::Stdin::read_byte(&*__hx_this);
            if last == end {
                break;
            }
            crate::haxe_io_bytes_buffer::BytesBuffer::add_byte(&*buf, last);
        }
        return hxrt::string::HxString::from(
            crate::haxe_io_bytes_buffer::BytesBuffer::get_bytes(&*buf)
                .borrow()
                .to_string(),
        );
    }

    pub fn read_line(self_: &crate::HxRefCell<Stdin>) -> hxrt::string::HxString {
        let __hx_this: crate::HxRef<crate::sys_io_stdin::Stdin> = self_.self_ref();
        let buf: crate::HxRef<crate::haxe_io_bytes_buffer::BytesBuffer> =
            crate::haxe_io_bytes_buffer::BytesBuffer::new();
        match hxrt::exception::catch_unwind(|| loop {
            let last: i32 = crate::sys_io_stdin::Stdin::read_byte(&*__hx_this);
            if last == 10 {
                break;
            }
            crate::haxe_io_bytes_buffer::BytesBuffer::add_byte(&*buf, last);
        }) {
            Ok(__hx_ok) => __hx_ok,
            Err(__hx_ex) => match __hx_ex.downcast::<crate::HxRef<crate::haxe_io_eof::Eof>>() {
                Ok(__hx_box) => {
                    let e: crate::HxRef<crate::haxe_io_eof::Eof> = *__hx_box;
                    let bytes: crate::HxRef<hxrt::bytes::Bytes> =
                        crate::haxe_io_bytes_buffer::BytesBuffer::get_bytes(&*buf);
                    if bytes.borrow().length() == 0 {
                        hxrt::exception::throw(hxrt::dynamic::from(e));
                    }
                    return hxrt::string::HxString::from(bytes.borrow().to_string());
                }
                Err(__hx_ex) => hxrt::exception::rethrow(__hx_ex),
            },
        };
        let mut bytes_2: crate::HxRef<hxrt::bytes::Bytes> =
            crate::haxe_io_bytes_buffer::BytesBuffer::get_bytes(&*buf);
        let bytes_len: i32 = bytes_2.borrow().length();
        if bytes_len > 0 {
            let last_byte: i32 = bytes_2.borrow().get(bytes_len - 1);
            if last_byte == 13 {
                let trimmed: crate::HxRef<hxrt::bytes::Bytes> =
                    crate::HxRef::new(bytes_2.borrow().sub(0, bytes_len - 1));
                bytes_2 = trimmed;
            }
        }
        return hxrt::string::HxString::from(bytes_2.borrow().to_string());
    }

    pub fn read_float(self_: &crate::HxRefCell<Stdin>) -> f64 {
        let __hx_this: crate::HxRef<crate::sys_io_stdin::Stdin> = self_.self_ref();
        return crate::haxe_io_fp_helper::FPHelper::i32_to_float(
            crate::sys_io_stdin::Stdin::read_int32(&*__hx_this),
        );
    }

    pub fn read_double(self_: &crate::HxRefCell<Stdin>) -> f64 {
        let __hx_this: crate::HxRef<crate::sys_io_stdin::Stdin> = self_.self_ref();
        let i1: i32 = crate::sys_io_stdin::Stdin::read_int32(&*__hx_this);
        let i2: i32 = crate::sys_io_stdin::Stdin::read_int32(&*__hx_this);
        return if {
            let __b = __hx_this.borrow();
            __b.big_endian
        } {
            crate::haxe_io_fp_helper::FPHelper::i64_to_double(i2, i1)
        } else {
            crate::haxe_io_fp_helper::FPHelper::i64_to_double(i1, i2)
        };
    }

    pub fn read_int8(self_: &crate::HxRefCell<Stdin>) -> i32 {
        let __hx_this: crate::HxRef<crate::sys_io_stdin::Stdin> = self_.self_ref();
        let n: i32 = crate::sys_io_stdin::Stdin::read_byte(&*__hx_this);
        if n >= 128 {
            return n - 256;
        }
        return n;
    }

    pub fn read_int16(self_: &crate::HxRefCell<Stdin>) -> i32 {
        let __hx_this: crate::HxRef<crate::sys_io_stdin::Stdin> = self_.self_ref();
        let ch1: i32 = crate::sys_io_stdin::Stdin::read_byte(&*__hx_this);
        let ch2: i32 = crate::sys_io_stdin::Stdin::read_byte(&*__hx_this);
        let n: i32 = if {
            let __b = __hx_this.borrow();
            __b.big_endian
        } {
            ch1 << 8 | ch2
        } else {
            ch1 | ch2 << 8
        };
        if n >= 32768 {
            return n - 65536;
        }
        return n;
    }

    pub fn read_u_int16(self_: &crate::HxRefCell<Stdin>) -> i32 {
        let __hx_this: crate::HxRef<crate::sys_io_stdin::Stdin> = self_.self_ref();
        let ch1: i32 = crate::sys_io_stdin::Stdin::read_byte(&*__hx_this);
        let ch2: i32 = crate::sys_io_stdin::Stdin::read_byte(&*__hx_this);
        return if {
            let __b = __hx_this.borrow();
            __b.big_endian
        } {
            ch1 << 8 | ch2
        } else {
            ch1 | ch2 << 8
        };
    }

    pub fn read_int24(self_: &crate::HxRefCell<Stdin>) -> i32 {
        let __hx_this: crate::HxRef<crate::sys_io_stdin::Stdin> = self_.self_ref();
        let ch1: i32 = crate::sys_io_stdin::Stdin::read_byte(&*__hx_this);
        let ch2: i32 = crate::sys_io_stdin::Stdin::read_byte(&*__hx_this);
        let ch3: i32 = crate::sys_io_stdin::Stdin::read_byte(&*__hx_this);
        let n: i32 = if {
            let __b = __hx_this.borrow();
            __b.big_endian
        } {
            ch1 << 16 | ch2 << 8 | ch3
        } else {
            ch1 | ch2 << 8 | ch3 << 16
        };
        if n >= 8388608 {
            return n - 16777216;
        }
        return n;
    }

    pub fn read_u_int24(self_: &crate::HxRefCell<Stdin>) -> i32 {
        let __hx_this: crate::HxRef<crate::sys_io_stdin::Stdin> = self_.self_ref();
        let ch1: i32 = crate::sys_io_stdin::Stdin::read_byte(&*__hx_this);
        let ch2: i32 = crate::sys_io_stdin::Stdin::read_byte(&*__hx_this);
        let ch3: i32 = crate::sys_io_stdin::Stdin::read_byte(&*__hx_this);
        return if {
            let __b = __hx_this.borrow();
            __b.big_endian
        } {
            ch1 << 16 | ch2 << 8 | ch3
        } else {
            ch1 | ch2 << 8 | ch3 << 16
        };
    }

    pub fn read_int32(self_: &crate::HxRefCell<Stdin>) -> i32 {
        let __hx_this: crate::HxRef<crate::sys_io_stdin::Stdin> = self_.self_ref();
        let ch1: i32 = crate::sys_io_stdin::Stdin::read_byte(&*__hx_this);
        let ch2: i32 = crate::sys_io_stdin::Stdin::read_byte(&*__hx_this);
        let ch3: i32 = crate::sys_io_stdin::Stdin::read_byte(&*__hx_this);
        let ch4: i32 = crate::sys_io_stdin::Stdin::read_byte(&*__hx_this);
        return if {
            let __b = __hx_this.borrow();
            __b.big_endian
        } {
            ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24
        } else {
            ch1 | ch2 << 8 | ch3 << 16 | ch4 << 24
        };
    }

    pub fn read_string(
        self_: &crate::HxRefCell<Stdin>,
        len: i32,
        encoding: Option<crate::haxe_io_encoding::Encoding>,
    ) -> hxrt::string::HxString {
        let __hx_this: crate::HxRef<crate::sys_io_stdin::Stdin> = self_.self_ref();
        let b: crate::HxRef<hxrt::bytes::Bytes> =
            crate::HxRef::new(hxrt::bytes::Bytes::alloc(len as usize));
        crate::sys_io_stdin::Stdin::read_full_bytes(&*__hx_this, b.clone(), 0, len);
        return hxrt::string::HxString::from({
            let _ = encoding;
            b.borrow().get_string(0, len)
        });
    }
}

impl crate::haxe_io_input::InputTrait for crate::HxRefCell<Stdin> {
    fn __hx_get_big_endian(&self) -> bool {
        self.borrow().big_endian
    }
    fn __hx_set_big_endian(&self, v: bool) {
        self.borrow_mut().big_endian = v;
    }
    fn close(&self) -> () {
        Stdin::close(self)
    }
    fn read(&self, nbytes: i32) -> crate::HxRef<hxrt::bytes::Bytes> {
        Stdin::read(self, nbytes)
    }
    fn read_all(&self, bufsize: Option<i32>) -> crate::HxRef<hxrt::bytes::Bytes> {
        Stdin::read_all(self, bufsize)
    }
    fn read_byte(&self) -> i32 {
        Stdin::read_byte(self)
    }
    fn read_bytes(&self, s: crate::HxRef<hxrt::bytes::Bytes>, pos: i32, len: i32) -> i32 {
        Stdin::read_bytes(self, s, pos, len)
    }
    fn read_double(&self) -> f64 {
        Stdin::read_double(self)
    }
    fn read_float(&self) -> f64 {
        Stdin::read_float(self)
    }
    fn read_full_bytes(&self, s: crate::HxRef<hxrt::bytes::Bytes>, pos: i32, len: i32) -> () {
        Stdin::read_full_bytes(self, s, pos, len)
    }
    fn read_int16(&self) -> i32 {
        Stdin::read_int16(self)
    }
    fn read_int24(&self) -> i32 {
        Stdin::read_int24(self)
    }
    fn read_int32(&self) -> i32 {
        Stdin::read_int32(self)
    }
    fn read_int8(&self) -> i32 {
        Stdin::read_int8(self)
    }
    fn read_line(&self) -> hxrt::string::HxString {
        Stdin::read_line(self)
    }
    fn read_string(
        &self,
        len: i32,
        encoding: Option<crate::haxe_io_encoding::Encoding>,
    ) -> hxrt::string::HxString {
        Stdin::read_string(self, len, encoding)
    }
    fn read_u_int16(&self) -> i32 {
        Stdin::read_u_int16(self)
    }
    fn read_u_int24(&self) -> i32 {
        Stdin::read_u_int24(self)
    }
    fn read_until(&self, end: i32) -> hxrt::string::HxString {
        Stdin::read_until(self, end)
    }
    fn set_big_endian(&self, b: bool) -> bool {
        Stdin::set_big_endian(self, b)
    }
    fn __hx_type_id(&self) -> u32 {
        crate::sys_io_stdin::__HX_TYPE_ID
    }
}
