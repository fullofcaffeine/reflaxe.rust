// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0x03be022du32;

#[derive(Debug)]

pub struct ResultTools {}

impl ResultTools {
    pub fn is_ok<T: Clone, E: Clone>(r: Result<T, E>) -> bool {
        return match r.clone() {
            Result::Ok(__p) => {
                let _g: T = __p;
                true
            }
            Result::Err(__p) => {
                let _g_2: E = __p;
                false
            }
        };
    }

    pub fn is_err<T: Clone, E: Clone>(r: Result<T, E>) -> bool {
        return !(match r.clone() {
            Result::Ok(__p) => {
                let _g: T = __p;
                true
            }
            Result::Err(__p) => {
                let _g_2: E = __p;
                false
            }
        });
    }

    pub fn unwrap_or<T: Clone, E: Clone>(r: Result<T, E>, fallback: T) -> T {
        return match r.clone() {
            Result::Ok(__p) => {
                let _g: T = __p;
                {
                    let v: T = _g;
                    v
                }
            }
            Result::Err(__p) => {
                let _g_2: E = __p;
                fallback
            }
        };
    }

    pub fn unwrap<T: Clone, E: Clone + std::fmt::Debug>(r: Result<T, E>) -> T {
        return match r.clone() {
            Result::Ok(__p) => {
                let _g: T = __p;
                {
                    let v: T = _g;
                    v
                }
            }
            Result::Err(__p) => {
                let _g_2: E = __p;
                {
                    let e: E = _g_2;
                    hxrt::exception::throw(hxrt::dynamic::from(format!(
                        "{}{}",
                        "called Result.unwrap() on Err: ",
                        format!("{:?}", e)
                    )));
                }
            }
        };
    }

    pub fn expect<T: Clone, E: Clone + std::fmt::Debug>(r: Result<T, E>, message: String) -> T {
        return match r.clone() {
            Result::Ok(__p) => {
                let _g: T = __p;
                {
                    let v: T = _g;
                    v
                }
            }
            Result::Err(__p) => {
                let _g_2: E = __p;
                {
                    let e: E = _g_2;
                    hxrt::exception::throw(hxrt::dynamic::from(format!(
                        "{}{}{}",
                        &message,
                        ": ",
                        format!("{:?}", e)
                    )));
                }
            }
        };
    }

    pub fn context<T: Clone>(r: Result<T, String>, prefix: String) -> Result<T, String> {
        return match r.clone() {
            Result::Ok(__p) => {
                let _g: T = __p;
                {
                    let v: T = _g;
                    Result::Ok(v.clone())
                }
            }
            Result::Err(__p) => {
                let _g_2: String = __p;
                {
                    let e: String = _g_2;
                    Result::Err(format!("{}{}{}", &prefix, ": ", &e))
                }
            }
        };
    }
}
