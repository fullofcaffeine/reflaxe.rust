// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0xd7e07825u32;

#[derive(Debug)]

pub struct ObjectMap<
    K: hxrt::hxref::HxRefLike + Clone + Send + Sync + 'static + std::fmt::Debug,
    V: Clone + Send + Sync + 'static + std::fmt::Debug,
> {
    keys_map: std::collections::HashMap<String, K>,
    values_map: std::collections::HashMap<String, V>,
}

impl<
        K: hxrt::hxref::HxRefLike + Clone + Send + Sync + 'static + std::fmt::Debug,
        V: Clone + Send + Sync + 'static + std::fmt::Debug,
    > ObjectMap<K, V>
{
    pub fn new() -> crate::HxRef<crate::haxe_ds_object_map::ObjectMap<K, V>> {
        let self_: crate::HxRef<crate::haxe_ds_object_map::ObjectMap<K, V>> =
            crate::HxRef::new(ObjectMap {
                keys_map: std::collections::HashMap::<String, K>::new(),
                values_map: std::collections::HashMap::<String, V>::new(),
            });
        return self_;
    }

    fn key_id(_self_: &crate::HxRefCell<ObjectMap<K, V>>, key: K) -> String {
        return hxrt::hxref::ptr_id(&key);
    }

    pub fn set(self_: &crate::HxRefCell<ObjectMap<K, V>>, key: K, value: V) {
        let __hx_this: crate::HxRef<crate::haxe_ds_object_map::ObjectMap<K, V>> = self_.self_ref();
        let id: String = hxrt::hxref::ptr_id(&key);
        {
            let mut __s = __hx_this.borrow_mut();
            __s.keys_map.insert(id.clone(), key);
            __s.values_map.insert(id, value);
        };
    }

    pub fn get(self_: &crate::HxRefCell<ObjectMap<K, V>>, key: K) -> Option<V> {
        let __hx_this: crate::HxRef<crate::haxe_ds_object_map::ObjectMap<K, V>> = self_.self_ref();
        let id: String = hxrt::hxref::ptr_id(&key);
        return __hx_this.borrow().values_map.get(&id).cloned();
    }

    pub fn exists(self_: &crate::HxRefCell<ObjectMap<K, V>>, key: K) -> bool {
        let __hx_this: crate::HxRef<crate::haxe_ds_object_map::ObjectMap<K, V>> = self_.self_ref();
        let id: String = hxrt::hxref::ptr_id(&key);
        return __hx_this.borrow().values_map.contains_key(&id);
    }

    pub fn remove(self_: &crate::HxRefCell<ObjectMap<K, V>>, key: K) -> bool {
        let __hx_this: crate::HxRef<crate::haxe_ds_object_map::ObjectMap<K, V>> = self_.self_ref();
        let id: String = hxrt::hxref::ptr_id(&key);
        return {
            let mut __s = __hx_this.borrow_mut();
            let __existed = __s.values_map.remove(&id).is_some();
            __s.keys_map.remove(&id);
            __existed
        };
    }

    pub fn keys(self_: &crate::HxRefCell<ObjectMap<K, V>>) -> hxrt::iter::Iter<K> {
        let __hx_this: crate::HxRef<crate::haxe_ds_object_map::ObjectMap<K, V>> = self_.self_ref();
        return hxrt::iter::Iter::from_vec(
            __hx_this
                .borrow()
                .keys_map
                .values()
                .cloned()
                .collect::<Vec<_>>(),
        );
    }

    pub fn iterator(self_: &crate::HxRefCell<ObjectMap<K, V>>) -> hxrt::iter::Iter<V> {
        let __hx_this: crate::HxRef<crate::haxe_ds_object_map::ObjectMap<K, V>> = self_.self_ref();
        return hxrt::iter::Iter::from_vec(
            __hx_this
                .borrow()
                .values_map
                .values()
                .cloned()
                .collect::<Vec<_>>(),
        );
    }

    pub fn key_value_iterator(
        self_: &crate::HxRefCell<ObjectMap<K, V>>,
    ) -> hxrt::iter::Iter<hxrt::iter::KeyValue<K, V>> {
        let __hx_this: crate::HxRef<crate::haxe_ds_object_map::ObjectMap<K, V>> = self_.self_ref();
        return hxrt::iter::Iter::from_vec({
            let __s = __hx_this.borrow();
            __s.values_map
                .iter()
                .map(|(id, v)| hxrt::iter::KeyValue {
                    key: __s.keys_map.get(id).unwrap().clone(),
                    value: v.clone(),
                })
                .collect::<Vec<_>>()
        });
    }

    pub fn copy(
        self_: &crate::HxRefCell<ObjectMap<K, V>>,
    ) -> crate::HxRef<crate::haxe_ds_object_map::ObjectMap<K, V>> {
        let __hx_this: crate::HxRef<crate::haxe_ds_object_map::ObjectMap<K, V>> = self_.self_ref();
        let out: crate::HxRef<crate::haxe_ds_object_map::ObjectMap<K, V>> =
            crate::haxe_ds_object_map::ObjectMap::<K, V>::new();
        {
            let __s = __hx_this.borrow();
            let mut __o = out.borrow_mut();
            __o.keys_map = __s.keys_map.clone();
            __o.values_map = __s.values_map.clone();
        };
        return out;
    }

    pub fn to_string(self_: &crate::HxRefCell<ObjectMap<K, V>>) -> String {
        let __hx_this: crate::HxRef<crate::haxe_ds_object_map::ObjectMap<K, V>> = self_.self_ref();
        return format!("{:?}", __hx_this.borrow().values_map);
    }

    pub fn clear(self_: &crate::HxRefCell<ObjectMap<K, V>>) {
        let __hx_this: crate::HxRef<crate::haxe_ds_object_map::ObjectMap<K, V>> = self_.self_ref();
        {
            let mut __s = __hx_this.borrow_mut();
            __s.keys_map.clear();
            __s.values_map.clear();
        };
    }
}

impl<
        K: hxrt::hxref::HxRefLike + Clone + Send + Sync + 'static + std::fmt::Debug,
        V: Clone + Send + Sync + 'static + std::fmt::Debug,
    > crate::haxe_i_map::IMap<K, V> for crate::HxRefCell<ObjectMap<K, V>>
{
    fn get(&self, k: K) -> Option<V> {
        ObjectMap::<K, V>::get(self, k)
    }
    fn set(&self, k: K, v: V) -> () {
        ObjectMap::<K, V>::set(self, k, v)
    }
    fn exists(&self, k: K) -> bool {
        ObjectMap::<K, V>::exists(self, k)
    }
    fn remove(&self, k: K) -> bool {
        ObjectMap::<K, V>::remove(self, k)
    }
    fn keys(&self) -> hxrt::iter::Iter<K> {
        ObjectMap::<K, V>::keys(self)
    }
    fn iterator(&self) -> hxrt::iter::Iter<V> {
        ObjectMap::<K, V>::iterator(self)
    }
    fn key_value_iterator(&self) -> hxrt::iter::Iter<hxrt::iter::KeyValue<K, V>> {
        ObjectMap::<K, V>::key_value_iterator(self)
    }
    fn copy(&self) -> crate::HxRc<dyn crate::haxe_i_map::IMap<K, V> + Send + Sync> {
        let __tmp = ObjectMap::<K, V>::copy(self);
        let __up: crate::HxRc<dyn crate::haxe_i_map::IMap<K, V> + Send + Sync> =
            match __tmp.as_arc_opt() {
                Some(__rc) => __rc.clone(),
                None => hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access"))),
            };
        __up
    }
    fn to_string(&self) -> String {
        ObjectMap::<K, V>::to_string(self)
    }
    fn clear(&self) -> () {
        ObjectMap::<K, V>::clear(self)
    }
    fn __hx_type_id(&self) -> u32 {
        crate::haxe_ds_object_map::__HX_TYPE_ID
    }
}
