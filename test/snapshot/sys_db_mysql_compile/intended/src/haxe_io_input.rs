// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0xd50291cbu32;

#[derive(Debug)]

pub struct Input {
    pub big_endian: bool,
}

impl Input {
    pub fn read_byte(_self_: &crate::HxRefCell<Input>) -> i32 {
        hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::Custom(
            hxrt::dynamic::from(String::from("Input.readByte is not implemented")),
        )));
    }

    pub fn read_bytes(
        self_: &crate::HxRefCell<Input>,
        s: crate::HxRef<hxrt::bytes::Bytes>,
        pos: i32,
        len: i32,
    ) -> i32 {
        let __hx_this: crate::HxRef<crate::haxe_io_input::Input> = self_.self_ref();
        let mut k: i32 = len;
        let mut p: i32 = pos;
        if p < 0 || len < 0 || p + len > s.borrow().length() {
            hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::OutsideBounds));
        }
        match hxrt::exception::catch_unwind(|| {
            while k > 0 {
                s.borrow_mut()
                    .set(p, crate::haxe_io_input::Input::read_byte(&*__hx_this));
                {
                    let __tmp = p;
                    p = p + 1;
                    __tmp
                };
                {
                    let __tmp = k;
                    k = k - 1;
                    __tmp
                };
            }
        }) {
            Ok(__hx_ok) => __hx_ok,
            Err(__hx_ex) => match __hx_ex.downcast::<crate::HxRef<crate::haxe_io_eof::Eof>>() {
                Ok(_) => {}
                Err(__hx_ex) => hxrt::exception::rethrow(__hx_ex),
            },
        };
        return len - k;
    }

    pub fn close(_self_: &crate::HxRefCell<Input>) {}

    pub fn set_big_endian(self_: &crate::HxRefCell<Input>, b: bool) -> bool {
        let __hx_this: crate::HxRef<crate::haxe_io_input::Input> = self_.self_ref();
        {
            let __tmp = b;
            __hx_this.borrow_mut().big_endian = __tmp;
            __tmp
        };
        return b;
    }

    pub fn read_all(
        self_: &crate::HxRefCell<Input>,
        bufsize: Option<i32>,
    ) -> crate::HxRef<hxrt::bytes::Bytes> {
        let __hx_this: crate::HxRef<crate::haxe_io_input::Input> = self_.self_ref();
        let mut bs: Option<i32> = bufsize;
        if bs.is_none() {
            {
                let __tmp = 16384;
                bs = Some(__tmp);
                __tmp
            };
        }
        let bufsize_2: i32 = {
            let __hx_opt = bs.clone();
            match &__hx_opt {
                Some(__v) => __v.clone(),
                None => hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access"))),
            }
        };
        let buf: crate::HxRef<hxrt::bytes::Bytes> =
            crate::HxRef::new(hxrt::bytes::Bytes::alloc(bufsize_2 as usize));
        let total: crate::HxRef<crate::haxe_io_bytes_buffer::BytesBuffer> =
            crate::haxe_io_bytes_buffer::BytesBuffer::new();
        match hxrt::exception::catch_unwind(|| loop {
            let len: i32 =
                crate::haxe_io_input::Input::read_bytes(&*__hx_this, buf.clone(), 0, bufsize_2);
            if len == 0 {
                hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::Blocked));
            }
            crate::haxe_io_bytes_buffer::BytesBuffer::add_bytes(&*total, buf.clone(), 0, len);
        }) {
            Ok(__hx_ok) => __hx_ok,
            Err(__hx_ex) => match __hx_ex.downcast::<crate::HxRef<crate::haxe_io_eof::Eof>>() {
                Ok(_) => {}
                Err(__hx_ex) => hxrt::exception::rethrow(__hx_ex),
            },
        };
        return crate::haxe_io_bytes_buffer::BytesBuffer::get_bytes(&*total);
    }

    pub fn read_full_bytes(
        self_: &crate::HxRefCell<Input>,
        s: crate::HxRef<hxrt::bytes::Bytes>,
        pos: i32,
        len: i32,
    ) {
        let __hx_this: crate::HxRef<crate::haxe_io_input::Input> = self_.self_ref();
        let mut p: i32 = pos;
        let mut l: i32 = len;
        while l > 0 {
            let k: i32 = crate::haxe_io_input::Input::read_bytes(&*__hx_this, s.clone(), p, l);
            if k == 0 {
                hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::Blocked));
            }
            {
                p = p + k;
                p
            };
            {
                l = l - k;
                l
            };
        }
    }

    pub fn read(self_: &crate::HxRefCell<Input>, nbytes: i32) -> crate::HxRef<hxrt::bytes::Bytes> {
        let __hx_this: crate::HxRef<crate::haxe_io_input::Input> = self_.self_ref();
        let mut remaining: i32 = nbytes;
        let s: crate::HxRef<hxrt::bytes::Bytes> =
            crate::HxRef::new(hxrt::bytes::Bytes::alloc(remaining as usize));
        let mut p: i32 = 0;
        while remaining > 0 {
            let k: i32 =
                crate::haxe_io_input::Input::read_bytes(&*__hx_this, s.clone(), p, remaining);
            if k == 0 {
                hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::Blocked));
            }
            {
                p = p + k;
                p
            };
            {
                remaining = remaining - k;
                remaining
            };
        }
        return s;
    }

    pub fn read_until(self_: &crate::HxRefCell<Input>, end: i32) -> String {
        let __hx_this: crate::HxRef<crate::haxe_io_input::Input> = self_.self_ref();
        let buf: crate::HxRef<crate::haxe_io_bytes_buffer::BytesBuffer> =
            crate::haxe_io_bytes_buffer::BytesBuffer::new();
        loop {
            let last: i32 = crate::haxe_io_input::Input::read_byte(&*__hx_this);
            if last == end {
                break;
            }
            crate::haxe_io_bytes_buffer::BytesBuffer::add_byte(&*buf, last);
        }
        return crate::haxe_io_bytes_buffer::BytesBuffer::get_bytes(&*buf)
            .borrow()
            .to_string();
    }

    pub fn read_line(self_: &crate::HxRefCell<Input>) -> String {
        let __hx_this: crate::HxRef<crate::haxe_io_input::Input> = self_.self_ref();
        let buf: crate::HxRef<crate::haxe_io_bytes_buffer::BytesBuffer> =
            crate::haxe_io_bytes_buffer::BytesBuffer::new();
        match hxrt::exception::catch_unwind(|| loop {
            let last: i32 = crate::haxe_io_input::Input::read_byte(&*__hx_this);
            if last == 10 {
                break;
            }
            crate::haxe_io_bytes_buffer::BytesBuffer::add_byte(&*buf, last);
        }) {
            Ok(__hx_ok) => __hx_ok,
            Err(__hx_ex) => match __hx_ex.downcast::<crate::HxRef<crate::haxe_io_eof::Eof>>() {
                Ok(__hx_box) => {
                    let e: crate::HxRef<crate::haxe_io_eof::Eof> = *__hx_box;
                    let bytes: crate::HxRef<hxrt::bytes::Bytes> =
                        crate::haxe_io_bytes_buffer::BytesBuffer::get_bytes(&*buf);
                    if bytes.borrow().length() == 0 {
                        hxrt::exception::throw(hxrt::dynamic::from(e));
                    }
                    return bytes.borrow().to_string();
                }
                Err(__hx_ex) => hxrt::exception::rethrow(__hx_ex),
            },
        };
        let mut bytes_2: crate::HxRef<hxrt::bytes::Bytes> =
            crate::haxe_io_bytes_buffer::BytesBuffer::get_bytes(&*buf);
        let bytes_len: i32 = bytes_2.borrow().length();
        if bytes_len > 0 {
            let last_byte: i32 = bytes_2.borrow().get(bytes_len - 1);
            if last_byte == 13 {
                let trimmed: crate::HxRef<hxrt::bytes::Bytes> =
                    crate::HxRef::new(bytes_2.borrow().sub(0, bytes_len - 1));
                bytes_2 = trimmed;
            }
        }
        return bytes_2.borrow().to_string();
    }

    pub fn read_float(self_: &crate::HxRefCell<Input>) -> f64 {
        let __hx_this: crate::HxRef<crate::haxe_io_input::Input> = self_.self_ref();
        return crate::haxe_io_fp_helper::FPHelper::i32_to_float(
            crate::haxe_io_input::Input::read_int32(&*__hx_this),
        );
    }

    pub fn read_double(self_: &crate::HxRefCell<Input>) -> f64 {
        let __hx_this: crate::HxRef<crate::haxe_io_input::Input> = self_.self_ref();
        let i1: i32 = crate::haxe_io_input::Input::read_int32(&*__hx_this);
        let i2: i32 = crate::haxe_io_input::Input::read_int32(&*__hx_this);
        return if {
            let __b = __hx_this.borrow();
            __b.big_endian
        } {
            crate::haxe_io_fp_helper::FPHelper::i64_to_double(i2, i1)
        } else {
            crate::haxe_io_fp_helper::FPHelper::i64_to_double(i1, i2)
        };
    }

    pub fn read_int8(self_: &crate::HxRefCell<Input>) -> i32 {
        let __hx_this: crate::HxRef<crate::haxe_io_input::Input> = self_.self_ref();
        let n: i32 = crate::haxe_io_input::Input::read_byte(&*__hx_this);
        if n >= 128 {
            return n - 256;
        }
        return n;
    }

    pub fn read_int16(self_: &crate::HxRefCell<Input>) -> i32 {
        let __hx_this: crate::HxRef<crate::haxe_io_input::Input> = self_.self_ref();
        let ch1: i32 = crate::haxe_io_input::Input::read_byte(&*__hx_this);
        let ch2: i32 = crate::haxe_io_input::Input::read_byte(&*__hx_this);
        let n: i32 = if {
            let __b = __hx_this.borrow();
            __b.big_endian
        } {
            ch1 << 8 | ch2
        } else {
            ch1 | ch2 << 8
        };
        if n >= 32768 {
            return n - 65536;
        }
        return n;
    }

    pub fn read_u_int16(self_: &crate::HxRefCell<Input>) -> i32 {
        let __hx_this: crate::HxRef<crate::haxe_io_input::Input> = self_.self_ref();
        let ch1: i32 = crate::haxe_io_input::Input::read_byte(&*__hx_this);
        let ch2: i32 = crate::haxe_io_input::Input::read_byte(&*__hx_this);
        return if {
            let __b = __hx_this.borrow();
            __b.big_endian
        } {
            ch1 << 8 | ch2
        } else {
            ch1 | ch2 << 8
        };
    }

    pub fn read_int24(self_: &crate::HxRefCell<Input>) -> i32 {
        let __hx_this: crate::HxRef<crate::haxe_io_input::Input> = self_.self_ref();
        let ch1: i32 = crate::haxe_io_input::Input::read_byte(&*__hx_this);
        let ch2: i32 = crate::haxe_io_input::Input::read_byte(&*__hx_this);
        let ch3: i32 = crate::haxe_io_input::Input::read_byte(&*__hx_this);
        let n: i32 = if {
            let __b = __hx_this.borrow();
            __b.big_endian
        } {
            ch1 << 16 | ch2 << 8 | ch3
        } else {
            ch1 | ch2 << 8 | ch3 << 16
        };
        if n >= 8388608 {
            return n - 16777216;
        }
        return n;
    }

    pub fn read_u_int24(self_: &crate::HxRefCell<Input>) -> i32 {
        let __hx_this: crate::HxRef<crate::haxe_io_input::Input> = self_.self_ref();
        let ch1: i32 = crate::haxe_io_input::Input::read_byte(&*__hx_this);
        let ch2: i32 = crate::haxe_io_input::Input::read_byte(&*__hx_this);
        let ch3: i32 = crate::haxe_io_input::Input::read_byte(&*__hx_this);
        return if {
            let __b = __hx_this.borrow();
            __b.big_endian
        } {
            ch1 << 16 | ch2 << 8 | ch3
        } else {
            ch1 | ch2 << 8 | ch3 << 16
        };
    }

    pub fn read_int32(self_: &crate::HxRefCell<Input>) -> i32 {
        let __hx_this: crate::HxRef<crate::haxe_io_input::Input> = self_.self_ref();
        let ch1: i32 = crate::haxe_io_input::Input::read_byte(&*__hx_this);
        let ch2: i32 = crate::haxe_io_input::Input::read_byte(&*__hx_this);
        let ch3: i32 = crate::haxe_io_input::Input::read_byte(&*__hx_this);
        let ch4: i32 = crate::haxe_io_input::Input::read_byte(&*__hx_this);
        return if {
            let __b = __hx_this.borrow();
            __b.big_endian
        } {
            ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24
        } else {
            ch1 | ch2 << 8 | ch3 << 16 | ch4 << 24
        };
    }

    pub fn read_string(
        self_: &crate::HxRefCell<Input>,
        len: i32,
        encoding: Option<crate::haxe_io_encoding::Encoding>,
    ) -> String {
        let __hx_this: crate::HxRef<crate::haxe_io_input::Input> = self_.self_ref();
        let b: crate::HxRef<hxrt::bytes::Bytes> =
            crate::HxRef::new(hxrt::bytes::Bytes::alloc(len as usize));
        crate::haxe_io_input::Input::read_full_bytes(&*__hx_this, b.clone(), 0, len);
        return {
            let _ = encoding;
            b.borrow().get_string(0, len)
        };
    }
}

pub trait InputTrait: Send + Sync {
    fn __hx_get_big_endian(&self) -> bool;
    fn __hx_set_big_endian(&self, v: bool);
    fn read_byte(&self) -> i32;
    fn read_bytes(&self, s: crate::HxRef<hxrt::bytes::Bytes>, pos: i32, len: i32) -> i32;
    fn close(&self) -> ();
    fn set_big_endian(&self, b: bool) -> bool;
    fn read_all(&self, bufsize: Option<i32>) -> crate::HxRef<hxrt::bytes::Bytes>;
    fn read_full_bytes(&self, s: crate::HxRef<hxrt::bytes::Bytes>, pos: i32, len: i32) -> ();
    fn read(&self, nbytes: i32) -> crate::HxRef<hxrt::bytes::Bytes>;
    fn read_until(&self, end: i32) -> String;
    fn read_line(&self) -> String;
    fn read_float(&self) -> f64;
    fn read_double(&self) -> f64;
    fn read_int8(&self) -> i32;
    fn read_int16(&self) -> i32;
    fn read_u_int16(&self) -> i32;
    fn read_int24(&self) -> i32;
    fn read_u_int24(&self) -> i32;
    fn read_int32(&self) -> i32;
    fn read_string(&self, len: i32, encoding: Option<crate::haxe_io_encoding::Encoding>) -> String;
    fn __hx_type_id(&self) -> u32;
}

impl crate::haxe_io_input::InputTrait for crate::HxRefCell<Input> {
    fn __hx_get_big_endian(&self) -> bool {
        self.borrow().big_endian
    }
    fn __hx_set_big_endian(&self, v: bool) {
        self.borrow_mut().big_endian = v;
    }
    fn read_byte(&self) -> i32 {
        Input::read_byte(self)
    }
    fn read_bytes(&self, s: crate::HxRef<hxrt::bytes::Bytes>, pos: i32, len: i32) -> i32 {
        Input::read_bytes(self, s, pos, len)
    }
    fn close(&self) -> () {
        Input::close(self)
    }
    fn set_big_endian(&self, b: bool) -> bool {
        Input::set_big_endian(self, b)
    }
    fn read_all(&self, bufsize: Option<i32>) -> crate::HxRef<hxrt::bytes::Bytes> {
        Input::read_all(self, bufsize)
    }
    fn read_full_bytes(&self, s: crate::HxRef<hxrt::bytes::Bytes>, pos: i32, len: i32) -> () {
        Input::read_full_bytes(self, s, pos, len)
    }
    fn read(&self, nbytes: i32) -> crate::HxRef<hxrt::bytes::Bytes> {
        Input::read(self, nbytes)
    }
    fn read_until(&self, end: i32) -> String {
        Input::read_until(self, end)
    }
    fn read_line(&self) -> String {
        Input::read_line(self)
    }
    fn read_float(&self) -> f64 {
        Input::read_float(self)
    }
    fn read_double(&self) -> f64 {
        Input::read_double(self)
    }
    fn read_int8(&self) -> i32 {
        Input::read_int8(self)
    }
    fn read_int16(&self) -> i32 {
        Input::read_int16(self)
    }
    fn read_u_int16(&self) -> i32 {
        Input::read_u_int16(self)
    }
    fn read_int24(&self) -> i32 {
        Input::read_int24(self)
    }
    fn read_u_int24(&self) -> i32 {
        Input::read_u_int24(self)
    }
    fn read_int32(&self) -> i32 {
        Input::read_int32(self)
    }
    fn read_string(&self, len: i32, encoding: Option<crate::haxe_io_encoding::Encoding>) -> String {
        Input::read_string(self, len, encoding)
    }
    fn __hx_type_id(&self) -> u32 {
        crate::haxe_io_input::__HX_TYPE_ID
    }
}
