// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0xe52d85f9u32;

#[derive(Debug)]

pub struct MysqlConnection {
    handle: hxrt::dynamic::Dynamic,
}

impl MysqlConnection {
    pub fn new(
        params: crate::HxRef<hxrt::anon::Anon>,
    ) -> crate::HxRef<crate::sys_db_mysql_mysql_connection::MysqlConnection> {
        let self_: crate::HxRef<crate::sys_db_mysql_mysql_connection::MysqlConnection> =
            crate::HxRc::new(crate::HxRefCell::new(MysqlConnection {
                handle: hxrt::dynamic::Dynamic::null(),
            }));
        let port: i32 = if params.borrow().get::<Option<i32>>("port").is_none() {
            3306
        } else {
            params.borrow().get::<Option<i32>>("port").unwrap()
        };
        {
            let __tmp = {
                let socket = params.borrow().get::<Option<String>>("socket");
                let db_name = params.borrow().get::<Option<String>>("database");
                let mut b = mysql::OptsBuilder::new()
                    .ip_or_hostname(Some(params.borrow().get::<String>("host").as_str()))
                    .user(Some(params.borrow().get::<String>("user").as_str()))
                    .pass(Some(params.borrow().get::<String>("pass").as_str()))
                    .tcp_port(port as u16);
                if let Some(s) = socket.as_ref() {
                    b = b.socket(Some(s.as_str()));
                }
                if let Some(db) = db_name.as_ref() {
                    b = b.db_name(Some(db.as_str()));
                }

                let conn = mysql::Conn::new(b).unwrap_or_else(|e| {
                    hxrt::exception::throw(hxrt::dynamic::from(format!("Mysql.connect: {e}")))
                });
                hxrt::dynamic::from(std::sync::Arc::new(std::sync::Mutex::new(Some(conn))))
            };
            self_.borrow_mut().handle = __tmp.clone();
            __tmp
        };
        return self_;
    }

    pub fn close(self_: &crate::HxRefCell<MysqlConnection>) {
        {
            let hdyn = self_.borrow().handle.clone();
            let h = hdyn
                .downcast_ref::<std::sync::Arc<std::sync::Mutex<Option<mysql::Conn>>>>()
                .unwrap_or_else(|| {
                    hxrt::exception::throw(hxrt::dynamic::from(
                        "Mysql.close: invalid handle".to_string(),
                    ))
                });
            let mut g = h.lock().unwrap();
            let _ = g.take();
        };
    }

    pub fn request(
        self_: &crate::HxRefCell<MysqlConnection>,
        sql: String,
    ) -> crate::HxRc<dyn crate::sys_db_result_set::ResultSet + Send + Sync> {
        let res: crate::HxRef<hxrt::db::QueryResult> = {
            use mysql::prelude::*;
            use mysql::Value;

            let hdyn = self_.borrow().handle.clone();
            let h = hdyn
                .downcast_ref::<std::sync::Arc<std::sync::Mutex<Option<mysql::Conn>>>>()
                .unwrap_or_else(|| {
                    hxrt::exception::throw(hxrt::dynamic::from(
                        "Mysql.request: invalid handle".to_string(),
                    ))
                });
            let mut g = h.lock().unwrap();
            let conn = g.as_mut().unwrap_or_else(|| {
                hxrt::exception::throw(hxrt::dynamic::from(
                    "Mysql.request: connection closed".to_string(),
                ))
            });

            let mut q = conn.query_iter(sql.as_str()).unwrap_or_else(|e| {
                hxrt::exception::throw(hxrt::dynamic::from(format!("Mysql.request: {e}")))
            });

            let cols = q.columns();
            let names_vec: Vec<String> = cols
                .as_ref()
                .iter()
                .map(|c| c.name_str().to_string())
                .collect();
            let names = hxrt::array::Array::<String>::from_vec(names_vec);

            let mut rows_out: Vec<hxrt::array::Array<hxrt::dynamic::Dynamic>> = Vec::new();
            for row_res in q.by_ref() {
                let row = row_res.unwrap_or_else(|e| {
                    hxrt::exception::throw(hxrt::dynamic::from(format!("Mysql.request: {e}")))
                });
                let mut vals: Vec<hxrt::dynamic::Dynamic> = Vec::new();
                for v in row.unwrap().into_iter() {
                    let d = match v {
                        Value::NULL => hxrt::dynamic::Dynamic::null(),
                        Value::Int(x) => {
                            let y: i32 = (x.clamp(i32::MIN as i64, i32::MAX as i64)) as i32;
                            hxrt::dynamic::from(y)
                        }
                        Value::UInt(x) => {
                            let y: i32 = (x.min(i32::MAX as u64)) as i32;
                            hxrt::dynamic::from(y)
                        }
                        Value::Float(x) => hxrt::dynamic::from(x as f64),
                        Value::Double(x) => hxrt::dynamic::from(x),
                        Value::Bytes(b) => match String::from_utf8(b.clone()) {
                            Ok(s) => hxrt::dynamic::from(s),
                            Err(_) => {
                                let bytes = hxrt::bytes::Bytes::from_vec(b);
                                let href = hxrt::cell::HxRc::new(hxrt::cell::HxCell::new(bytes));
                                hxrt::dynamic::from(href)
                            }
                        },
                        Value::Date(y, m, d, hh, mm, ss, micros) => {
                            let s =
                                format!("{y:04}-{m:02}-{d:02} {hh:02}:{mm:02}:{ss:02}.{micros:06}");
                            hxrt::dynamic::from(s)
                        }
                        Value::Time(neg, days, hh, mm, ss, micros) => {
                            let sign = if neg { "-" } else { "" };
                            let s = format!("{sign}{days}:{hh:02}:{mm:02}:{ss:02}.{micros:06}");
                            hxrt::dynamic::from(s)
                        }
                    };
                    vals.push(d);
                }
                rows_out.push(hxrt::array::Array::<hxrt::dynamic::Dynamic>::from_vec(vals));
            }

            let rows_arr =
                hxrt::array::Array::<hxrt::array::Array<hxrt::dynamic::Dynamic>>::from_vec(
                    rows_out,
                );
            hxrt::db::query_result_new(names, rows_arr)
        };
        return crate::sys_db_mysql_mysql_result_set::MysqlResultSet::new(res.clone());
    }

    pub fn escape(_self_: &crate::HxRefCell<MysqlConnection>, s: String) -> String {
        return hxrt::string::split(
            hxrt::string::split(s.as_str(), String::from("\\").as_str())
                .join(String::from("\\\\"))
                .as_str(),
            String::from("'").as_str(),
        )
        .join(String::from("\\'"));
    }

    pub fn quote(self_: &crate::HxRefCell<MysqlConnection>, s: String) -> String {
        return format!(
            "{}{}{}",
            "'",
            crate::sys_db_mysql_mysql_connection::MysqlConnection::escape(&self_, s),
            "'"
        );
    }

    pub fn add_value(
        _self_: &crate::HxRefCell<MysqlConnection>,
        sb: crate::HxRef<crate::string_buf::StringBuf>,
        v: hxrt::dynamic::Dynamic,
    ) {
        let rendered: String = {
            let v = v;
            let out: String = if v.is_null() {
                String::from("NULL")
            } else if let Some(x) = v.downcast_ref::<i32>() {
                x.to_string()
            } else if let Some(x) = v.downcast_ref::<f64>() {
                x.to_string()
            } else if let Some(x) = v.downcast_ref::<bool>() {
                if *x {
                    "1".to_string()
                } else {
                    "0".to_string()
                }
            } else if let Some(b) = v.downcast_ref::<hxrt::cell::HxRef<hxrt::bytes::Bytes>>() {
                // Bytes: x'ABCD...'
                let data = b.borrow();
                let slice = data.as_slice();
                let mut s = String::with_capacity(2 + slice.len() * 2 + 1);
                s.push_str("x'");
                const HEX: &[u8; 16] = b"0123456789ABCDEF";
                for byte in slice {
                    s.push(HEX[(byte >> 4) as usize] as char);
                    s.push(HEX[(byte & 0xF) as usize] as char);
                }
                s.push_str("'");
                s
            } else {
                // Strings (and everything else): quote + MySQL-ish escaping.
                let s = if let Some(s) = v.downcast_ref::<String>() {
                    s.clone()
                } else {
                    v.to_haxe_string()
                };
                let escaped = s.replace("\\", "\\\\").replace("'", "\\'");
                format!("'{}'", escaped)
            };
            out
        };
        crate::string_buf::StringBuf::add(&sb, hxrt::dynamic::from(rendered.clone()));
    }

    pub fn last_insert_id(self_: &crate::HxRefCell<MysqlConnection>) -> i32 {
        return crate::sys_db_mysql_mysql_connection::MysqlConnection::request(
            &self_,
            String::from("SELECT LAST_INSERT_ID()"),
        )
        .get_int_result(0);
    }

    pub fn db_name(_self_: &crate::HxRefCell<MysqlConnection>) -> String {
        return String::from("MySQL");
    }

    pub fn start_transaction(self_: &crate::HxRefCell<MysqlConnection>) {
        crate::sys_db_mysql_mysql_connection::MysqlConnection::request(
            &self_,
            String::from("START TRANSACTION"),
        );
    }

    pub fn commit(self_: &crate::HxRefCell<MysqlConnection>) {
        crate::sys_db_mysql_mysql_connection::MysqlConnection::request(
            &self_,
            String::from("COMMIT"),
        );
    }

    pub fn rollback(self_: &crate::HxRefCell<MysqlConnection>) {
        crate::sys_db_mysql_mysql_connection::MysqlConnection::request(
            &self_,
            String::from("ROLLBACK"),
        );
    }
}

impl crate::sys_db_connection::Connection for crate::HxRefCell<MysqlConnection> {
    fn request(
        &self,
        s: String,
    ) -> crate::HxRc<dyn crate::sys_db_result_set::ResultSet + Send + Sync> {
        MysqlConnection::request(self, s)
    }
    fn close(&self) -> () {
        MysqlConnection::close(self)
    }
    fn escape(&self, s: String) -> String {
        MysqlConnection::escape(self, s)
    }
    fn quote(&self, s: String) -> String {
        MysqlConnection::quote(self, s)
    }
    fn add_value(
        &self,
        s: crate::HxRef<crate::string_buf::StringBuf>,
        v: hxrt::dynamic::Dynamic,
    ) -> () {
        MysqlConnection::add_value(self, s, v)
    }
    fn last_insert_id(&self) -> i32 {
        MysqlConnection::last_insert_id(self)
    }
    fn db_name(&self) -> String {
        MysqlConnection::db_name(self)
    }
    fn start_transaction(&self) -> () {
        MysqlConnection::start_transaction(self)
    }
    fn commit(&self) -> () {
        MysqlConnection::commit(self)
    }
    fn rollback(&self) -> () {
        MysqlConnection::rollback(self)
    }
}
