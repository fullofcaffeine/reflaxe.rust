// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0x181f937bu32;

#[derive(Debug)]

pub struct StringMap<T: Clone + Send + Sync + 'static + std::fmt::Debug> {
    h: std::collections::HashMap<hxrt::string::HxString, T>,
}

impl<T: Clone + Send + Sync + 'static + std::fmt::Debug> StringMap<T> {
    pub fn new() -> crate::HxRef<crate::haxe_ds_string_map::StringMap<T>> {
        let self_: crate::HxRef<crate::haxe_ds_string_map::StringMap<T>> =
            crate::HxRef::new(StringMap {
                h: std::collections::HashMap::<hxrt::string::HxString, T>::new(),
            });
        return self_;
    }

    pub fn set(self_: &crate::HxRefCell<StringMap<T>>, key: hxrt::string::HxString, value: T) {
        let __hx_this: crate::HxRef<crate::haxe_ds_string_map::StringMap<T>> = self_.self_ref();
        __hx_this.borrow_mut().h.insert(key, value);
    }

    pub fn get(self_: &crate::HxRefCell<StringMap<T>>, key: hxrt::string::HxString) -> Option<T> {
        let __hx_this: crate::HxRef<crate::haxe_ds_string_map::StringMap<T>> = self_.self_ref();
        return __hx_this.borrow().h.get(&key).cloned();
    }

    pub fn exists(self_: &crate::HxRefCell<StringMap<T>>, key: hxrt::string::HxString) -> bool {
        let __hx_this: crate::HxRef<crate::haxe_ds_string_map::StringMap<T>> = self_.self_ref();
        return __hx_this.borrow().h.contains_key(&key);
    }

    pub fn remove(self_: &crate::HxRefCell<StringMap<T>>, key: hxrt::string::HxString) -> bool {
        let __hx_this: crate::HxRef<crate::haxe_ds_string_map::StringMap<T>> = self_.self_ref();
        return __hx_this.borrow_mut().h.remove(&key).is_some();
    }

    pub fn keys(
        self_: &crate::HxRefCell<StringMap<T>>,
    ) -> hxrt::iter::Iter<hxrt::string::HxString> {
        let __hx_this: crate::HxRef<crate::haxe_ds_string_map::StringMap<T>> = self_.self_ref();
        return hxrt::iter::Iter::from_vec(
            __hx_this.borrow().h.keys().cloned().collect::<Vec<_>>(),
        );
    }

    pub fn iterator(self_: &crate::HxRefCell<StringMap<T>>) -> hxrt::iter::Iter<T> {
        let __hx_this: crate::HxRef<crate::haxe_ds_string_map::StringMap<T>> = self_.self_ref();
        return hxrt::iter::Iter::from_vec(
            __hx_this.borrow().h.values().cloned().collect::<Vec<_>>(),
        );
    }

    pub fn key_value_iterator(
        self_: &crate::HxRefCell<StringMap<T>>,
    ) -> hxrt::iter::Iter<hxrt::iter::KeyValue<hxrt::string::HxString, T>> {
        let __hx_this: crate::HxRef<crate::haxe_ds_string_map::StringMap<T>> = self_.self_ref();
        return hxrt::iter::Iter::from_vec(
            __hx_this
                .borrow()
                .h
                .iter()
                .map(|(k, v)| hxrt::iter::KeyValue {
                    key: k.clone(),
                    value: v.clone(),
                })
                .collect::<Vec<_>>(),
        );
    }

    pub fn copy(
        self_: &crate::HxRefCell<StringMap<T>>,
    ) -> crate::HxRef<crate::haxe_ds_string_map::StringMap<T>> {
        let __hx_this: crate::HxRef<crate::haxe_ds_string_map::StringMap<T>> = self_.self_ref();
        let out: crate::HxRef<crate::haxe_ds_string_map::StringMap<T>> =
            crate::haxe_ds_string_map::StringMap::<T>::new();
        out.borrow_mut().h = __hx_this.borrow().h.clone();
        return out;
    }

    pub fn to_string(self_: &crate::HxRefCell<StringMap<T>>) -> hxrt::string::HxString {
        let __hx_this: crate::HxRef<crate::haxe_ds_string_map::StringMap<T>> = self_.self_ref();
        return hxrt::string::HxString::from(format!("{:?}", __hx_this.borrow().h));
    }

    pub fn clear(self_: &crate::HxRefCell<StringMap<T>>) {
        let __hx_this: crate::HxRef<crate::haxe_ds_string_map::StringMap<T>> = self_.self_ref();
        __hx_this.borrow_mut().h.clear();
    }
}

impl<T: Clone + Send + Sync + 'static + std::fmt::Debug>
    crate::haxe_i_map::IMap<hxrt::string::HxString, T> for crate::HxRefCell<StringMap<T>>
{
    fn get(&self, k: hxrt::string::HxString) -> Option<T> {
        StringMap::<T>::get(self, k)
    }
    fn set(&self, k: hxrt::string::HxString, v: T) -> () {
        StringMap::<T>::set(self, k, v)
    }
    fn exists(&self, k: hxrt::string::HxString) -> bool {
        StringMap::<T>::exists(self, k)
    }
    fn remove(&self, k: hxrt::string::HxString) -> bool {
        StringMap::<T>::remove(self, k)
    }
    fn keys(&self) -> hxrt::iter::Iter<hxrt::string::HxString> {
        StringMap::<T>::keys(self)
    }
    fn iterator(&self) -> hxrt::iter::Iter<T> {
        StringMap::<T>::iterator(self)
    }
    fn key_value_iterator(
        &self,
    ) -> hxrt::iter::Iter<hxrt::iter::KeyValue<hxrt::string::HxString, T>> {
        StringMap::<T>::key_value_iterator(self)
    }
    fn copy(
        &self,
    ) -> crate::HxRc<dyn crate::haxe_i_map::IMap<hxrt::string::HxString, T> + Send + Sync> {
        let __tmp = StringMap::<T>::copy(self);
        let __up: crate::HxRc<
            dyn crate::haxe_i_map::IMap<hxrt::string::HxString, T> + Send + Sync,
        > = match __tmp.as_arc_opt() {
            Some(__rc) => __rc.clone(),
            None => hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access"))),
        };
        __up
    }
    fn to_string(&self) -> hxrt::string::HxString {
        StringMap::<T>::to_string(self)
    }
    fn clear(&self) -> () {
        StringMap::<T>::clear(self)
    }
}
