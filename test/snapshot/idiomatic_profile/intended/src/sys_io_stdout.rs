// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0x9402c169u32;

#[derive(Debug)]

pub struct Stdout {
    pub big_endian: bool,
}

impl Stdout {
    pub fn new() -> crate::HxRef<crate::sys_io_stdout::Stdout> {
        let self_: crate::HxRef<crate::sys_io_stdout::Stdout> =
            crate::HxRc::new(crate::HxRefCell::new(Stdout { big_endian: false }));
        return self_;
    }

    pub fn write_byte(_self_: &crate::HxRefCell<Stdout>, c: i32) {
        {
            use std::io::Write;
            std::io::stdout().write_all(&[(c & 0xFF) as u8]).unwrap();
        };
    }

    pub fn write_bytes(
        _self_: &crate::HxRefCell<Stdout>,
        s: crate::HxRef<hxrt::bytes::Bytes>,
        pos: i32,
        len: i32,
    ) -> i32 {
        if pos < 0 || len < 0 || pos + len > s.borrow().length() {
            hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::OutsideBounds));
        }
        if len == 0 {
            return 0;
        }
        return {
            use std::io::Write;
            let b = s.borrow();
            let data = b.as_slice();
            let start = pos as usize;
            let end = (pos + len) as usize;
            std::io::stdout().write_all(&data[start..end]).unwrap();
            len as i32
        };
    }

    pub fn flush(_self_: &crate::HxRefCell<Stdout>) {
        {
            use std::io::Write;
            std::io::stdout().flush().ok();
        };
    }
}

impl crate::haxe_io_output::OutputTrait for crate::HxRefCell<Stdout> {
    fn __hx_get_big_endian(&self) -> bool {
        self.borrow().big_endian
    }
    fn __hx_set_big_endian(&self, v: bool) {
        self.borrow_mut().big_endian = v;
    }
    fn write_byte(&self, _c: i32) -> () {
        Stdout::write_byte(self, _c)
    }
    fn write_bytes(&self, s: crate::HxRef<hxrt::bytes::Bytes>, pos: i32, len: i32) -> i32 {
        Stdout::write_bytes(self, s, pos, len)
    }
    fn flush(&self) -> () {
        Stdout::flush(self)
    }
    fn close(&self) -> () {
        todo!()
    }
    fn set_big_endian(&self, _: bool) -> bool {
        todo!()
    }
    fn write(&self, _: crate::HxRef<hxrt::bytes::Bytes>) -> () {
        todo!()
    }
    fn write_full_bytes(&self, _: crate::HxRef<hxrt::bytes::Bytes>, _: i32, _: i32) -> () {
        todo!()
    }
    fn write_float(&self, _: f64) -> () {
        todo!()
    }
    fn write_double(&self, _: f64) -> () {
        todo!()
    }
    fn write_int8(&self, _: i32) -> () {
        todo!()
    }
    fn write_int16(&self, _: i32) -> () {
        todo!()
    }
    fn write_u_int16(&self, _: i32) -> () {
        todo!()
    }
    fn write_int24(&self, _: i32) -> () {
        todo!()
    }
    fn write_u_int24(&self, _: i32) -> () {
        todo!()
    }
    fn write_int32(&self, _: i32) -> () {
        todo!()
    }
    fn prepare(&self, _: i32) -> () {
        todo!()
    }
    fn write_input(
        &self,
        _: crate::HxRc<dyn crate::haxe_io_input::InputTrait>,
        _: Option<i32>,
    ) -> () {
        todo!()
    }
    fn write_string(&self, _: String, _: Option<crate::haxe_io_encoding::Encoding>) -> () {
        todo!()
    }
    fn __hx_type_id(&self) -> u32 {
        crate::sys_io_stdout::__HX_TYPE_ID
    }
}
