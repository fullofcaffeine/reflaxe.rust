// Generated by reflaxe.rust (POC)

#![allow(dead_code)]
#![allow(type_alias_bounds)]

type HxRc<T> = hxrt::cell::HxRc<T>;
type HxDynRef<T: ?Sized> = hxrt::cell::HxDynRef<T>;
type HxRefCell<T> = hxrt::cell::HxCell<T>;
type HxRef<T> = hxrt::cell::HxRef<T>;

mod date;
mod haxe_call_stack_call_stack_impl_;
mod haxe_crypto_base64;
mod haxe_crypto_base_code;
mod haxe_crypto_sha256;
mod haxe_ds_enum_value_map;
mod haxe_ds_int_map;
mod haxe_ds_list;
mod haxe_ds_object_map;
mod haxe_ds_string_map;
mod haxe_exception;
mod haxe_i_map;
mod haxe_int64_int64;
mod haxe_int64_int64_impl_;
mod haxe_io_bytes_buffer;
mod haxe_io_encoding;
mod haxe_io_eof;
mod haxe_io_fp_helper;
mod haxe_io_input;
mod haxe_io_output;
mod haxe_iterators_string_iterator;
mod haxe_iterators_string_key_value_iterator;
mod haxe_json;
mod haxe_json_value;
mod haxe_serializer;
mod haxe_stack_item;
mod haxe_unserializer;
mod haxe_unserializer_default_resolver;
mod string_buf;
mod string_tools;
mod sys;
mod sys_io_stderr;
mod sys_io_stdin;
mod sys_io_stdout;
mod value_type;

/// Runtime subtype check for stable Haxe class type ids.
///
/// Generated by reflaxe.rust from the emitted class inheritance graph.
#[inline]
pub(crate) fn __hx_is_subtype_type_id(actual: u32, expected: u32) -> bool {
    if actual == expected {
        return true;
    }
    match actual {
        0x0cd85f36u32 => matches!(expected, 0x44f4c432u32),
        0x39e0cd5bu32 => matches!(expected, 0x44f4c432u32),
        0xd7e07825u32 => matches!(expected, 0x44f4c432u32),
        0x181f937bu32 => matches!(expected, 0x44f4c432u32),
        0x163b1f5au32 => matches!(expected, 0xe82620b4u32),
        0xfb16179cu32 => matches!(expected, 0xd50291cbu32),
        0x9402c169u32 => matches!(expected, 0xe82620b4u32),
        _ => false,
    }
}

fn main() {
    crate::sys::Sys::println(hxrt::dynamic::from(hxrt::string::HxString::from(format!(
        "{}{}",
        "sha256=",
        crate::haxe_crypto_sha256::Sha256::encode(hxrt::string::HxString::from(
            hxrt::string::HxString::from("hello")
        ))
    ))));
    let b: crate::HxRef<hxrt::bytes::Bytes> = crate::HxRef::new(hxrt::bytes::Bytes::of_string(
        hxrt::string::HxString::from("hi").as_str(),
    ));
    crate::sys::Sys::println(hxrt::dynamic::from(hxrt::string::HxString::from(format!(
        "{}{}",
        "b64=",
        crate::haxe_crypto_base64::Base64::encode(b.clone(), true)
    ))));
    let obj: crate::HxRef<hxrt::anon::Anon> = {
        let __o = crate::HxRef::new(hxrt::anon::Anon::new());
        {
            let mut __b = __o.borrow_mut();
            __b.set("a", 1);
            __b.set("b", hxrt::string::HxString::from("x"));
        };
        __o
    };
    let json: hxrt::string::HxString =
        hxrt::string::HxString::from(crate::haxe_json::Json::stringify(
            hxrt::dynamic::from_ref(obj.clone()),
            crate::HxDynRef::<
                dyn Fn(hxrt::dynamic::Dynamic, hxrt::dynamic::Dynamic) -> hxrt::dynamic::Dynamic
                    + Send
                    + Sync,
            >::null(),
            hxrt::string::HxString::from(hxrt::string::HxString::null()),
        ));
    crate::sys::Sys::println(hxrt::dynamic::from(hxrt::string::HxString::from(format!(
        "{}{}",
        "json=", &json
    ))));
    let parsed: crate::haxe_json_value::Value =
        crate::haxe_json::Json::parse_value(hxrt::string::HxString::from(json.clone()));
    let parsed_a: i32 = if (match parsed.clone() {
        crate::haxe_json_value::Value::JString(__p) => 3,
        crate::haxe_json_value::Value::JObject(__p0, __p1) => 4,
        crate::haxe_json_value::Value::JNumber(__p) => 2,
        crate::haxe_json_value::Value::JNull => 0,
        crate::haxe_json_value::Value::JBool(__p) => 1,
        crate::haxe_json_value::Value::JArray(__p) => 5,
    }) == 4
    {
        let _g: hxrt::array::Array<hxrt::string::HxString> = match parsed.clone() {
            crate::haxe_json_value::Value::JObject(__p, _) => __p,
            _ => unreachable!(),
        };
        let _g1: hxrt::array::Array<crate::haxe_json_value::Value> = match parsed.clone() {
            crate::haxe_json_value::Value::JObject(_, __p) => __p,
            _ => unreachable!(),
        };
        {
            let keys: hxrt::array::Array<hxrt::string::HxString> = _g;
            let values: hxrt::array::Array<crate::haxe_json_value::Value> = _g1;
            {
                let mut out: i32 = -1;
                let mut i: i32 = 0;
                while i < (keys.len() as i32) {
                    if keys.get_unchecked(i as usize) == hxrt::string::HxString::from("a") {
                        out = {
                            let _g_2: crate::haxe_json_value::Value =
                                values.get_unchecked(i as usize);
                            if (match _g_2.clone() {
                                crate::haxe_json_value::Value::JString(__p) => 3,
                                crate::haxe_json_value::Value::JObject(__p0, __p1) => 4,
                                crate::haxe_json_value::Value::JNumber(__p) => 2,
                                crate::haxe_json_value::Value::JNull => 0,
                                crate::haxe_json_value::Value::JBool(__p) => 1,
                                crate::haxe_json_value::Value::JArray(__p) => 5,
                            }) == 2
                            {
                                let _g_3: f64 = match _g_2.clone() {
                                    crate::haxe_json_value::Value::JNumber(__p) => __p,
                                    _ => unreachable!(),
                                };
                                {
                                    let n: f64 = _g_3;
                                    n as i32
                                }
                            } else {
                                -1
                            }
                        };
                        break;
                    }
                    i = i + 1;
                }
                out
            }
        }
    } else {
        -1
    };
    crate::sys::Sys::println(hxrt::dynamic::from(hxrt::string::HxString::from(format!(
        "{}{}",
        "parsed.a=",
        hxrt::dynamic::from(parsed_a).to_haxe_string()
    ))));
    let ser: hxrt::string::HxString = hxrt::string::HxString::from(
        crate::haxe_serializer::Serializer::run(hxrt::dynamic::from_ref(obj.clone())),
    );
    crate::sys::Sys::println(hxrt::dynamic::from(hxrt::string::HxString::from(format!(
        "{}{}",
        "ser=", &ser
    ))));
    let unser: crate::HxRef<hxrt::anon::Anon> = {
        let __hx_dyn =
            crate::haxe_unserializer::Unserializer::run(hxrt::string::HxString::from(ser.clone()));
        if __hx_dyn.is_null() {
            hxrt::exception::throw(hxrt::dynamic::from(String::from("Null Access")))
        } else {
            __hx_dyn
                .downcast_ref::<crate::HxRef<hxrt::anon::Anon>>()
                .unwrap()
                .clone()
        }
    };
    crate::sys::Sys::println(hxrt::dynamic::from(hxrt::string::HxString::from(format!(
        "{}{}",
        "unser.b=",
        unser.borrow().get::<hxrt::string::HxString>("b")
    ))));
}
