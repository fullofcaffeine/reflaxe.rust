// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0x70f28bdfu32;

#[derive(Debug)]

pub struct StringTools {}

impl StringTools {
    pub fn url_encode(s: String) -> String {
        return {
            let bytes = s.as_bytes();
            let mut out = String::new();
            for &b in bytes {
                match b {
                    b'A'..=b'Z' | b'a'..=b'z' | b'0'..=b'9' | b'-' | b'_' | b'.' | b'~' => {
                        out.push(b as char)
                    }
                    b' ' => out.push_str("%20"),
                    _ => out.push_str(&format!("%{:02X}", b)),
                }
            }
            out
        };
    }

    pub fn url_decode(s: String) -> String {
        return {
            fn hex_val(b: u8) -> Option<u8> {
                match b {
                    b'0'..=b'9' => Some(b - b'0'),
                    b'a'..=b'f' => Some(b - b'a' + 10),
                    b'A'..=b'F' => Some(b - b'A' + 10),
                    _ => None,
                }
            }

            let input = s.replace("+", " ");
            let bytes = input.as_bytes();
            let mut out: Vec<u8> = Vec::with_capacity(bytes.len());

            let mut i: usize = 0;
            while i < bytes.len() {
                if bytes[i] == b'%' && i + 2 < bytes.len() {
                    let h1 = hex_val(bytes[i + 1]);
                    let h2 = hex_val(bytes[i + 2]);
                    if let (Some(a), Some(b)) = (h1, h2) {
                        out.push((a << 4) | b);
                        i += 3;
                        continue;
                    }
                }
                out.push(bytes[i]);
                i += 1;
            }

            String::from_utf8(out.clone())
                .unwrap_or_else(|_| String::from_utf8_lossy(&out).to_string())
        };
    }

    pub fn contains(s: String, value: String) -> bool {
        return hxrt::string::index_of(s.as_str(), value.as_str(), None) != -1;
    }

    pub fn starts_with(s: String, start: String) -> bool {
        return s.starts_with(start.as_str());
    }

    pub fn ends_with(s: String, end: String) -> bool {
        return s.ends_with(end.as_str());
    }

    pub fn is_space(s: String, pos: i32) -> bool {
        if hxrt::string::len(s.as_str()) == 0 || pos < 0 || pos >= hxrt::string::len(s.as_str()) {
            return false;
        }
        let c: i32 = crate::string_tools::StringTools::fast_code_at(s.clone(), pos);
        return c > 8 && c < 14 || c == 32;
    }

    pub fn ltrim(s: String) -> String {
        let l: i32 = hxrt::string::len(s.as_str());
        let mut r: i32 = 0;
        while r < l && crate::string_tools::StringTools::is_space(s.clone(), r) {
            {
                let __tmp = r;
                r = r + 1;
                __tmp
            };
        }
        return if r > 0 {
            hxrt::string::substr(s.as_str(), r, Some(l - r))
        } else {
            s
        };
    }

    pub fn rtrim(s: String) -> String {
        let l: i32 = hxrt::string::len(s.as_str());
        let mut r: i32 = 0;
        while r < l && crate::string_tools::StringTools::is_space(s.clone(), l - r - 1) {
            {
                let __tmp = r;
                r = r + 1;
                __tmp
            };
        }
        return if r > 0 {
            hxrt::string::substr(s.as_str(), 0, Some(l - r))
        } else {
            s
        };
    }

    pub fn trim(s: String) -> String {
        return crate::string_tools::StringTools::ltrim(crate::string_tools::StringTools::rtrim(s));
    }

    pub fn lpad(s: String, c: String, l: i32) -> String {
        if hxrt::string::len(c.as_str()) <= 0 {
            return s;
        }
        let pad_len: i32 = l - hxrt::string::len(s.as_str());
        if pad_len <= 0 {
            return s;
        }
        return {
            let mut buf = String::new();
            let mut cur: i32 = 0;
            while cur < pad_len {
                buf.push_str(c.as_str());
                cur = hxrt::string::len(buf.as_str());
            }
            format!("{}{}", buf, s)
        };
    }

    pub fn rpad(s: String, c: String, l: i32) -> String {
        if hxrt::string::len(c.as_str()) <= 0 {
            return s;
        }
        if l <= hxrt::string::len(s.as_str()) {
            return s;
        }
        let pad_len: i32 = l - hxrt::string::len(s.as_str());
        return {
            let mut buf = String::new();
            let mut cur: i32 = 0;
            while cur < pad_len {
                buf.push_str(c.as_str());
                cur = hxrt::string::len(buf.as_str());
            }
            format!("{}{}", s, buf)
        };
    }

    pub fn replace(s: String, sub: String, by: String) -> String {
        return s.replace(sub.as_str(), by.as_str());
    }

    pub fn hex(n: i32, digits: Option<i32>) -> String {
        return {
            let mut s = format!("{:X}", n as u32);
            let d: i32 = digits.unwrap_or(0);
            while d != 0 && (hxrt::string::len(s.as_str()) < d) {
                s = format!("0{}", s);
            }
            s
        };
    }

    pub fn fast_code_at(s: String, index: i32) -> i32 {
        return s
            .chars()
            .nth(index as usize)
            .map(|c| c as i32)
            .unwrap_or(-1);
    }

    pub fn unsafe_code_at(s: String, index: i32) -> i32 {
        return crate::string_tools::StringTools::fast_code_at(s, index);
    }

    pub fn is_eof(c: i32) -> bool {
        return c == -1;
    }

    pub fn iterator(
        s: String,
    ) -> crate::HxRef<crate::haxe_iterators_string_iterator::StringIterator> {
        return crate::haxe_iterators_string_iterator::StringIterator::new(s);
    }

    pub fn key_value_iterator(
        s: String,
    ) -> crate::HxRef<crate::haxe_iterators_string_key_value_iterator::StringKeyValueIterator> {
        return crate::haxe_iterators_string_key_value_iterator::StringKeyValueIterator::new(s);
    }

    fn utf16_code_point_at(s: String, index: i32) -> i32 {
        let mut c: i32 = crate::string_tools::StringTools::fast_code_at(s.clone(), index);
        if c >= 55296 && c <= 56319 {
            c = c - 55232 << 10
                | crate::string_tools::StringTools::fast_code_at(s.clone(), index + 1) & 1023;
        }
        return c;
    }
}
