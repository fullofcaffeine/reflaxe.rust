// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0x70f28bdfu32;

#[derive(Debug)]

pub struct StringTools {}

impl StringTools {
    pub fn url_encode(s: hxrt::string::HxString) -> hxrt::string::HxString {
        return hxrt::string::HxString::from({
            let bytes = s.as_bytes();
            let mut out = String::new();
            for &b in bytes {
                match b {
                    b'A'..=b'Z' | b'a'..=b'z' | b'0'..=b'9' | b'-' | b'_' | b'.' | b'~' => {
                        out.push(b as char)
                    }
                    b' ' => out.push_str("%20"),
                    _ => out.push_str(&format!("%{:02X}", b)),
                }
            }
            out
        });
    }

    pub fn url_decode(s: hxrt::string::HxString) -> hxrt::string::HxString {
        return hxrt::string::HxString::from({
            fn hex_val(b: u8) -> Option<u8> {
                match b {
                    b'0'..=b'9' => Some(b - b'0'),
                    b'a'..=b'f' => Some(b - b'a' + 10),
                    b'A'..=b'F' => Some(b - b'A' + 10),
                    _ => None,
                }
            }

            let input = s.replace("+", " ");
            let bytes = input.as_bytes();
            let mut out: Vec<u8> = Vec::with_capacity(bytes.len());

            let mut i: usize = 0;
            while i < bytes.len() {
                if bytes[i] == b'%' && i + 2 < bytes.len() {
                    let h1 = hex_val(bytes[i + 1]);
                    let h2 = hex_val(bytes[i + 2]);
                    if let (Some(a), Some(b)) = (h1, h2) {
                        out.push((a << 4) | b);
                        i += 3;
                        continue;
                    }
                }
                out.push(bytes[i]);
                i += 1;
            }

            String::from_utf8(out.clone())
                .unwrap_or_else(|_| String::from_utf8_lossy(&out).to_string())
        });
    }

    pub fn contains(s: hxrt::string::HxString, value: hxrt::string::HxString) -> bool {
        return hxrt::string::index_of(
            s.as_str(),
            hxrt::string::HxString::from(value).as_str(),
            None,
        ) != -1;
    }

    pub fn starts_with(s: hxrt::string::HxString, start: hxrt::string::HxString) -> bool {
        return s.starts_with(start.as_str());
    }

    pub fn ends_with(s: hxrt::string::HxString, end: hxrt::string::HxString) -> bool {
        return s.ends_with(end.as_str());
    }

    pub fn is_space(s: hxrt::string::HxString, pos: i32) -> bool {
        if hxrt::string::len(s.as_str()) == 0 || pos < 0 || pos >= hxrt::string::len(s.as_str()) {
            return false;
        }
        let c: i32 = crate::string_tools::StringTools::fast_code_at(
            hxrt::string::HxString::from(s.clone()),
            pos,
        );
        return c > 8 && c < 14 || c == 32;
    }

    pub fn ltrim(s: hxrt::string::HxString) -> hxrt::string::HxString {
        let l: i32 = hxrt::string::len(s.as_str());
        let mut r: i32 = 0;
        while r < l
            && crate::string_tools::StringTools::is_space(
                hxrt::string::HxString::from(s.clone()),
                r,
            )
        {
            {
                let __tmp = r;
                r = r + 1;
                __tmp
            };
        }
        return hxrt::string::HxString::from(if r > 0 {
            hxrt::string::HxString::from(hxrt::string::substr(s.as_str(), r, Some(l - r)))
        } else {
            s
        });
    }

    pub fn rtrim(s: hxrt::string::HxString) -> hxrt::string::HxString {
        let l: i32 = hxrt::string::len(s.as_str());
        let mut r: i32 = 0;
        while r < l
            && crate::string_tools::StringTools::is_space(
                hxrt::string::HxString::from(s.clone()),
                l - r - 1,
            )
        {
            {
                let __tmp = r;
                r = r + 1;
                __tmp
            };
        }
        return hxrt::string::HxString::from(if r > 0 {
            hxrt::string::HxString::from(hxrt::string::substr(s.as_str(), 0, Some(l - r)))
        } else {
            s
        });
    }

    pub fn trim(s: hxrt::string::HxString) -> hxrt::string::HxString {
        return hxrt::string::HxString::from(crate::string_tools::StringTools::ltrim(
            hxrt::string::HxString::from(crate::string_tools::StringTools::rtrim(
                hxrt::string::HxString::from(s),
            )),
        ));
    }

    pub fn lpad(
        s: hxrt::string::HxString,
        c: hxrt::string::HxString,
        l: i32,
    ) -> hxrt::string::HxString {
        if hxrt::string::len(c.as_str()) <= 0 {
            return hxrt::string::HxString::from(s);
        }
        let pad_len: i32 = l - hxrt::string::len(s.as_str());
        if pad_len <= 0 {
            return hxrt::string::HxString::from(s);
        }
        return hxrt::string::HxString::from({
            let mut buf = String::new();
            let mut cur: i32 = 0;
            while cur < pad_len {
                buf.push_str(c.as_str());
                cur = hxrt::string::len(buf.as_str());
            }
            format!("{}{}", buf, s)
        });
    }

    pub fn rpad(
        s: hxrt::string::HxString,
        c: hxrt::string::HxString,
        l: i32,
    ) -> hxrt::string::HxString {
        if hxrt::string::len(c.as_str()) <= 0 {
            return hxrt::string::HxString::from(s);
        }
        if l <= hxrt::string::len(s.as_str()) {
            return hxrt::string::HxString::from(s);
        }
        let pad_len: i32 = l - hxrt::string::len(s.as_str());
        return hxrt::string::HxString::from({
            let mut buf = String::new();
            let mut cur: i32 = 0;
            while cur < pad_len {
                buf.push_str(c.as_str());
                cur = hxrt::string::len(buf.as_str());
            }
            format!("{}{}", s, buf)
        });
    }

    pub fn replace(
        s: hxrt::string::HxString,
        sub: hxrt::string::HxString,
        by: hxrt::string::HxString,
    ) -> hxrt::string::HxString {
        return hxrt::string::HxString::from(s.replace(sub.as_str(), by.as_str()));
    }

    pub fn hex(n: i32, digits: Option<i32>) -> hxrt::string::HxString {
        return hxrt::string::HxString::from({
            let mut s = format!("{:X}", n as u32);
            let d: i32 = digits.unwrap_or(0);
            while d != 0 && (hxrt::string::len(s.as_str()) < d) {
                s = format!("0{}", s);
            }
            s
        });
    }

    pub fn fast_code_at(s: hxrt::string::HxString, index: i32) -> i32 {
        return s
            .chars()
            .nth(index as usize)
            .map(|c| c as i32)
            .unwrap_or(-1);
    }

    pub fn unsafe_code_at(s: hxrt::string::HxString, index: i32) -> i32 {
        return crate::string_tools::StringTools::fast_code_at(
            hxrt::string::HxString::from(s),
            index,
        );
    }

    pub fn is_eof(c: i32) -> bool {
        return c == -1;
    }

    pub fn iterator(
        s: hxrt::string::HxString,
    ) -> crate::HxRef<crate::haxe_iterators_string_iterator::StringIterator> {
        return crate::haxe_iterators_string_iterator::StringIterator::new(
            hxrt::string::HxString::from(s),
        );
    }

    pub fn key_value_iterator(
        s: hxrt::string::HxString,
    ) -> crate::HxRef<crate::haxe_iterators_string_key_value_iterator::StringKeyValueIterator> {
        return crate::haxe_iterators_string_key_value_iterator::StringKeyValueIterator::new(
            hxrt::string::HxString::from(s),
        );
    }

    fn utf16_code_point_at(s: hxrt::string::HxString, index: i32) -> i32 {
        let mut c: i32 = crate::string_tools::StringTools::fast_code_at(
            hxrt::string::HxString::from(s.clone()),
            index,
        );
        if c >= 55296 && c <= 56319 {
            c = c - 55232 << 10
                | crate::string_tools::StringTools::fast_code_at(
                    hxrt::string::HxString::from(s.clone()),
                    index + 1,
                ) & 1023;
        }
        return c;
    }
}
