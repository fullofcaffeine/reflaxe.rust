// Generated by reflaxe.rust (POC)

static __HX_STATIC_CHARS: std::sync::OnceLock<hxrt::cell::HxCell<hxrt::string::HxString>> =
    std::sync::OnceLock::new();
fn __hx_static_cell_chars() -> &'static hxrt::cell::HxCell<hxrt::string::HxString> {
    __HX_STATIC_CHARS.get_or_init(|| {
        hxrt::cell::HxCell::new(hxrt::string::HxString::from(hxrt::string::HxString::from(
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        )))
    })
}
pub(crate) fn __hx_static_get_chars() -> hxrt::string::HxString {
    __hx_static_cell_chars().borrow().clone()
}
pub(crate) fn __hx_static_set_chars(value: hxrt::string::HxString) {
    *__hx_static_cell_chars().borrow_mut() = value;
}

static __HX_STATIC_BYTES: std::sync::OnceLock<
    hxrt::cell::HxCell<crate::HxRef<hxrt::bytes::Bytes>>,
> = std::sync::OnceLock::new();
fn __hx_static_cell_bytes() -> &'static hxrt::cell::HxCell<crate::HxRef<hxrt::bytes::Bytes>> {
    __HX_STATIC_BYTES.get_or_init(|| {
        hxrt::cell::HxCell::new(crate::HxRef::new(hxrt::bytes::Bytes::of_string(
            crate::haxe_crypto_base64::__hx_static_get_chars().as_str(),
        )))
    })
}
pub(crate) fn __hx_static_get_bytes() -> crate::HxRef<hxrt::bytes::Bytes> {
    __hx_static_cell_bytes().borrow().clone()
}
pub(crate) fn __hx_static_set_bytes(value: crate::HxRef<hxrt::bytes::Bytes>) {
    *__hx_static_cell_bytes().borrow_mut() = value;
}

pub const __HX_TYPE_ID: u32 = 0x7122cdcdu32;

#[derive(Debug)]

pub struct Base64 {}

impl Base64 {
    pub fn encode(
        bytes: crate::HxRef<hxrt::bytes::Bytes>,
        complement: bool,
    ) -> hxrt::string::HxString {
        let mut str: hxrt::string::HxString = hxrt::string::HxString::from(
            crate::haxe_crypto_base_code::BaseCode::encode_bytes(
                &*crate::haxe_crypto_base_code::BaseCode::new(
                    crate::haxe_crypto_base64::__hx_static_get_bytes(),
                ),
                bytes.clone(),
            )
            .borrow()
            .to_string(),
        );
        if complement {
            {
                let _g: i32 = bytes.borrow().length() % 3;
                match _g {
                    1 => {
                        let __tmp = hxrt::string::HxString::from("==");
                        str = hxrt::string::HxString::from(format!("{}{}", str, __tmp));
                    }
                    2 => {
                        let __tmp = hxrt::string::HxString::from("=");
                        str = hxrt::string::HxString::from(format!("{}{}", str, __tmp));
                    }
                    _ => {}
                }
            }
        }
        return hxrt::string::HxString::from(str);
    }
}
