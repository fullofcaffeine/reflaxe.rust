// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0x8584eeaeu32;

#[derive(Debug)]

pub struct BaseCode {
    base: crate::HxRef<hxrt::bytes::Bytes>,
    nbits: i32,
}

impl BaseCode {
    pub fn new(
        base: crate::HxRef<hxrt::bytes::Bytes>,
    ) -> crate::HxRef<crate::haxe_crypto_base_code::BaseCode> {
        let self_: crate::HxRef<crate::haxe_crypto_base_code::BaseCode> =
            crate::HxRef::new(BaseCode {
                base: Default::default(),
                nbits: 0,
            });
        let len: i32 = base.borrow().length();
        let mut nbits: i32 = 1;
        while len > 1 << nbits {
            {
                let __tmp = nbits;
                nbits = nbits + 1;
                __tmp
            };
        }
        if nbits > 8 || len != 1 << nbits {
            hxrt::exception::throw(hxrt::dynamic::from(hxrt::string::HxString::from(
                "BaseCode : base length must be a power of two.",
            )));
        }
        {
            let __tmp = base.clone();
            self_.borrow_mut().base = __tmp.clone();
            __tmp
        };
        {
            let __tmp = nbits;
            self_.borrow_mut().nbits = __tmp;
            __tmp
        };
        return self_;
    }

    pub fn encode_bytes(
        self_: &crate::HxRefCell<BaseCode>,
        b: crate::HxRef<hxrt::bytes::Bytes>,
    ) -> crate::HxRef<hxrt::bytes::Bytes> {
        let __hx_this: crate::HxRef<crate::haxe_crypto_base_code::BaseCode> = self_.self_ref();
        let nbits: i32 = {
            let __b = __hx_this.borrow();
            __b.nbits
        };
        let base: crate::HxRef<hxrt::bytes::Bytes> = {
            let __b = __hx_this.borrow();
            __b.base.clone()
        };
        let size: i32 = ((b.borrow().length() * 8) as f64 / nbits as f64) as i32;
        let out: crate::HxRef<hxrt::bytes::Bytes> = crate::HxRef::new(hxrt::bytes::Bytes::alloc(
            (size
                + (if b.borrow().length() * 8 % nbits == 0 {
                    0
                } else {
                    1
                })) as usize,
        ));
        let mut buf: i32 = 0;
        let mut curbits: i32 = 0;
        let mask: i32 = (1 << nbits) - 1;
        let mut pin: i32 = 0;
        let mut pout: i32 = 0;
        while pout < size {
            while curbits < nbits {
                {
                    curbits = curbits + 8;
                    curbits
                };
                {
                    buf = buf << 8;
                    buf
                };
                {
                    buf = buf
                        | b.borrow().get({
                            let __tmp = pin;
                            pin = pin + 1;
                            __tmp
                        });
                    buf
                };
            }
            {
                curbits = curbits - nbits;
                curbits
            };
            out.borrow_mut().set(
                {
                    let __tmp = pout;
                    pout = pout + 1;
                    __tmp
                },
                base.borrow().get(buf >> curbits & mask),
            );
        }
        if curbits > 0 {
            out.borrow_mut().set(
                {
                    let __tmp = pout;
                    pout = pout + 1;
                    __tmp
                },
                base.borrow().get(buf << nbits - curbits & mask),
            );
        }
        return out;
    }
}
