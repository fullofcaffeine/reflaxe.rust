// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0x71215cbau32;

#[derive(Debug)]

pub struct Sys {}

impl Sys {
    pub fn print(v: hxrt::dynamic::Dynamic) {
        {
            print!("{}", v);
        };
    }

    pub fn println(v: hxrt::dynamic::Dynamic) {
        {
            println!("{}", v);
        };
    }

    pub fn args() -> hxrt::array::Array<String> {
        return hxrt::array::Array::<String>::from_vec(
            std::env::args().skip(1).collect::<Vec<String>>(),
        );
    }

    pub fn get_env(s: String) -> String {
        return std::env::var(s.as_str())
            .ok()
            .unwrap_or_else(|| String::new());
    }

    pub fn put_env(s: String, v: Option<String>) {
        if v.is_none() {
            {
                std::env::remove_var(s.as_str());
            };
        } else {
            {
                std::env::set_var(s.as_str(), v.as_ref().unwrap().as_str());
            };
        }
    }

    pub fn environment() -> crate::HxRef<crate::haxe_ds_string_map::StringMap<String>> {
        return {
            let m = crate::haxe_ds_string_map::StringMap::<String>::new();
            for (k, v) in std::env::vars() {
                crate::haxe_ds_string_map::StringMap::set(&m, k, v);
            }
            m
        };
    }

    pub fn sleep(seconds: f64) {
        {
            std::thread::sleep(std::time::Duration::from_millis((seconds * 1000.0) as u64));
        };
    }

    pub fn set_time_locale(loc: String) -> bool {
        let _unused: String = loc;
        return false;
    }

    pub fn get_cwd() -> String {
        return std::env::current_dir()
            .unwrap()
            .to_string_lossy()
            .to_string();
    }

    pub fn set_cwd(path: String) {
        {
            std::env::set_current_dir(path.as_str()).unwrap();
        };
    }

    pub fn system_name() -> String {
        return match std::env::consts::OS {
            "windows" => String::from("Windows"),
            "linux" => String::from("Linux"),
            "macos" => String::from("Mac"),
            "freebsd" => String::from("BSD"),
            "netbsd" => String::from("BSD"),
            "openbsd" => String::from("BSD"),
            _ => String::from(std::env::consts::OS),
        };
    }

    pub fn command(cmd: String, args: Option<hxrt::array::Array<String>>) -> i32 {
        if args.is_none() {
            return std::process::Command::new("sh")
                .arg("-c")
                .arg(cmd.as_str())
                .status()
                .unwrap()
                .code()
                .unwrap_or(1) as i32;
        }
        return {
            let mut c = std::process::Command::new(cmd.as_str());
            let args = args.as_ref().unwrap();
            let mut i: i32 = 0;
            while i < args.len() as i32 {
                let a = args.get_unchecked(i as usize);
                c.arg(a);
                i = i + 1;
            }
            c.status().unwrap().code().unwrap_or(1) as i32
        };
    }

    pub fn exit(code: i32) {
        std::process::exit(code);
    }

    pub fn time() -> f64 {
        return {
            use std::time::{SystemTime, UNIX_EPOCH};
            let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();
            (now.as_secs_f64()) as f64
        };
    }

    pub fn cpu_time() -> f64 {
        return crate::sys::Sys::time();
    }

    pub fn executable_path() -> String {
        return crate::sys::Sys::program_path();
    }

    pub fn program_path() -> String {
        return std::env::current_exe()
            .unwrap()
            .to_string_lossy()
            .to_string();
    }

    pub fn get_char(echo: bool) -> i32 {
        let c: i32 = crate::sys::Sys::stdin().read_byte();
        if echo {
            crate::sys::Sys::stdout().write_byte(c);
        }
        return c;
    }

    pub fn stdin() -> std::rc::Rc<dyn crate::haxe_io_input::InputTrait> {
        return crate::sys_io_stdin::Stdin::new();
    }

    pub fn stdout() -> std::rc::Rc<dyn crate::haxe_io_output::OutputTrait> {
        return crate::sys_io_stdout::Stdout::new();
    }

    pub fn stderr() -> std::rc::Rc<dyn crate::haxe_io_output::OutputTrait> {
        return crate::sys_io_stderr::Stderr::new();
    }
}
