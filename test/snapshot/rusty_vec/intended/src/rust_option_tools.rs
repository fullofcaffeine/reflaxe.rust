// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0x329b81b9u32;

#[derive(Debug)]

pub struct OptionTools {}

impl OptionTools {
    pub fn is_some<T: Clone>(o: Option<T>) -> bool {
        return match o.clone() {
            Option::Some(__p) => {
                let _g: T = __p;
                true
            }
            Option::None => false,
        };
    }

    pub fn is_none<T: Clone>(o: Option<T>) -> bool {
        return !(match o.clone() {
            Option::Some(__p) => {
                let _g: T = __p;
                true
            }
            Option::None => false,
        });
    }

    pub fn unwrap_or<T: Clone>(o: Option<T>, fallback: T) -> T {
        return match o.clone() {
            Option::Some(__p) => {
                let _g: T = __p;
                {
                    let v: T = _g;
                    v
                }
            }
            Option::None => fallback,
        };
    }

    pub fn unwrap<T: Clone>(o: Option<T>) -> T {
        return match o.clone() {
            Option::Some(__p) => {
                let _g: T = __p;
                {
                    let v: T = _g;
                    v
                }
            }
            Option::None => hxrt::exception::throw(hxrt::dynamic::from(String::from(
                "called Option.unwrap() on None",
            ))),
        };
    }

    pub fn expect<T: Clone>(o: Option<T>, message: String) -> T {
        return match o.clone() {
            Option::Some(__p) => {
                let _g: T = __p;
                {
                    let v: T = _g;
                    v
                }
            }
            Option::None => hxrt::exception::throw(hxrt::dynamic::from(message)),
        };
    }

    pub fn ok_or<T: Clone>(o: Option<T>, err: String) -> Result<T, String> {
        return match o.clone() {
            Option::Some(__p) => {
                let _g: T = __p;
                {
                    let v: T = _g;
                    Result::Ok(v.clone())
                }
            }
            Option::None => Result::Err(err),
        };
    }
}
