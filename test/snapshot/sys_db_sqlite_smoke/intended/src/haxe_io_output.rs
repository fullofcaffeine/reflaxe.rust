// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0xe82620b4u32;

#[derive(Debug)]

pub struct Output {
    pub big_endian: bool,
}

impl Output {
    pub fn write_byte(_self_: &crate::HxRefCell<Output>, _c: i32) {
        hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::Custom(
            hxrt::dynamic::from(String::from("Output.writeByte is not implemented")),
        )));
    }

    pub fn write_bytes(
        self_: &crate::HxRefCell<Output>,
        s: crate::HxRef<hxrt::bytes::Bytes>,
        pos: i32,
        len: i32,
    ) -> i32 {
        if pos < 0 || len < 0 || pos + len > s.borrow().length() {
            hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::OutsideBounds));
        }
        let mut p: i32 = pos;
        let mut k: i32 = len;
        while k > 0 {
            crate::haxe_io_output::Output::write_byte(&self_, s.borrow().get(p));
            {
                let __tmp = p;
                p = p + 1;
                __tmp
            };
            {
                let __tmp = k;
                k = k - 1;
                __tmp
            };
        }
        return len;
    }

    pub fn flush(_self_: &crate::HxRefCell<Output>) {}

    pub fn close(_self_: &crate::HxRefCell<Output>) {}

    pub fn set_big_endian(self_: &crate::HxRefCell<Output>, b: bool) -> bool {
        {
            let __tmp = b;
            self_.borrow_mut().big_endian = __tmp;
            __tmp
        };
        return b;
    }

    pub fn write(self_: &crate::HxRefCell<Output>, s: crate::HxRef<hxrt::bytes::Bytes>) {
        let mut l: i32 = s.borrow().length();
        let mut p: i32 = 0;
        while l > 0 {
            let k: i32 = crate::haxe_io_output::Output::write_bytes(&self_, s.clone(), p, l);
            if k == 0 {
                hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::Blocked));
            }
            {
                p = p + k;
                p
            };
            {
                l = l - k;
                l
            };
        }
    }

    pub fn write_full_bytes(
        self_: &crate::HxRefCell<Output>,
        s: crate::HxRef<hxrt::bytes::Bytes>,
        pos: i32,
        len: i32,
    ) {
        let mut p: i32 = pos;
        let mut l: i32 = len;
        while l > 0 {
            let k: i32 = crate::haxe_io_output::Output::write_bytes(&self_, s.clone(), p, l);
            {
                p = p + k;
                p
            };
            {
                l = l - k;
                l
            };
        }
    }

    pub fn write_float(self_: &crate::HxRefCell<Output>, x: f64) {
        crate::haxe_io_output::Output::write_int32(
            &self_,
            crate::haxe_io_fp_helper::FPHelper::float_to_i32(x),
        );
    }

    pub fn write_double(self_: &crate::HxRefCell<Output>, x: f64) {
        let i64: crate::HxRef<crate::haxe_int64_int64::Int64> =
            crate::haxe_io_fp_helper::FPHelper::double_to_i64(x);
        if self_.borrow().big_endian {
            crate::haxe_io_output::Output::write_int32(&self_, i64.borrow().high);
            crate::haxe_io_output::Output::write_int32(&self_, i64.borrow().low);
        } else {
            crate::haxe_io_output::Output::write_int32(&self_, i64.borrow().low);
            crate::haxe_io_output::Output::write_int32(&self_, i64.borrow().high);
        }
    }

    pub fn write_int8(self_: &crate::HxRefCell<Output>, x: i32) {
        if x < -128 || x >= 128 {
            hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::Overflow));
        }
        crate::haxe_io_output::Output::write_byte(&self_, x & 255);
    }

    pub fn write_int16(self_: &crate::HxRefCell<Output>, x: i32) {
        if x < -32768 || x >= 32768 {
            hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::Overflow));
        }
        crate::haxe_io_output::Output::write_u_int16(&self_, x & 65535);
    }

    pub fn write_u_int16(self_: &crate::HxRefCell<Output>, x: i32) {
        if x < 0 || x >= 65536 {
            hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::Overflow));
        }
        if self_.borrow().big_endian {
            crate::haxe_io_output::Output::write_byte(&self_, x >> 8);
            crate::haxe_io_output::Output::write_byte(&self_, x & 255);
        } else {
            crate::haxe_io_output::Output::write_byte(&self_, x & 255);
            crate::haxe_io_output::Output::write_byte(&self_, x >> 8);
        }
    }

    pub fn write_int24(self_: &crate::HxRefCell<Output>, x: i32) {
        if x < -8388608 || x >= 8388608 {
            hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::Overflow));
        }
        crate::haxe_io_output::Output::write_u_int24(&self_, x & 16777215);
    }

    pub fn write_u_int24(self_: &crate::HxRefCell<Output>, x: i32) {
        if x < 0 || x >= 16777216 {
            hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::Overflow));
        }
        if self_.borrow().big_endian {
            crate::haxe_io_output::Output::write_byte(&self_, x >> 16);
            crate::haxe_io_output::Output::write_byte(&self_, x >> 8 & 255);
            crate::haxe_io_output::Output::write_byte(&self_, x & 255);
        } else {
            crate::haxe_io_output::Output::write_byte(&self_, x & 255);
            crate::haxe_io_output::Output::write_byte(&self_, x >> 8 & 255);
            crate::haxe_io_output::Output::write_byte(&self_, x >> 16);
        }
    }

    pub fn write_int32(self_: &crate::HxRefCell<Output>, x: i32) {
        if self_.borrow().big_endian {
            crate::haxe_io_output::Output::write_byte(&self_, (x as u32 >> 24 as u32) as i32);
            crate::haxe_io_output::Output::write_byte(&self_, x >> 16 & 255);
            crate::haxe_io_output::Output::write_byte(&self_, x >> 8 & 255);
            crate::haxe_io_output::Output::write_byte(&self_, x & 255);
        } else {
            crate::haxe_io_output::Output::write_byte(&self_, x & 255);
            crate::haxe_io_output::Output::write_byte(&self_, x >> 8 & 255);
            crate::haxe_io_output::Output::write_byte(&self_, x >> 16 & 255);
            crate::haxe_io_output::Output::write_byte(&self_, (x as u32 >> 24 as u32) as i32);
        }
    }

    pub fn prepare(_self_: &crate::HxRefCell<Output>, _nbytes: i32) {}

    pub fn write_input(
        self_: &crate::HxRefCell<Output>,
        i: crate::HxRc<dyn crate::haxe_io_input::InputTrait + Send + Sync>,
        bufsize: Option<i32>,
    ) {
        let mut bs: Option<i32> = bufsize;
        if bs.is_none() {
            {
                let __tmp = 4096;
                bs = Some(__tmp);
                __tmp
            };
        }
        let bufsize_2: i32 = bs.unwrap();
        let buf: crate::HxRef<hxrt::bytes::Bytes> = crate::HxRc::new(crate::HxRefCell::new(
            hxrt::bytes::Bytes::alloc(bufsize_2 as usize),
        ));
        match hxrt::exception::catch_unwind(|| loop {
            let mut len: i32 = i.read_bytes(buf.clone(), 0, bufsize_2);
            if len == 0 {
                hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::Blocked));
            }
            let mut p: i32 = 0;
            while len > 0 {
                let k: i32 =
                    crate::haxe_io_output::Output::write_bytes(&self_, buf.clone(), p, len);
                if k == 0 {
                    hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::Blocked));
                }
                {
                    p = p + k;
                    p
                };
                {
                    len = len - k;
                    len
                };
            }
        }) {
            Ok(__hx_ok) => __hx_ok,
            Err(__hx_ex) => match __hx_ex.downcast::<crate::HxRef<crate::haxe_io_eof::Eof>>() {
                Ok(_) => {}
                Err(__hx_ex) => hxrt::exception::rethrow(__hx_ex),
            },
        };
    }

    pub fn write_string(
        self_: &crate::HxRefCell<Output>,
        s: String,
        encoding: Option<crate::haxe_io_encoding::Encoding>,
    ) {
        let b: crate::HxRef<hxrt::bytes::Bytes> = {
            let _ = encoding;
            crate::HxRc::new(crate::HxRefCell::new(hxrt::bytes::Bytes::of_string(
                s.as_str(),
            )))
        };
        crate::haxe_io_output::Output::write_full_bytes(&self_, b.clone(), 0, b.borrow().length());
    }
}

pub trait OutputTrait: Send + Sync {
    fn __hx_get_big_endian(&self) -> bool;
    fn __hx_set_big_endian(&self, v: bool);
    fn write_byte(&self, _c: i32) -> ();
    fn write_bytes(&self, s: crate::HxRef<hxrt::bytes::Bytes>, pos: i32, len: i32) -> i32;
    fn flush(&self) -> ();
    fn close(&self) -> ();
    fn set_big_endian(&self, b: bool) -> bool;
    fn write(&self, s: crate::HxRef<hxrt::bytes::Bytes>) -> ();
    fn write_full_bytes(&self, s: crate::HxRef<hxrt::bytes::Bytes>, pos: i32, len: i32) -> ();
    fn write_float(&self, x: f64) -> ();
    fn write_double(&self, x: f64) -> ();
    fn write_int8(&self, x: i32) -> ();
    fn write_int16(&self, x: i32) -> ();
    fn write_u_int16(&self, x: i32) -> ();
    fn write_int24(&self, x: i32) -> ();
    fn write_u_int24(&self, x: i32) -> ();
    fn write_int32(&self, x: i32) -> ();
    fn prepare(&self, _nbytes: i32) -> ();
    fn write_input(
        &self,
        i: crate::HxRc<dyn crate::haxe_io_input::InputTrait + Send + Sync>,
        bufsize: Option<i32>,
    ) -> ();
    fn write_string(&self, s: String, encoding: Option<crate::haxe_io_encoding::Encoding>) -> ();
    fn __hx_type_id(&self) -> u32;
}

impl crate::haxe_io_output::OutputTrait for crate::HxRefCell<Output> {
    fn __hx_get_big_endian(&self) -> bool {
        self.borrow().big_endian
    }
    fn __hx_set_big_endian(&self, v: bool) {
        self.borrow_mut().big_endian = v;
    }
    fn write_byte(&self, _c: i32) -> () {
        Output::write_byte(self, _c)
    }
    fn write_bytes(&self, s: crate::HxRef<hxrt::bytes::Bytes>, pos: i32, len: i32) -> i32 {
        Output::write_bytes(self, s, pos, len)
    }
    fn flush(&self) -> () {
        Output::flush(self)
    }
    fn close(&self) -> () {
        Output::close(self)
    }
    fn set_big_endian(&self, b: bool) -> bool {
        Output::set_big_endian(self, b)
    }
    fn write(&self, s: crate::HxRef<hxrt::bytes::Bytes>) -> () {
        Output::write(self, s)
    }
    fn write_full_bytes(&self, s: crate::HxRef<hxrt::bytes::Bytes>, pos: i32, len: i32) -> () {
        Output::write_full_bytes(self, s, pos, len)
    }
    fn write_float(&self, x: f64) -> () {
        Output::write_float(self, x)
    }
    fn write_double(&self, x: f64) -> () {
        Output::write_double(self, x)
    }
    fn write_int8(&self, x: i32) -> () {
        Output::write_int8(self, x)
    }
    fn write_int16(&self, x: i32) -> () {
        Output::write_int16(self, x)
    }
    fn write_u_int16(&self, x: i32) -> () {
        Output::write_u_int16(self, x)
    }
    fn write_int24(&self, x: i32) -> () {
        Output::write_int24(self, x)
    }
    fn write_u_int24(&self, x: i32) -> () {
        Output::write_u_int24(self, x)
    }
    fn write_int32(&self, x: i32) -> () {
        Output::write_int32(self, x)
    }
    fn prepare(&self, _nbytes: i32) -> () {
        Output::prepare(self, _nbytes)
    }
    fn write_input(
        &self,
        i: crate::HxRc<dyn crate::haxe_io_input::InputTrait + Send + Sync>,
        bufsize: Option<i32>,
    ) -> () {
        Output::write_input(self, i, bufsize)
    }
    fn write_string(&self, s: String, encoding: Option<crate::haxe_io_encoding::Encoding>) -> () {
        Output::write_string(self, s, encoding)
    }
    fn __hx_type_id(&self) -> u32 {
        crate::haxe_io_output::__HX_TYPE_ID
    }
}
