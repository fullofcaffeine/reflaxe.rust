// Generated by reflaxe.rust (POC)

pub const __HX_TYPE_ID: u32 = 0x041993fcu32;

#[derive(Debug)]

pub struct FileInput {
    pub big_endian: bool,
    handle: crate::HxRef<hxrt::fs::FileHandle>,
}

impl FileInput {
    pub fn new(
        handle: crate::HxRef<hxrt::fs::FileHandle>,
    ) -> crate::HxRef<crate::sys_io_file_input::FileInput> {
        let self_: crate::HxRef<crate::sys_io_file_input::FileInput> =
            crate::HxRc::new(crate::HxRefCell::new(FileInput {
                big_endian: false,
                handle: handle,
            }));
        return self_;
    }

    fn get_handle(self_: &crate::HxRefCell<FileInput>) -> crate::HxRef<hxrt::fs::FileHandle> {
        return self_.borrow().handle.clone();
    }

    pub fn close(self_: &crate::HxRefCell<FileInput>) {
        self_.borrow().handle.clone().borrow_mut().close();
    }

    pub fn read_byte(self_: &crate::HxRefCell<FileInput>) -> i32 {
        let v: i32 = { self_.borrow().handle.clone().borrow_mut().read_byte() };
        if v == -1 {
            hxrt::exception::throw(hxrt::dynamic::from(crate::haxe_io_eof::Eof::new()));
        }
        return v;
    }

    pub fn read_bytes(
        self_: &crate::HxRefCell<FileInput>,
        s: crate::HxRef<hxrt::bytes::Bytes>,
        pos: i32,
        len: i32,
    ) -> i32 {
        if pos < 0 || len < 0 || pos + len > s.borrow().length() {
            hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::OutsideBounds));
        }
        if len == 0 {
            return 0;
        }
        let out: i32 = {
            let mut buf = vec![0u8; len as usize];
            let n: i32 = self_
                .borrow()
                .handle
                .clone()
                .borrow_mut()
                .read_into(buf.as_mut_slice());
            if n == 0 {
                -1i32
            } else if n == -1i32 {
                -1i32
            } else {
                hxrt::bytes::write_from_slice(&s, pos, &buf[0..(n as usize)]);
                n
            }
        };
        if out == -1 {
            hxrt::exception::throw(hxrt::dynamic::from(crate::haxe_io_eof::Eof::new()));
        }
        return out;
    }

    pub fn seek(
        self_: &crate::HxRefCell<FileInput>,
        p: i32,
        pos: crate::sys_io_file_seek::FileSeek,
    ) {
        let h: crate::HxRef<hxrt::fs::FileHandle> = self_.borrow().handle.clone();
        match pos.clone() {
            crate::sys_io_file_seek::FileSeek::SeekBegin => {
                h.borrow_mut().seek_from_start(p as u64);
            }
            crate::sys_io_file_seek::FileSeek::SeekCur => {
                h.borrow_mut().seek_from_current(p as i64);
            }
            crate::sys_io_file_seek::FileSeek::SeekEnd => {
                h.borrow_mut().seek_from_end(p as i64);
            }
        }
    }

    pub fn tell(self_: &crate::HxRefCell<FileInput>) -> i32 {
        return self_.borrow().handle.clone().borrow_mut().tell();
    }

    pub fn eof(self_: &crate::HxRefCell<FileInput>) -> bool {
        return self_.borrow().handle.clone().borrow_mut().eof();
    }

    pub fn set_big_endian(self_: &crate::HxRefCell<FileInput>, b: bool) -> bool {
        {
            let __tmp = b;
            self_.borrow_mut().big_endian = __tmp;
            __tmp
        };
        return b;
    }

    pub fn read_all(
        self_: &crate::HxRefCell<FileInput>,
        bufsize: Option<i32>,
    ) -> crate::HxRef<hxrt::bytes::Bytes> {
        let mut bs: Option<i32> = bufsize;
        if bs.is_none() {
            {
                let __tmp = 16384;
                bs = Some(__tmp);
                __tmp
            };
        }
        let bufsize_2: i32 = bs.unwrap();
        let buf: crate::HxRef<hxrt::bytes::Bytes> = crate::HxRc::new(crate::HxRefCell::new(
            hxrt::bytes::Bytes::alloc(bufsize_2 as usize),
        ));
        let total: crate::HxRef<crate::haxe_io_bytes_buffer::BytesBuffer> =
            crate::haxe_io_bytes_buffer::BytesBuffer::new();
        match hxrt::exception::catch_unwind(|| loop {
            let len: i32 =
                crate::sys_io_file_input::FileInput::read_bytes(&self_, buf.clone(), 0, bufsize_2);
            if len == 0 {
                hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::Blocked));
            }
            crate::haxe_io_bytes_buffer::BytesBuffer::add_bytes(&total, buf.clone(), 0, len);
        }) {
            Ok(__hx_ok) => __hx_ok,
            Err(__hx_ex) => match __hx_ex.downcast::<crate::HxRef<crate::haxe_io_eof::Eof>>() {
                Ok(_) => {}
                Err(__hx_ex) => hxrt::exception::rethrow(__hx_ex),
            },
        };
        return crate::haxe_io_bytes_buffer::BytesBuffer::get_bytes(&total);
    }

    pub fn read_full_bytes(
        self_: &crate::HxRefCell<FileInput>,
        s: crate::HxRef<hxrt::bytes::Bytes>,
        pos: i32,
        len: i32,
    ) {
        let mut p: i32 = pos;
        let mut l: i32 = len;
        while l > 0 {
            let k: i32 = crate::sys_io_file_input::FileInput::read_bytes(&self_, s.clone(), p, l);
            if k == 0 {
                hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::Blocked));
            }
            {
                p = p + k;
                p
            };
            {
                l = l - k;
                l
            };
        }
    }

    pub fn read(
        self_: &crate::HxRefCell<FileInput>,
        nbytes: i32,
    ) -> crate::HxRef<hxrt::bytes::Bytes> {
        let mut remaining: i32 = nbytes;
        let s: crate::HxRef<hxrt::bytes::Bytes> = crate::HxRc::new(crate::HxRefCell::new(
            hxrt::bytes::Bytes::alloc(remaining as usize),
        ));
        let mut p: i32 = 0;
        while remaining > 0 {
            let k: i32 =
                crate::sys_io_file_input::FileInput::read_bytes(&self_, s.clone(), p, remaining);
            if k == 0 {
                hxrt::exception::throw(hxrt::dynamic::from(hxrt::io::Error::Blocked));
            }
            {
                p = p + k;
                p
            };
            {
                remaining = remaining - k;
                remaining
            };
        }
        return s;
    }

    pub fn read_until(self_: &crate::HxRefCell<FileInput>, end: i32) -> String {
        let buf: crate::HxRef<crate::haxe_io_bytes_buffer::BytesBuffer> =
            crate::haxe_io_bytes_buffer::BytesBuffer::new();
        loop {
            let last: i32 = crate::sys_io_file_input::FileInput::read_byte(&self_);
            if last == end {
                break;
            }
            crate::haxe_io_bytes_buffer::BytesBuffer::add_byte(&buf, last);
        }
        return crate::haxe_io_bytes_buffer::BytesBuffer::get_bytes(&buf)
            .borrow()
            .to_string();
    }

    pub fn read_line(self_: &crate::HxRefCell<FileInput>) -> String {
        let buf: crate::HxRef<crate::haxe_io_bytes_buffer::BytesBuffer> =
            crate::haxe_io_bytes_buffer::BytesBuffer::new();
        match hxrt::exception::catch_unwind(|| loop {
            let last: i32 = crate::sys_io_file_input::FileInput::read_byte(&self_);
            if last == 10 {
                break;
            }
            crate::haxe_io_bytes_buffer::BytesBuffer::add_byte(&buf, last);
        }) {
            Ok(__hx_ok) => __hx_ok,
            Err(__hx_ex) => match __hx_ex.downcast::<crate::HxRef<crate::haxe_io_eof::Eof>>() {
                Ok(__hx_box) => {
                    let e: crate::HxRef<crate::haxe_io_eof::Eof> = *__hx_box;
                    let bytes: crate::HxRef<hxrt::bytes::Bytes> =
                        crate::haxe_io_bytes_buffer::BytesBuffer::get_bytes(&buf);
                    if bytes.borrow().length() == 0 {
                        hxrt::exception::throw(hxrt::dynamic::from(e));
                    }
                    return bytes.borrow().to_string();
                }
                Err(__hx_ex) => hxrt::exception::rethrow(__hx_ex),
            },
        };
        let mut bytes_2: crate::HxRef<hxrt::bytes::Bytes> =
            crate::haxe_io_bytes_buffer::BytesBuffer::get_bytes(&buf);
        let bytes_len: i32 = bytes_2.borrow().length();
        if bytes_len > 0 {
            let last_byte: i32 = bytes_2.borrow().get(bytes_len - 1);
            if last_byte == 13 {
                let trimmed: crate::HxRef<hxrt::bytes::Bytes> = crate::HxRc::new(
                    crate::HxRefCell::new(bytes_2.borrow().sub(0, bytes_len - 1)),
                );
                bytes_2 = trimmed;
            }
        }
        return bytes_2.borrow().to_string();
    }

    pub fn read_float(self_: &crate::HxRefCell<FileInput>) -> f64 {
        return crate::haxe_io_fp_helper::FPHelper::i32_to_float(
            crate::sys_io_file_input::FileInput::read_int32(&self_),
        );
    }

    pub fn read_double(self_: &crate::HxRefCell<FileInput>) -> f64 {
        let i1: i32 = crate::sys_io_file_input::FileInput::read_int32(&self_);
        let i2: i32 = crate::sys_io_file_input::FileInput::read_int32(&self_);
        return if self_.borrow().big_endian {
            crate::haxe_io_fp_helper::FPHelper::i64_to_double(i2, i1)
        } else {
            crate::haxe_io_fp_helper::FPHelper::i64_to_double(i1, i2)
        };
    }

    pub fn read_int8(self_: &crate::HxRefCell<FileInput>) -> i32 {
        let n: i32 = crate::sys_io_file_input::FileInput::read_byte(&self_);
        if n >= 128 {
            return n - 256;
        }
        return n;
    }

    pub fn read_int16(self_: &crate::HxRefCell<FileInput>) -> i32 {
        let ch1: i32 = crate::sys_io_file_input::FileInput::read_byte(&self_);
        let ch2: i32 = crate::sys_io_file_input::FileInput::read_byte(&self_);
        let n: i32 = if self_.borrow().big_endian {
            ch1 << 8 | ch2
        } else {
            ch1 | (ch2 << 8)
        };
        if n >= 32768 {
            return n - 65536;
        }
        return n;
    }

    pub fn read_u_int16(self_: &crate::HxRefCell<FileInput>) -> i32 {
        let ch1: i32 = crate::sys_io_file_input::FileInput::read_byte(&self_);
        let ch2: i32 = crate::sys_io_file_input::FileInput::read_byte(&self_);
        return if self_.borrow().big_endian {
            ch1 << 8 | ch2
        } else {
            ch1 | (ch2 << 8)
        };
    }

    pub fn read_int24(self_: &crate::HxRefCell<FileInput>) -> i32 {
        let ch1: i32 = crate::sys_io_file_input::FileInput::read_byte(&self_);
        let ch2: i32 = crate::sys_io_file_input::FileInput::read_byte(&self_);
        let ch3: i32 = crate::sys_io_file_input::FileInput::read_byte(&self_);
        let n: i32 = if self_.borrow().big_endian {
            ch1 << 16 | (ch2 << 8) | ch3
        } else {
            ch1 | (ch2 << 8) | (ch3 << 16)
        };
        if n >= 8388608 {
            return n - 16777216;
        }
        return n;
    }

    pub fn read_u_int24(self_: &crate::HxRefCell<FileInput>) -> i32 {
        let ch1: i32 = crate::sys_io_file_input::FileInput::read_byte(&self_);
        let ch2: i32 = crate::sys_io_file_input::FileInput::read_byte(&self_);
        let ch3: i32 = crate::sys_io_file_input::FileInput::read_byte(&self_);
        return if self_.borrow().big_endian {
            ch1 << 16 | (ch2 << 8) | ch3
        } else {
            ch1 | (ch2 << 8) | (ch3 << 16)
        };
    }

    pub fn read_int32(self_: &crate::HxRefCell<FileInput>) -> i32 {
        let ch1: i32 = crate::sys_io_file_input::FileInput::read_byte(&self_);
        let ch2: i32 = crate::sys_io_file_input::FileInput::read_byte(&self_);
        let ch3: i32 = crate::sys_io_file_input::FileInput::read_byte(&self_);
        let ch4: i32 = crate::sys_io_file_input::FileInput::read_byte(&self_);
        return if self_.borrow().big_endian {
            ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24)
        } else {
            ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24)
        };
    }

    pub fn read_string(
        self_: &crate::HxRefCell<FileInput>,
        len: i32,
        encoding: Option<crate::haxe_io_encoding::Encoding>,
    ) -> String {
        let b: crate::HxRef<hxrt::bytes::Bytes> = crate::HxRc::new(crate::HxRefCell::new(
            hxrt::bytes::Bytes::alloc(len as usize),
        ));
        crate::sys_io_file_input::FileInput::read_full_bytes(&self_, b.clone(), 0, len);
        return {
            let _ = encoding;
            b.borrow().get_string(0, len)
        };
    }
}

impl crate::haxe_io_input::InputTrait for crate::HxRefCell<FileInput> {
    fn __hx_get_big_endian(&self) -> bool {
        self.borrow().big_endian
    }
    fn __hx_set_big_endian(&self, v: bool) {
        self.borrow_mut().big_endian = v;
    }
    fn close(&self) -> () {
        FileInput::close(self)
    }
    fn read(&self, nbytes: i32) -> crate::HxRef<hxrt::bytes::Bytes> {
        FileInput::read(self, nbytes)
    }
    fn read_all(&self, bufsize: Option<i32>) -> crate::HxRef<hxrt::bytes::Bytes> {
        FileInput::read_all(self, bufsize)
    }
    fn read_byte(&self) -> i32 {
        FileInput::read_byte(self)
    }
    fn read_bytes(&self, s: crate::HxRef<hxrt::bytes::Bytes>, pos: i32, len: i32) -> i32 {
        FileInput::read_bytes(self, s, pos, len)
    }
    fn read_double(&self) -> f64 {
        FileInput::read_double(self)
    }
    fn read_float(&self) -> f64 {
        FileInput::read_float(self)
    }
    fn read_full_bytes(&self, s: crate::HxRef<hxrt::bytes::Bytes>, pos: i32, len: i32) -> () {
        FileInput::read_full_bytes(self, s, pos, len)
    }
    fn read_int16(&self) -> i32 {
        FileInput::read_int16(self)
    }
    fn read_int24(&self) -> i32 {
        FileInput::read_int24(self)
    }
    fn read_int32(&self) -> i32 {
        FileInput::read_int32(self)
    }
    fn read_int8(&self) -> i32 {
        FileInput::read_int8(self)
    }
    fn read_line(&self) -> String {
        FileInput::read_line(self)
    }
    fn read_string(&self, len: i32, encoding: Option<crate::haxe_io_encoding::Encoding>) -> String {
        FileInput::read_string(self, len, encoding)
    }
    fn read_u_int16(&self) -> i32 {
        FileInput::read_u_int16(self)
    }
    fn read_u_int24(&self) -> i32 {
        FileInput::read_u_int24(self)
    }
    fn read_until(&self, end: i32) -> String {
        FileInput::read_until(self, end)
    }
    fn set_big_endian(&self, b: bool) -> bool {
        FileInput::set_big_endian(self, b)
    }
    fn __hx_type_id(&self) -> u32 {
        crate::sys_io_file_input::__HX_TYPE_ID
    }
}
