// Generated by reflaxe.rust (POC)

#![allow(dead_code)]
#![allow(type_alias_bounds)]

type HxRc<T> = hxrt::cell::HxRc<T>;
type HxDynRef<T: ?Sized> = hxrt::cell::HxDynRef<T>;
type HxRefCell<T> = hxrt::cell::HxCell<T>;
type HxRef<T> = hxrt::cell::HxRef<T>;

mod foo;
mod haxe_call_stack_call_stack_impl_;
mod haxe_ds_enum_value_map;
mod haxe_ds_int_map;
mod haxe_ds_object_map;
mod haxe_ds_string_map;
mod haxe_exception;
mod haxe_i_map;
mod haxe_int64_int64;
mod haxe_int64_int64_impl_;
mod haxe_io_bytes_buffer;
mod haxe_io_encoding;
mod haxe_io_eof;
mod haxe_io_fp_helper;
mod haxe_io_input;
mod haxe_io_output;
mod haxe_stack_item;
mod my_enum;
mod string_buf;
mod sys;
mod sys_io_stderr;
mod sys_io_stdin;
mod sys_io_stdout;

/// Runtime subtype check for stable Haxe class type ids.
///
/// Generated by reflaxe.rust from the emitted class inheritance graph.
#[inline]
pub(crate) fn __hx_is_subtype_type_id(actual: u32, expected: u32) -> bool {
    if actual == expected {
        return true;
    }
    match actual {
        0x0cd85f36u32 => matches!(expected, 0x44f4c432u32),
        0x39e0cd5bu32 => matches!(expected, 0x44f4c432u32),
        0xd7e07825u32 => matches!(expected, 0x44f4c432u32),
        0x181f937bu32 => matches!(expected, 0x44f4c432u32),
        0x163b1f5au32 => matches!(expected, 0xe82620b4u32),
        0xfb16179cu32 => matches!(expected, 0xd50291cbu32),
        0x9402c169u32 => matches!(expected, 0xe82620b4u32),
        _ => false,
    }
}

fn main() {
    println!(
        "{}",
        hxrt::dynamic::from(hxrt::string::HxString::from("--- Std.string ---"))
    );
    println!("{}", hxrt::dynamic::from(hxrt::string::HxString::from("1")));
    println!(
        "{}",
        hxrt::dynamic::from(hxrt::string::HxString::from("true"))
    );
    println!(
        "{}",
        hxrt::dynamic::from(hxrt::string::HxString::from(1.5.to_string()).clone())
    );
    println!(
        "{}",
        hxrt::dynamic::from(hxrt::string::HxString::from("hi"))
    );
    println!(
        "{}",
        hxrt::dynamic::from(
            hxrt::string::HxString::from(
                hxrt::dynamic::from(crate::foo::Foo::new(3).clone()).to_haxe_string()
            )
            .clone()
        )
    );
    println!(
        "{}",
        hxrt::dynamic::from(hxrt::string::HxString::from("--- Std.parseFloat ---"))
    );
    println!(
        "{}",
        hxrt::dynamic::from(hxrt::string::parse_float(
            hxrt::string::HxString::from("1.25").as_str()
        ))
    );
    println!(
        "{}",
        hxrt::dynamic::from(hxrt::string::parse_float(
            hxrt::string::HxString::from("nope").as_str()
        ))
    );
    println!(
        "{}",
        hxrt::dynamic::from(hxrt::string::HxString::from("--- Type names ---"))
    );
    println!("{}", hxrt::dynamic::from(String::from("Main.Foo").clone()));
    println!(
        "{}",
        hxrt::dynamic::from(String::from("Main.MyEnum").clone())
    );
    println!(
        "{}",
        hxrt::dynamic::from(hxrt::string::HxString::from("--- Bytes ---"))
    );
    let b: crate::HxRef<hxrt::bytes::Bytes> = crate::HxRef::new(hxrt::bytes::Bytes::of_string(
        hxrt::string::HxString::from("hi").as_str(),
    ));
    println!("{}", hxrt::dynamic::from(b.borrow().length()));
    println!("{}", hxrt::dynamic::from(b.borrow().get(0)));
    b.borrow_mut().set(0, 72);
    println!("{}", hxrt::dynamic::from(b.borrow().to_string().clone()));
    let b2: crate::HxRef<hxrt::bytes::Bytes> =
        crate::HxRef::new(hxrt::bytes::Bytes::alloc(3 as usize));
    b2.borrow_mut().set(0, 65);
    b2.borrow_mut().set(1, 66);
    b2.borrow_mut().set(2, 67);
    println!("{}", hxrt::dynamic::from(b2.borrow().to_string().clone()));
    println!(
        "{}",
        hxrt::dynamic::from(hxrt::string::HxString::from("--- Option ---"))
    );
    let o: Option<i32> = Option::Some(5);
    match o.clone() {
        Option::Some(__p) => {
            let _g: i32 = __p;
            {
                let v: i32 = _g;
                println!("{}", hxrt::dynamic::from(v));
            }
        }
        Option::None => {
            println!(
                "{}",
                hxrt::dynamic::from(hxrt::string::HxString::from("none"))
            );
        }
    }
    let o2: Option<i32> = Option::None;
    match o2.clone() {
        Option::Some(__p) => {
            let _g_2: i32 = __p;
            {
                let v_2: i32 = _g_2;
                println!("{}", hxrt::dynamic::from(v_2));
            }
        }
        Option::None => {
            println!(
                "{}",
                hxrt::dynamic::from(hxrt::string::HxString::from("none"))
            );
        }
    }
    println!(
        "{}",
        hxrt::dynamic::from(hxrt::string::HxString::from("--- Result ---"))
    );
    let r: Result<i32, hxrt::string::HxString> = Result::Ok(7);
    match r.clone() {
        Result::Ok(__p) => {
            let _g_3: i32 = __p;
            {
                let v_3: i32 = _g_3;
                println!("{}", hxrt::dynamic::from(v_3));
            }
        }
        Result::Err(__p) => {
            let _g_4: hxrt::string::HxString = hxrt::string::HxString::from(__p);
            {
                let e: hxrt::string::HxString = hxrt::string::HxString::from(_g_4);
                println!("{}", hxrt::dynamic::from(e.clone()));
            }
        }
    }
    let r2: Result<i32, hxrt::string::HxString> = Result::Err(hxrt::string::HxString::from(
        hxrt::string::HxString::from("fail"),
    ));
    match r2.clone() {
        Result::Ok(__p) => {
            let _g_5: i32 = __p;
            {
                let v_4: i32 = _g_5;
                println!("{}", hxrt::dynamic::from(v_4));
            }
        }
        Result::Err(__p) => {
            let _g_6: hxrt::string::HxString = hxrt::string::HxString::from(__p);
            {
                let e_2: hxrt::string::HxString = hxrt::string::HxString::from(_g_6);
                println!("{}", hxrt::dynamic::from(e_2.clone()));
            }
        }
    }
    println!(
        "{}",
        hxrt::dynamic::from(hxrt::string::HxString::from("--- Reflect ---"))
    );
    let foo: crate::HxRef<crate::foo::Foo> = crate::foo::Foo::new(9);
    println!(
        "{}",
        hxrt::dynamic::from({
            let __b = foo.borrow();
            __b.x
        })
    );
    println!(
        "{}",
        hxrt::dynamic::from({
            let __b = foo.borrow();
            __b.x.clone()
        })
    );
    {
        let __obj = foo.clone();
        let __val = 42;
        __obj.borrow_mut().x = __val;
    };
    println!(
        "{}",
        hxrt::dynamic::from({
            let __b = foo.borrow();
            __b.x
        })
    );
}
