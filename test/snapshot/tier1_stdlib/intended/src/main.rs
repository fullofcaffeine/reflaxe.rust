// Generated by reflaxe.rust (POC)

#![allow(dead_code)]

type HxRef<T> = std::rc::Rc<std::cell::RefCell<T>>;

mod foo;
mod my_enum;
mod sys;

fn main() {
    println!("{}", String::from("--- Std.string ---"));
    println!("{}", String::from("1"));
    println!("{}", String::from("true"));
    println!("{}", 1.5.to_string());
    println!("{}", String::from("hi"));
    println!("{}", format!("{:?}", crate::foo::Foo::new(3)));
    println!("{}", String::from("--- Std.parseFloat ---"));
    println!(
        "{}",
        hxrt::string::parse_float(String::from("1.25").as_str())
    );
    println!(
        "{}",
        hxrt::string::parse_float(String::from("nope").as_str())
    );
    println!("{}", String::from("--- Type names ---"));
    println!("{}", String::from("Main.Foo"));
    println!("{}", String::from("Main.MyEnum"));
    println!("{}", String::from("--- Bytes ---"));
    let b: crate::HxRef<hxrt::bytes::Bytes> = std::rc::Rc::new(std::cell::RefCell::new(
        hxrt::bytes::Bytes::of_string(String::from("hi").as_str()),
    ));
    println!("{}", b.borrow().length());
    println!("{}", b.borrow().get(0));
    b.borrow_mut().set(0, 72);
    println!("{}", b.borrow().to_string());
    let b2: crate::HxRef<hxrt::bytes::Bytes> = std::rc::Rc::new(std::cell::RefCell::new(
        hxrt::bytes::Bytes::alloc(3 as usize),
    ));
    b2.borrow_mut().set(0, 65);
    b2.borrow_mut().set(1, 66);
    b2.borrow_mut().set(2, 67);
    println!("{}", b2.borrow().to_string());
    println!("{}", String::from("--- Option ---"));
    let o: Option<i32> = Option::Some(5);
    match o.clone() {
        Option::Some(__p) => {
            let _g: i32 = __p;
            {
                let v: i32 = _g;
                println!("{}", v);
            };
        }
        Option::None => {
            println!("{}", String::from("none"));
        }
    };
    let o2: Option<i32> = Option::None;
    match o2.clone() {
        Option::Some(__p) => {
            let _g_2: i32 = __p;
            {
                let v_2: i32 = _g_2;
                println!("{}", v_2);
            };
        }
        Option::None => {
            println!("{}", String::from("none"));
        }
    };
    println!("{}", String::from("--- Result ---"));
    let r: Result<i32, String> = Result::Ok(7);
    match r.clone() {
        Result::Ok(__p) => {
            let _g_3: i32 = __p;
            {
                let v_3: i32 = _g_3;
                println!("{}", v_3);
            };
        }
        Result::Err(__p) => {
            let _g_4: String = __p;
            {
                let e: String = _g_4;
                println!("{}", e);
            };
        }
    };
    let r2: Result<i32, String> = Result::Err(String::from("fail").clone());
    match r2.clone() {
        Result::Ok(__p) => {
            let _g_5: i32 = __p;
            {
                let v_4: i32 = _g_5;
                println!("{}", v_4);
            };
        }
        Result::Err(__p) => {
            let _g_6: String = __p;
            {
                let e_2: String = _g_6;
                println!("{}", e_2);
            };
        }
    };
    println!("{}", String::from("--- Reflect ---"));
    let foo: crate::HxRef<crate::foo::Foo> = crate::foo::Foo::new(9);
    println!("{}", foo.borrow().x);
    println!("{:?}", hxrt::dynamic::from(foo.borrow().x.clone()));
    {
        {
            let __tmp = 42;
            foo.borrow_mut().x = __tmp.clone();
            __tmp
        };
    };
    println!("{}", foo.borrow().x);
}
