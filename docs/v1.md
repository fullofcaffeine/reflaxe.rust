# v1.0 Support Matrix (Draft)

This document defines what “v1.0” means for `reflaxe.rust`: which Haxe features and std modules are
considered supported, which profiles exist, and what the default build workflow looks like.

v1.0 is intentionally strict: if something is not listed here, treat it as “may compile, but not
part of the stability contract yet”.

## Build workflow (native by default)

Minimal compile:

- `haxe -lib reflaxe.rust -D rust_output=out -main Main`

Defaults:

- Generates a Cargo crate in `out/` (with `hxrt` runtime bundled).
- Runs `cargo build` best-effort after codegen (debug profile).

Opt-outs / knobs:

- Codegen-only: `-D rust_no_build` (alias: `-D rust_codegen_only`)
- Release build: `-D rust_release` (alias: `-D rust_build_release`)
- Run rustfmt after codegen: `-D rustfmt`
- Choose Cargo subcommand: `-D rust_cargo_subcommand=build|check|test|clippy|run`
- Pass target triple: `-D rust_target=<triple>`
- Force nullable string wrapper mode: `-D rust_string_nullable`
- Force legacy non-null string mode: `-D rust_string_non_nullable`

## Profiles

Profiles are compile-time flags that trade “Haxe portability” vs “Rust idioms”.

Set via:

- `-D reflaxe_rust_profile=portable|idiomatic|rusty|metal`

### Portable (default)

- Prioritizes Haxe semantics and portability.
- Uses runtime wrappers when Rust ownership would otherwise conflict with Haxe expectations
  (example: `Array<T>` aliases on assignment).
- String representation defaults to nullable `hxrt::string::HxString` (Haxe-compatible `null` support).

### Idiomatic

- Same semantics as Portable, but emits cleaner Rust where possible (clone elision, cleaner blocks,
  warning-free output).
- Example: when passing `String` arguments, the compiler only clones *locals* (to preserve Haxe’s
  “strings are reusable after calls” behavior). In practice this means:
  - locals are cloned only when they are used more than once within the function (otherwise we can
    safely move them)
  - temporary string expressions (concatenations, call results) are moved without an extra `.clone()`
    to keep output clean
  - string concatenation lowers to a single `format!` call and prefers borrowing `String` sources
    (and emitting string literals as `&'static str`) to avoid intermediate allocations

### Rusty

- Opt-in mode for developers who want to integrate with Rust concepts more directly.
- Adds “borrow scoped” helper APIs (`rust.Borrow`, `rust.SliceTools`, `rust.MutSliceTools`, etc.).
- Still aims to keep app code “pure Haxe” (no direct `__rust__` in examples/apps).
- Keeps legacy non-null Rust `String` by default unless you explicitly set `-D rust_string_nullable`.

### Metal (experimental)

- Rusty+ mode for teams that need typed low-level interop in selected places.
- Adds `rust.metal.Code.expr(...)` / `rust.metal.Code.stmt(...)` as typed façade surfaces.
- Enables strict app-boundary policy by default (raw app-side `__rust__` is rejected).

## “No injection in apps” rule

Policy:

- Apps/examples should not call `__rust__` directly.
- Put injections behind Haxe APIs in `std/rust/*` (escape hatch still exists, but should be rare).

Enforcement:

- Examples and snapshot tests compile with `-D reflaxe_rust_strict_examples`.

## Supported language features (v1.0 target)

This list is the minimum surface expected to remain stable for v1.0:

- Expressions: literals, locals, assignment, unary/binary ops
- Equality: `==` / `!=` for objects and arrays uses Haxe identity semantics
- Control flow: blocks, if/else, while, for-range, for-iter
- Functions: calls, closures/function values
- Types: classes, interfaces, inheritance (portable dispatch model)
  - Inheritance includes method inheritance shims (subclasses get concrete Rust methods for base methods).
  - `super.method(...)` is supported (compiled via per-base “super thunk” methods on the current class).
- Properties (`var x(get,set)` / `var x(default,set)`):
  - Non-storage properties are not emitted as struct fields.
  - Property reads/writes lower to `get_x()` / `set_x(v)` calls.
  - Assignment result matches Haxe semantics: `obj.x = v` returns the setter return value (not always `v`).
  - Storage-backed accessors (`default,get` / `default,set`) treat `x` inside `get_x`/`set_x` as direct backing-field
    access to avoid recursive calls.
- Enums + `switch` lowering to Rust `match`
- Exceptions: throw + try/catch
- Generics: common cases used by std and rusty helpers

Known gaps (not v1.0 yet):

- (keep this section small; add new gaps only when they are genuinely blocking)

## Core stdlib + overrides

The Rust target ships a small Rust runtime crate (`runtime/hxrt`) and overrides a subset of the Haxe
stdlib in `std/` to ensure predictable semantics.

Notable items:

- `Array<T>` maps to `hxrt::array::Array<T>` (a lightweight wrapper around `HxRef<Vec<T>>`).
  - `HxRef<T>` is the runtime's nullable shared handle for Haxe reference values, backed by thread-safe
    ownership/interior-mutability primitives (so values can safely cross OS threads).
- `haxe.io.Bytes` maps to a runtime buffer type (`hxrt::bytes::Bytes`)
- Compiler emission model:
  - By default, codegen emits user project modules plus this repo's `std/` overrides.
  - Upstream Haxe stdlib modules are type-checked but not emitted unless you opt in with
    `-D rust_emit_upstream_std`.
- `Sys.getEnv(name)` currently returns `""` (empty string) when missing instead of `null`.
  - Rationale: this preserves existing cross-target behavior in apps that assume a concrete string return.
  - If you need to distinguish missing vs empty, prefer `Sys.environment().exists(name)` for now.

## Reflection subset (portable)

Portable v1.0 includes a deliberately small reflection surface (compile-time where possible):

- `Type.getClassName(TypeExpr)` and `Type.getEnumName(TypeExpr)` for `TTypeExpr` inputs.
- `Reflect.hasField(obj, "field")` for constant field names on:
  - class instances (`TInst`): checks declared instance fields/methods
  - anonymous objects (`TAnonymous`): checks structural fields
- `Reflect.field(obj, "field")` for constant field names on:
  - class instances: supports instance `var` fields (boxed into `Dynamic`)
  - anonymous objects: supports structural fields (boxed into `Dynamic`)
- `Reflect.setField(obj, "field", value)` for constant field names on:
  - class instances: supports instance `var` fields
  - anonymous objects: supports general record literals (lowered to `hxrt::anon::Anon`)

Notes:

- This is not “full RTTI reflection”. If the field name is not a compile-time string literal, the call is unsupported.
- `Reflect.setField` accepts either a concrete typed value or a `Dynamic` value that can be downcast to the target field type at runtime.

## Rusty API layer (selected)

The `std/rust/*` package provides Rust-leaning APIs that remain “Haxe shaped”:

- Ownership/borrows: `rust.Ref<T>`, `rust.MutRef<T>`, `rust.Borrow.withRef/withMut`
- Collections: `rust.Vec<T>`, `rust.HashMap<K,V>` (+ Tools)
- Slices: `rust.Slice<T>`, `rust.MutSlice<T>`, `rust.SliceTools`, `rust.MutSliceTools`
  - Works on `rust.Vec<T>` and (in Rusty profile) on `Array<T>` without cloning.
- Option/Result: `rust.Option<T>`, `rust.Result<T,E>` (+ Tools)

## Known limitations (v1.0 non-goals)

- Full Rust lifetime modeling: Haxe has no lifetime syntax; borrow helpers must keep borrows scoped.
- Zero-cost output everywhere: correctness and predictability beat “perfectly idiomatic Rust” in Portable.
- Total stdlib parity: **required for v1.0**. The v1.0 bar is “sys target parity” with Haxe 4.3.7 std
  (the full `sys/*` tree, plus dependent `haxe/*` modules that are part of std for sys-capable targets).
  This release was tracked internally as a production release gate, and that gate is now closed.
- Catch type matching is currently exact-type downcast based (Rust `Any`), not a full subclass chain for trait-object values.
- `Dynamic` boxing requires `Clone`: values passed through `hxrt::dynamic::from(...)` (printing, exception
  payloads, some std APIs) must be Rust-`Clone`. Most Haxe values are (`String`, `HxRef<T>`, `Array<T>`, etc.),
  but some extern/native types may need a wrapper API.

## Smoke tests

The following snapshot tests act as a living executable spec for the supported surface:

- `test/snapshot/tier1_stdlib`
- `test/snapshot/enum_switch`
- `test/snapshot/interface_basic`
- `test/snapshot/properties_accessors`
- `test/snapshot/v1_smoke` (added specifically for this doc)
