# v1.0 Support Matrix (Draft)

This document defines what “v1.0” means for `reflaxe.rust`: which Haxe features and std modules are
considered supported, which profiles exist, and what the default build workflow looks like.

It is intentionally conservative: if something is not listed here, treat it as “may compile, but not
part of the stability contract yet”.

## Build workflow (native by default)

Minimal compile:

- `haxe -lib reflaxe.rust -D rust_output=out -main Main`

Defaults:

- Generates a Cargo crate in `out/` (with `hxrt` runtime bundled).
- Runs `cargo build` best-effort after codegen (debug profile).

Opt-outs / knobs:

- Codegen-only: `-D rust_no_build` (alias: `-D rust_codegen_only`)
- Release build: `-D rust_release` (alias: `-D rust_build_release`)
- Run rustfmt after codegen: `-D rustfmt`
- Choose Cargo subcommand: `-D rust_cargo_subcommand=build|check|test|clippy|run`
- Pass target triple: `-D rust_target=<triple>`

## Profiles

Profiles are compile-time flags that trade “Haxe portability” vs “Rust idioms”.

Set via:

- `-D reflaxe_rust_profile=portable|idiomatic|rusty`

### Portable (default)

- Prioritizes Haxe semantics and portability.
- Uses runtime wrappers when Rust ownership would otherwise conflict with Haxe expectations
  (example: `Array<T>` aliases on assignment).

### Idiomatic

- Same semantics as Portable, but emits cleaner Rust where possible (clone elision, cleaner blocks,
  warning-free output).
- Example: when passing `String` arguments, the compiler only clones *locals* (to preserve Haxe’s
  “strings are reusable after calls” behavior). Temporary string expressions (like concatenations or
  function-call results) are moved without an extra `.clone()` to keep output clean.

### Rusty

- Opt-in mode for developers who want to integrate with Rust concepts more directly.
- Adds “borrow scoped” helper APIs (`rust.Borrow`, `rust.SliceTools`, `rust.MutSliceTools`, etc.).
- Still aims to keep app code “pure Haxe” (no direct `__rust__` in examples/apps).

## “No injection in apps” rule

Policy:

- Apps/examples should not call `__rust__` directly.
- Put injections behind Haxe APIs in `std/rust/*` (escape hatch still exists, but should be rare).

Enforcement:

- Examples and snapshot tests compile with `-D reflaxe_rust_strict_examples`.

## Supported language features (v1.0 target)

This list is the minimum surface expected to remain stable for v1.0:

- Expressions: literals, locals, assignment, unary/binary ops
- Equality: `==` / `!=` for objects and arrays uses Haxe identity semantics
- Control flow: blocks, if/else, while, for-range, for-iter
- Functions: calls, closures/function values
- Types: classes, interfaces, inheritance (portable dispatch model)
- Enums + `switch` lowering to Rust `match`
- Exceptions: throw + try/catch
- Generics: common cases used by std and rusty helpers

Known gaps (not v1.0 yet):

- (keep this section small; add new gaps only when they are genuinely blocking)

## Core stdlib + overrides

The Rust target ships a small Rust runtime crate (`runtime/hxrt`) and overrides a subset of the Haxe
stdlib in `std/` to ensure predictable semantics.

Notable items:

- `Array<T>` maps to `hxrt::array::Array<T>` (shared `Rc<RefCell<Vec<T>>>`)
- `haxe.io.Bytes` maps to a runtime buffer type (`hxrt::bytes::Bytes`)

## Rusty API layer (selected)

The `std/rust/*` package provides Rust-leaning APIs that remain “Haxe shaped”:

- Ownership/borrows: `rust.Ref<T>`, `rust.MutRef<T>`, `rust.Borrow.withRef/withMut`
- Collections: `rust.Vec<T>`, `rust.HashMap<K,V>` (+ Tools)
- Slices: `rust.Slice<T>`, `rust.MutSlice<T>`, `rust.SliceTools`, `rust.MutSliceTools`
  - Works on `rust.Vec<T>` and (in Rusty profile) on `Array<T>` without cloning.
- Option/Result: `rust.Option<T>`, `rust.Result<T,E>` (+ Tools)

## Known limitations (v1.0 non-goals)

- Full Rust lifetime modeling: Haxe has no lifetime syntax; borrow helpers must keep borrows scoped.
- Zero-cost output everywhere: correctness and predictability beat “perfectly idiomatic Rust” in Portable.
- Total stdlib parity: the supported std surface will expand over time, but v1.0 is a curated subset.

## Smoke tests

The following snapshot tests act as a living executable spec for the supported surface:

- `test/snapshot/tier1_stdlib`
- `test/snapshot/enum_switch`
- `test/snapshot/interface_basic`
- `test/snapshot/v1_smoke` (added specifically for this doc)
