# Lifetime Encoding Design (Can We Encode Lifetimes In Haxe?)

This document answers a recurring question:

> Can `reflaxe.rust` encode Rust lifetimes from Haxe code?

Short answer:

- **Yes, partially**, with scoped patterns and compiler checks.
- **No, not fully**, in the same way handwritten Rust exposes generic lifetime parameters.

## Why This Is Hard

Rust lifetimes are part of Rust's type language. Haxe does not have:

- explicit lifetime parameters (`'a`, `'b`, ...)
- higher-ranked lifetime syntax
- a native borrow checker with lifetime inference rules equivalent to Rust

So a direct 1:1 language mapping is not available.

## What We Already Have

Today, Rusty profile already encodes useful lifetime-like intent through:

- borrow token types: `rust.Ref<T>`, `rust.MutRef<T>`, `rust.Slice<T>`, `rust.Str`
- scoped helpers: `rust.Borrow.withRef/withMut`, `rust.SliceTools.with`, `rust.MutSliceTools.with`
- runtime/callback boundaries that force borrows to remain short-lived

This is a practical "lexical lifetime" encoding strategy.

## What Is Not Currently Possible

These are not realistically expressible as first-class Haxe signatures in v1:

- generic API shapes that expose explicit lifetime parameters to users
- complex lifetime relationships across multiple return values and trait bounds
- full parity with Rust's non-lexical lifetime reasoning

## Candidate Compiler Designs

### 1) Scoped Region API (Incremental, low risk)

Keep the existing callback-scoped model and expand it consistently:

- enter a borrow scope
- create borrow tokens only inside that scope
- reject or warn when borrow tokens escape the scope

Pseudo-shape:

```haxe
Borrow.withRef(value, r -> {
  // r: rust.Ref<T>, valid only in this callback
  return useRef(r);
});
```

Pros:

- very compatible with current architecture
- easy to explain to users
- aligns well with Rust lexical borrow intuition

Cons:

- cannot express reusable generic lifetime APIs

### 2) Phantom Region Types (Medium risk, medium payoff)

Introduce internal "region ids" as phantom type parameters generated by macros/compiler:

- `ScopedRef<R, T>`
- `ScopedMutRef<R, T>`
- each `R` is fresh per scope

Then require region equality at use sites to prevent cross-scope leakage.

Pros:

- stronger static constraints in Haxe typing than plain `Ref<T>`
- clearer compile-time errors for escaped borrows

Cons:

- adds significant type-system complexity to user-facing APIs
- still cannot fully model all Rust lifetime features

### 3) Borrow Checker Pass In Compiler (Higher risk, high payoff)

Add a Rusty-only semantic pass over typed AST:

- track borrow creation/usage sites
- detect obvious aliasing/escape violations early
- emit targeted diagnostics before Rust codegen

Pros:

- better UX than relying only on downstream Rust errors
- can prevent known invalid patterns earlier

Cons:

- complex to implement and maintain
- may diverge from Rust behavior if rules are approximated poorly

### 4) Extern "Lifetime Islands" (Current practical fallback)

For APIs that truly need full lifetime power:

- expose a typed Haxe facade
- implement lifetime-heavy internals in handwritten Rust extern modules

Pros:

- full Rust expressiveness where needed
- keeps normal app code clean

Cons:

- split mental model (Haxe facade + Rust internals)

## Recommended Direction

For near-term compiler evolution:

1. Keep callback-scoped borrow APIs as the main user model.
2. Add stronger static non-escape checks in Rusty profile (warnings -> errors over time).
3. Introduce phantom-region typing only where it clearly improves correctness without harming ergonomics.
4. Keep lifetime-heavy generic patterns in extern Rust modules behind typed Haxe APIs.

This gives meaningful lifetime safety gains without pretending to fully replace Rust's lifetime language.

## Profile Relation

- `portable` / `idiomatic`: prefer owned/high-level APIs; lifetimes stay mostly an implementation detail.
- `rusty`: opt into borrow-aware APIs and scoped lifetime-like patterns deliberately.

See also:

- [Profiles](profiles.md)
- [Rusty profile](rusty-profile.md)
