package reflaxe.rust;

#if (macro || reflaxe_runtime)

import haxe.macro.Context;
import haxe.ds.Either;
import haxe.io.Path;
import haxe.macro.Expr.Binop;
import haxe.macro.Expr.Unop;
import haxe.macro.Type;
import haxe.macro.TypeTools;
import reflaxe.GenericCompiler;
import reflaxe.compiler.TypeUsageTracker.TypeOrModuleType;
import reflaxe.compiler.TargetCodeInjection;
import reflaxe.data.ClassFuncData;
import reflaxe.data.ClassVarData;
import reflaxe.data.EnumOptionData;
import reflaxe.output.DataAndFileInfo;
import reflaxe.output.OutputPath;
import reflaxe.output.StringOrBytes;
import reflaxe.rust.ast.RustAST;
import reflaxe.rust.ast.RustAST.RustBlock;
import reflaxe.rust.ast.RustAST.RustExpr;
import reflaxe.rust.ast.RustAST.RustFile;
import reflaxe.rust.ast.RustAST.RustItem;
import reflaxe.rust.ast.RustAST.RustStmt;
import reflaxe.helpers.TypeHelper;

using reflaxe.helpers.BaseTypeHelper;
using reflaxe.helpers.ClassFieldHelper;

/**
 * RustCompiler (POC)
 *
 * Emits a minimal Rust program for the Haxe main class.
 *
 * Architecture:
 * - Typed Haxe AST -> Rust AST (Builder-ish logic lives here for now)
 * - Rust AST -> string via RustASTPrinter (RustOutputIterator)
 * - Cargo.toml emitted as an extra file at compile end
 */
class RustCompiler extends GenericCompiler<RustFile, RustFile, RustExpr, RustFile, RustFile> {
	var didEmitMain: Bool = false;
	var crateName: String = "hx_app";
	var mainBaseType: Null<BaseType> = null;
	var currentClassKey: Null<String> = null;
	var currentClassName: Null<String> = null;

	public function new() {
		super();
	}

	public function createCompilationContext(): CompilationContext {
		return new CompilationContext(crateName);
	}

	public function generateOutputIterator(): Iterator<DataAndFileInfo<StringOrBytes>> {
		return new RustOutputIterator(this);
	}

	override public function onCompileStart() {
		// Allow overriding crate name with -D rust_crate=<name>
		var v = Context.definedValue("rust_crate");
		if (v != null && v.length > 0) crateName = v;
	}

	override public function onCompileEnd() {
		// POC Cargo project. Keep dependencies empty for now.
		if (!didEmitMain) {
			// No main class emitted; don't generate Cargo.toml.
			return;
		}

		var cargo = [
			"[package]",
			'name = "' + crateName + '"',
			'version = "0.0.1"',
			'edition = "2021"',
			"",
			"[dependencies]",
			""
		].join("\n");
		setExtraFile(OutputPath.fromStr("Cargo.toml"), cargo);
	}

	public function compileClassImpl(classType: ClassType, varFields: Array<ClassVarData>, funcFields: Array<ClassFuncData>): Null<RustFile> {
		var isMain = isMainClass(classType);
		if (!shouldEmitClass(classType, isMain)) return null;

		// Ensure this lands at <rust_output>/src/main.rs
		setOutputFileDir("src");
		if (isMain) {
			setOutputFileName("main");
			didEmitMain = true;
			mainBaseType = classType;
		} else {
			setOutputFileName(rustModuleNameForClass(classType));
		}

		currentClassKey = classKey(classType);
		currentClassName = classType.name;

		var items: Array<RustItem> = [];
		items.push(RRaw("// Generated by reflaxe.rust (POC)"));

		if (isMain) {
			var otherUserClasses = getUserClassesForModules();
			if (otherUserClasses.length > 0) {
				items.push(RRaw([
					"use std::cell::RefCell;",
					"use std::rc::Rc;",
					"",
					"type HxRef<T> = Rc<RefCell<T>>;"
				].join("\n")));

				var modLines: Array<String> = [];
				for (cls in otherUserClasses) {
					var modName = rustModuleNameForClass(cls);
					modLines.push("mod " + modName + ";");
					modLines.push("use crate::" + modName + "::" + cls.name + ";");
				}
				items.push(RRaw(modLines.join("\n")));
			}
		} else {
			items.push(RRaw([
				"use crate::HxRef;",
				"use std::cell::RefCell;",
				"use std::rc::Rc;"
			].join("\n")));

			var structFields: Array<reflaxe.rust.ast.RustAST.RustStructField> = [];
			for (v in varFields) {
				if (v.isStatic) continue;
				structFields.push({
					name: v.field.getHaxeName(),
					ty: toRustType(v.field.type, v.field.pos),
					isPub: v.field.isPublic
				});
			}

			items.push(RStruct({
				name: classType.name,
				isPub: true,
				fields: structFields
			}));

			var implFunctions: Array<reflaxe.rust.ast.RustAST.RustFunction> = [];

			// Constructor (`new`)
			var ctor = findConstructor(funcFields);
			if (ctor != null) {
				implFunctions.push(compileConstructor(classType, varFields, ctor));
			}

			// Instance methods
			for (f in funcFields) {
				if (f.isStatic) continue;
				if (f.field.getHaxeName() == "new") continue;
				if (f.expr == null) continue;
				implFunctions.push(compileInstanceMethod(classType, f));
			}

			items.push(RImpl({
				forType: classType.name,
				functions: implFunctions
			}));
		}

		if (isMain) {
			// Emit any additional static functions so user code can call them from `main`.
			for (f in funcFields) {
				if (!f.isStatic) continue;
				if (f.expr == null) continue;

				var haxeName = f.field.getHaxeName();
				if (haxeName == "main") continue;

				var args: Array<reflaxe.rust.ast.RustAST.RustFnArg> = [];
				for (a in f.args) {
					args.push({
						name: a.getName(),
						ty: toRustType(a.type, f.field.pos)
					});
				}

				items.push(RFn({
					name: haxeName,
					isPub: false,
					args: args,
					ret: toRustType(f.ret, f.field.pos),
					body: compileFunctionBody(f.expr, f.ret)
				}));
			}

			var mainFunc = findStaticMain(funcFields);
			var body: RustBlock = (mainFunc != null && mainFunc.expr != null)
				? compileFunctionBody(mainFunc.expr, mainFunc.ret)
				: defaultMainBody();

			items.push(RFn({
				name: "main",
				isPub: false,
				args: [],
				ret: RUnit,
				body: body
			}));
		}

		currentClassKey = null;
		currentClassName = null;
		return { items: items };
	}

	public function compileEnumImpl(enumType: EnumType, options: Array<EnumOptionData>): Null<RustFile> {
		return null;
	}

	override public function compileTypedefImpl(typedefType: DefType): Null<RustFile> {
		return null;
	}

	override public function compileAbstractImpl(abstractType: AbstractType): Null<RustFile> {
		return null;
	}

	public function compileExpressionImpl(expr: TypedExpr, topLevel: Bool): Null<RustExpr> {
		// Target code injection: __rust__("...", [args...])
		var injected = TargetCodeInjection.checkTargetCodeInjectionGeneric(options.targetCodeInjectionName ?? "__rust__", expr, this);
		if (injected != null) {
			var rendered = new StringBuf();
			for (part in injected) {
				switch (part) {
					case Left(s): rendered.add(s);
					case Right(e): rendered.add(reflaxe.rust.ast.RustASTPrinter.printExprForInjection(e));
				}
			}
			return ERaw(rendered.toString());
		}

		return compileExpr(expr);
	}

	function isMainClass(classType: ClassType): Bool {
		var m = getMainModule();
		return switch (m) {
			case TClassDecl(clsRef): {
				var mainCls = clsRef.get();
				(mainCls.module == classType.module && mainCls.name == classType.name && mainCls.pack.join(".") == classType.pack.join("."));
			}
			case _: false;
		}
	}

	function findStaticMain(funcFields: Array<ClassFuncData>): Null<ClassFuncData> {
		for (f in funcFields) {
			if (!f.isStatic) continue;
			if (f.field.getHaxeName() != "main") continue;
			return f;
		}
		return null;
	}

	function defaultMainBody(): RustBlock {
		return {
			stmts: [
				RSemi(EMacroCall("println", [ELitString("hi")]))
			],
			tail: null
		};
	}

	function shouldEmitClass(classType: ClassType, isMain: Bool): Bool {
		if (isMain) return true;
		if (classType.isExtern) return false;
		var file = Context.getPosInfos(classType.pos).file;
		return isUserProjectFile(file);
	}

	function isUserProjectFile(file: String): Bool {
		var cwd = Path.normalize(Sys.getCwd());
		var full = file;
		if (!Path.isAbsolute(full)) {
			full = Path.join([cwd, full]);
		}
		full = Path.normalize(full);
		return StringTools.startsWith(full, cwd);
	}

	function classKey(classType: ClassType): String {
		return classType.pack.join(".") + "." + classType.name;
	}

	function rustModuleNameForClass(classType: ClassType): String {
		var base = (classType.pack.length > 0 ? (classType.pack.join("_") + "_") : "") + classType.name;
		return toSnakeCase(base);
	}

	function toSnakeCase(s: String): String {
		var out = new StringBuf();
		for (i in 0...s.length) {
			var ch = s.charAt(i);
			var lower = ch.toLowerCase();
			var isUpper = (ch != lower);
			if (isUpper && i > 0) out.add("_");
			out.add(lower);
		}
		return out.toString();
	}

	function getUserClassesForModules(): Array<ClassType> {
		var out: Array<ClassType> = [];
		var seen = new Map<String, Bool>();

		var usage = getTypeUsage();
		if (usage == null) return out;

		for (level in usage.keys()) {
			var list = usage.get(level);
			if (list == null) continue;
			for (entry in list) {
				switch (entry) {
					case EModuleType(mt): {
						switch (mt) {
							case TClassDecl(clsRef): {
								var cls = clsRef.get();
								if (cls == null) continue;
								if (isMainClass(cls)) continue;
								if (!shouldEmitClass(cls, false)) continue;

								var key = classKey(cls);
								if (seen.exists(key)) continue;
								seen.set(key, true);
								out.push(cls);
							}
							case _:
						}
					}
					case _:
				}
			}
		}

		return out;
	}

	function findConstructor(funcFields: Array<ClassFuncData>): Null<ClassFuncData> {
		for (f in funcFields) {
			if (f.isStatic) continue;
			if (f.field.getHaxeName() != "new") continue;
			return f;
		}
		return null;
	}

	function defaultValueForType(t: Type, pos: haxe.macro.Expr.Position): String {
		if (TypeHelper.isBool(t)) return "false";
		if (TypeHelper.isInt(t)) return "0";
		if (TypeHelper.isFloat(t)) return "0.0";
		if (TypeHelper.isString(t)) return "String::new()";

		#if eval
		Context.error("Unsupported field type in class POC: " + Std.string(t), pos);
		#end
		return "Default::default()";
	}

	function compileConstructor(classType: ClassType, varFields: Array<ClassVarData>, f: ClassFuncData): reflaxe.rust.ast.RustAST.RustFunction {
		var args: Array<reflaxe.rust.ast.RustAST.RustFnArg> = [];
		for (a in f.args) {
			args.push({
				name: a.getName(),
				ty: toRustType(a.type, f.field.pos)
			});
		}

		var fieldInits: Array<String> = [];
		for (v in varFields) {
			if (v.isStatic) continue;
			fieldInits.push(v.field.getHaxeName() + ": " + defaultValueForType(v.field.type, v.field.pos));
		}
		var structInit = classType.name + " { " + fieldInits.join(", ") + " }";
		var allocExpr = "Rc::new(RefCell::new(" + structInit + "))";

		var stmts: Array<RustStmt> = [];
		stmts.push(RLet(
			"self_",
			true,
			RPath("HxRef<" + classType.name + ">"),
			ERaw(allocExpr)
		));

		if (f.expr != null) {
			var bodyBlock = compileFunctionBody(f.expr, f.ret);
			for (s in bodyBlock.stmts) stmts.push(s);
			if (bodyBlock.tail != null) stmts.push(RSemi(bodyBlock.tail));
		}

		stmts.push(RReturn(EPath("self_")));

		return {
			name: "new",
			isPub: true,
			args: args,
			ret: RPath("HxRef<" + classType.name + ">"),
			body: { stmts: stmts, tail: null }
		};
	}

	function compileInstanceMethod(classType: ClassType, f: ClassFuncData): reflaxe.rust.ast.RustAST.RustFunction {
		var args: Array<reflaxe.rust.ast.RustAST.RustFnArg> = [];
		args.push({
			name: "self_",
			ty: RPath("&HxRef<" + classType.name + ">")
		});
		for (a in f.args) {
			args.push({
				name: a.getName(),
				ty: toRustType(a.type, f.field.pos)
			});
		}

		var body = f.expr != null ? compileFunctionBody(f.expr, f.ret) : { stmts: [], tail: null };

		return {
			name: f.field.getHaxeName(),
			isPub: f.field.isPublic,
			args: args,
			ret: toRustType(f.ret, f.field.pos),
			body: body
		};
	}

	function compileFunctionBody(e: TypedExpr, expectedReturn: Null<Type> = null): RustBlock {
		var allowTail = true;
		if (expectedReturn != null && TypeHelper.isVoid(expectedReturn)) {
			allowTail = false;
		}

		return switch (e.expr) {
			case TBlock(exprs): compileBlock(exprs, allowTail);
			case _: {
				// Single-expression function body
				{ stmts: [compileStmt(e)], tail: null };
			}
		}
	}

	function compileBlock(exprs: Array<TypedExpr>, allowTail: Bool = true): RustBlock {
		var stmts: Array<RustStmt> = [];
		var tail: Null<RustExpr> = null;

		for (i in 0...exprs.length) {
			var e = exprs[i];
			var isLast = (i == exprs.length - 1);

			if (allowTail && isLast && !TypeHelper.isVoid(e.t) && !isStmtOnlyExpr(e)) {
				tail = compileExpr(e);
				break;
			}

			stmts.push(compileStmt(e));
		}

		return { stmts: stmts, tail: tail };
	}

	function isStmtOnlyExpr(e: TypedExpr): Bool {
		return switch (e.expr) {
			case TVar(_, _): true;
			case TReturn(_): true;
			case _: false;
		}
	}

	function compileStmt(e: TypedExpr): RustStmt {
		return switch (e.expr) {
			case TVar(v, init): {
				var name = v.name;
				var initExpr = init != null ? compileExpr(init) : null;
				// POC: default to `let mut` for simplicity.
				RLet(name, true, null, initExpr);
			}
			case TReturn(ret): {
				var ex = ret != null ? compileExpr(ret) : null;
				RReturn(ex);
			}
			case _: {
				RSemi(compileExpr(e));
			}
		}
	}

	function compileExpr(e: TypedExpr): RustExpr {
			return switch (e.expr) {
				case TConst(c): switch (c) {
					case TInt(v): ELitInt(v);
					case TFloat(s): ELitFloat(Std.parseFloat(s));
					case TString(s): ECall(EPath("String::from"), [ELitString(s)]);
					case TBool(b): ELitBool(b);
					case TNull: ERaw("None");
					case TThis: EPath("self_");
					case _: unsupported(e, "const");
				}

			case TLocal(v):
				EPath(v.name);

			case TBinop(op, e1, e2):
				compileBinop(op, e1, e2, e);

			case TUnop(op, postFix, expr):
				compileUnop(op, postFix, expr, e);

			case TIf(cond, eThen, eElse):
				EIf(compileExpr(cond), compileBranchExpr(eThen), eElse != null ? compileBranchExpr(eElse) : null);

			case TBlock(exprs):
				EBlock(compileBlock(exprs));

			case TCall(callExpr, args):
				compileCall(callExpr, args, e);

			case TNew(clsRef, _, args): {
				var cls = clsRef.get();
				ECall(EPath(cls.name + "::new"), [for (x in args) compileExpr(x)]);
			}

			case TField(obj, fa):
				compileField(obj, fa, e);

			default:
				unsupported(e, "expr");
		}
	}

	function compileBranchExpr(e: TypedExpr): RustExpr {
		return switch (e.expr) {
			case TBlock(_):
				EBlock(compileFunctionBody(e));
			case _:
				compileExpr(e);
		}
	}

	function compileCall(callExpr: TypedExpr, args: Array<TypedExpr>, fullExpr: TypedExpr): RustExpr {
		// Special-case: haxe.Log.trace(value, posInfos)
		switch (callExpr.expr) {
			case TField(_, FStatic(clsRef, fieldRef)):
				var cls = clsRef.get();
				var field = fieldRef.get();
				if (cls.pack.join(".") == "haxe" && cls.name == "Log" && field.name == "trace") {
					var value = args.length > 0 ? compileExpr(args[0]) : ELitString("");
					return compileTrace(value, args.length > 0 ? args[0].t : fullExpr.t);
				}
			case _:
		}

		// Instance method call: obj.method(args...) => Class::method(&obj, args...)
		switch (callExpr.expr) {
			case TField(obj, FInstance(_, _, cfRef)): {
				var cf = cfRef.get();
				switch (cf.kind) {
					case FMethod(_): {
						var clsName = classNameFromType(obj.t);
						if (clsName == null) return unsupported(fullExpr, "instance method call");
						var callArgs: Array<RustExpr> = [EUnary("&", compileExpr(obj))];
						for (x in args) callArgs.push(compileExpr(x));
						return ECall(EPath(clsName + "::" + cf.getHaxeName()), callArgs);
					}
					case _:
				}
			}
			case _:
		}

		var f = compileExpr(callExpr);
		var a = [for (x in args) compileExpr(x)];
		return ECall(f, a);
	}

		function compileTrace(valueExpr: RustExpr, valueType: Type): RustExpr {
			// Use `{}` for common primitives/strings; fall back to `{:?}`.
			var t = followType(valueType);
			var fmt = if (isStringType(t) || TypeHelper.isInt(t) || TypeHelper.isFloat(t) || TypeHelper.isBool(t)) {
				"{}";
			} else {
				"{:?}";
			}
			return EMacroCall("println", [ELitString(fmt), valueExpr]);
		}

	function compileField(obj: TypedExpr, fa: FieldAccess, fullExpr: TypedExpr): RustExpr {
		return switch (fa) {
			case FStatic(clsRef, cfRef): {
				var cls = clsRef.get();
				var cf = cfRef.get();
				var key = cls.pack.join(".") + "." + cls.name;
				if (currentClassKey != null && key == currentClassKey) {
					EPath(cf.getHaxeName());
				} else {
					EPath(cls.name + "::" + cf.getHaxeName());
				}
			}
			case FInstance(_, _, cfRef): {
				var cf = cfRef.get();
				switch (cf.kind) {
					case FMethod(_):
						unsupported(fullExpr, "method value");
					case _:
						compileInstanceFieldRead(obj, cf, fullExpr);
				}
			}
			case FAnon(cfRef): {
				var cf = cfRef.get();
				EField(compileExpr(obj), cf.getHaxeName());
			}
			case FDynamic(name): EField(compileExpr(obj), name);
			case _: unsupported(fullExpr, "field");
		}
	}

	function compileInstanceFieldRead(obj: TypedExpr, cf: ClassField, fullExpr: TypedExpr): RustExpr {
		var recv = compileExpr(obj);
		var borrowed = ECall(EField(recv, "borrow"), []);
		var access = EField(borrowed, cf.getHaxeName());

		// For non-Copy types, cloning is the simplest POC rule.
		if (!TypeHelper.isBool(fullExpr.t) && !TypeHelper.isInt(fullExpr.t) && !TypeHelper.isFloat(fullExpr.t)) {
			return ECall(EField(access, "clone"), []);
		}

		return access;
	}

	function compileInstanceFieldAssign(obj: TypedExpr, cf: ClassField, rhs: TypedExpr): RustExpr {
		// Important: evaluate RHS before taking a mutable borrow to avoid RefCell borrow panics.
		// `{ let __tmp = rhs; obj.borrow_mut().field = __tmp.clone(); __tmp }`
		var stmts: Array<RustStmt> = [];

		stmts.push(RLet("__tmp", false, null, compileExpr(rhs)));

		var recv = compileExpr(obj);
		var borrowed = ECall(EField(recv, "borrow_mut"), []);
		var access = EField(borrowed, cf.getHaxeName());
		var rhsClone = ECall(EField(EPath("__tmp"), "clone"), []);
		stmts.push(RSemi(EAssign(access, rhsClone)));

		return EBlock({
			stmts: stmts,
			tail: EPath("__tmp")
		});
	}

	function classNameFromType(t: Type): Null<String> {
		var ft = TypeTools.follow(t);
		return switch (ft) {
			case TInst(clsRef, _): clsRef.get().name;
			case _: null;
		}
	}

	function compileBinop(op: Binop, e1: TypedExpr, e2: TypedExpr, fullExpr: TypedExpr): RustExpr {
		return switch (op) {
			case OpAssign:
				switch (e1.expr) {
					case TField(obj, FInstance(_, _, cfRef)): {
						var cf = cfRef.get();
						switch (cf.kind) {
							case FVar(_, _):
								compileInstanceFieldAssign(obj, cf, e2);
							case _:
								EAssign(compileExpr(e1), compileExpr(e2));
						}
					}
					case _:
						EAssign(compileExpr(e1), compileExpr(e2));
				}

			case OpAdd:
				var ft = followType(fullExpr.t);
				if (isStringType(ft) || isStringType(followType(e1.t)) || isStringType(followType(e2.t))) {
					// POC: string concatenation via `format!`.
					EMacroCall("format", [ELitString("{}{}"), compileExpr(e1), compileExpr(e2)]);
				} else {
					EBinary("+", compileExpr(e1), compileExpr(e2));
				}

			case OpSub: EBinary("-", compileExpr(e1), compileExpr(e2));
			case OpMult: EBinary("*", compileExpr(e1), compileExpr(e2));
			case OpDiv: EBinary("/", compileExpr(e1), compileExpr(e2));

			case OpEq: EBinary("==", compileExpr(e1), compileExpr(e2));
			case OpNotEq: EBinary("!=", compileExpr(e1), compileExpr(e2));
			case OpLt: EBinary("<", compileExpr(e1), compileExpr(e2));
			case OpLte: EBinary("<=", compileExpr(e1), compileExpr(e2));
			case OpGt: EBinary(">", compileExpr(e1), compileExpr(e2));
			case OpGte: EBinary(">=", compileExpr(e1), compileExpr(e2));
			case OpBoolAnd: EBinary("&&", compileExpr(e1), compileExpr(e2));
			case OpBoolOr: EBinary("||", compileExpr(e1), compileExpr(e2));

			default:
				unsupported(fullExpr, "binop" + Std.string(op));
		}
	}

	function compileUnop(op: Unop, postFix: Bool, expr: TypedExpr, fullExpr: TypedExpr): RustExpr {
		if (postFix) {
			return unsupported(fullExpr, "postfix unop");
		}

		return switch (op) {
			case OpNot: EUnary("!", compileExpr(expr));
			case OpNeg: EUnary("-", compileExpr(expr));
			default: unsupported(fullExpr, "unop" + Std.string(op));
		}
	}

	function followType(t: Type): Type {
		#if eval
		return Context.followWithAbstracts(TypeTools.follow(t));
		#else
		return TypeTools.follow(t);
		#end
	}

	function isStringType(t: Type): Bool {
		var ft = followType(t);
		if (TypeHelper.isString(ft)) return true;
		return switch (ft) {
			case TInst(clsRef, []): {
				var cls = clsRef.get();
				var isNameString = cls.meta.has(":native") || cls.name == "String";
				isNameString && cls.module == "String" && cls.pack.length == 0;
			}
			case TAbstract(absRef, []): {
				var abs = absRef.get();
				abs.module == "StdTypes" && abs.name == "String";
			}
			case _: false;
		}
	}

	function unsupported(e: TypedExpr, what: String): RustExpr {
		#if eval
		Context.error('Unsupported $what for Rust POC: ' + Std.string(e.expr), e.pos);
		#end
		return ERaw("todo!()");
	}

	function toRustType(t: Type, pos: haxe.macro.Expr.Position): reflaxe.rust.ast.RustAST.RustType {
		var ft = TypeTools.follow(t);
		if (TypeHelper.isVoid(t)) return RUnit;
		if (TypeHelper.isBool(t)) return RBool;
		if (TypeHelper.isInt(t)) return RI32;
		if (TypeHelper.isFloat(t)) return RF64;
		if (isStringType(ft)) return RString;

		return switch (ft) {
			case TInst(clsRef, _): {
				var cls = clsRef.get();
				RPath("HxRef<" + cls.name + ">");
			}
			case _: {
				#if eval
				Context.error("Unsupported Rust type in POC: " + Std.string(t), pos);
				#end
				RUnit;
			}
		}
	}
}

#end
